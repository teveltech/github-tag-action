var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function toCommandValue(input) {
    if (input === null || input === void 0) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  exports2.toCommandValue = toCommandValue;
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var os = __importStar(require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  exports2.issueCommand = issueCommand;
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  exports2.issue = issue;
  var CMD_STRING = "::";
  var Command = class {
    constructor(command, properties, message) {
      if (!command) {
        command = "missing.command";
      }
      this.command = command;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  };
  function escapeData(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs = __importStar(require("fs"));
  var os = __importStar(require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  exports2.issueCommand = issueCommand;
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(require("os"));
  var path = __importStar(require("path"));
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
  function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      const delimiter = "_GitHubActionsFileCommandDelimeter_";
      const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
      file_command_1.issueCommand("ENV", commandValue);
    } else {
      command_1.issueCommand("set-env", {name}, convertedVal);
    }
  }
  exports2.exportVariable = exportVariable;
  function setSecret(secret) {
    command_1.issueCommand("add-mask", {}, secret);
  }
  exports2.setSecret = setSecret;
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      file_command_1.issueCommand("PATH", inputPath);
    } else {
      command_1.issueCommand("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
  }
  exports2.addPath = addPath;
  function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    return val.trim();
  }
  exports2.getInput = getInput;
  function setOutput(name, value) {
    command_1.issueCommand("set-output", {name}, value);
  }
  exports2.setOutput = setOutput;
  function setCommandEcho(enabled) {
    command_1.issue("echo", enabled ? "on" : "off");
  }
  exports2.setCommandEcho = setCommandEcho;
  function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
  }
  exports2.setFailed = setFailed;
  function isDebug() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  exports2.isDebug = isDebug;
  function debug(message) {
    command_1.issueCommand("debug", {}, message);
  }
  exports2.debug = debug;
  function error(message) {
    command_1.issue("error", message instanceof Error ? message.toString() : message);
  }
  exports2.error = error;
  function warning(message) {
    command_1.issue("warning", message instanceof Error ? message.toString() : message);
  }
  exports2.warning = warning;
  function info(message) {
    process.stdout.write(message + os.EOL);
  }
  exports2.info = info;
  function startGroup(name) {
    command_1.issue("group", name);
  }
  exports2.startGroup = startGroup;
  function endGroup() {
    command_1.issue("endgroup");
  }
  exports2.endGroup = endGroup;
  function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
      startGroup(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup();
      }
      return result;
    });
  }
  exports2.group = group;
  function saveState(name, value) {
    command_1.issueCommand("save-state", {name}, value);
  }
  exports2.saveState = saveState;
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  exports2.getState = getState;
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports2, module2) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.20";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag2(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag2(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index, value};
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag2(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrim, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimEnd, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports2);
});

// node_modules/trim-off-newlines/index.js
var require_trim_off_newlines = __commonJS((exports2, module2) => {
  "use strict";
  var regex = /^(?:\r\n|\n|\r)+|(?:\r\n|\n|\r)+$/g;
  module2.exports = function(str) {
    return str.replace(regex, "");
  };
});

// node_modules/conventional-commits-parser/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  "use strict";
  var trimOffNewlines = require_trim_off_newlines();
  var _ = require_lodash();
  var CATCH_ALL = /()(.+)/gi;
  var SCISSOR = "# ------------------------ >8 ------------------------";
  function append(src, line) {
    if (src) {
      src += "\n" + line;
    } else {
      src = line;
    }
    return src;
  }
  function getCommentFilter(char) {
    return function(line) {
      return line.charAt(0) !== char;
    };
  }
  function truncateToScissor(lines) {
    const scissorIndex = lines.indexOf(SCISSOR);
    if (scissorIndex === -1) {
      return lines;
    }
    return lines.slice(0, scissorIndex);
  }
  function getReferences(input, regex) {
    const references = [];
    let referenceSentences;
    let referenceMatch;
    const reApplicable = input.match(regex.references) !== null ? regex.references : CATCH_ALL;
    while (referenceSentences = reApplicable.exec(input)) {
      const action = referenceSentences[1] || null;
      const sentence = referenceSentences[2];
      while (referenceMatch = regex.referenceParts.exec(sentence)) {
        let owner = null;
        let repository = referenceMatch[1] || "";
        const ownerRepo = repository.split("/");
        if (ownerRepo.length > 1) {
          owner = ownerRepo.shift();
          repository = ownerRepo.join("/");
        }
        const reference = {
          action,
          owner,
          repository: repository || null,
          issue: referenceMatch[3],
          raw: referenceMatch[0],
          prefix: referenceMatch[2]
        };
        references.push(reference);
      }
    }
    return references;
  }
  function passTrough() {
    return true;
  }
  function parser(raw, options, regex) {
    if (!raw || !raw.trim()) {
      throw new TypeError("Expected a raw commit");
    }
    if (_.isEmpty(options)) {
      throw new TypeError("Expected options");
    }
    if (_.isEmpty(regex)) {
      throw new TypeError("Expected regex");
    }
    let currentProcessedField;
    let mentionsMatch;
    const otherFields = {};
    const commentFilter = typeof options.commentChar === "string" ? getCommentFilter(options.commentChar) : passTrough;
    const gpgFilter = (line) => !line.match(/^\s*gpg:/);
    const rawLines = trimOffNewlines(raw).split(/\r?\n/);
    const lines = truncateToScissor(rawLines).filter(commentFilter).filter(gpgFilter);
    let continueNote = false;
    let isBody = true;
    const headerCorrespondence = _.map(options.headerCorrespondence, function(part) {
      return part.trim();
    });
    const revertCorrespondence = _.map(options.revertCorrespondence, function(field) {
      return field.trim();
    });
    const mergeCorrespondence = _.map(options.mergeCorrespondence, function(field) {
      return field.trim();
    });
    let body = null;
    let footer = null;
    let header = null;
    const mentions = [];
    let merge = null;
    const notes = [];
    const references = [];
    let revert = null;
    if (lines.length === 0) {
      return {
        body,
        footer,
        header,
        mentions,
        merge,
        notes,
        references,
        revert,
        scope: null,
        subject: null,
        type: null
      };
    }
    merge = lines.shift();
    const mergeParts = {};
    const headerParts = {};
    body = "";
    footer = "";
    const mergeMatch = merge.match(options.mergePattern);
    if (mergeMatch && options.mergePattern) {
      merge = mergeMatch[0];
      header = lines.shift();
      while (!header.trim()) {
        header = lines.shift();
      }
      _.forEach(mergeCorrespondence, function(partName, index) {
        const partValue = mergeMatch[index + 1] || null;
        mergeParts[partName] = partValue;
      });
    } else {
      header = merge;
      merge = null;
      _.forEach(mergeCorrespondence, function(partName) {
        mergeParts[partName] = null;
      });
    }
    const headerMatch = header.match(options.headerPattern);
    if (headerMatch) {
      _.forEach(headerCorrespondence, function(partName, index) {
        const partValue = headerMatch[index + 1] || null;
        headerParts[partName] = partValue;
      });
    } else {
      _.forEach(headerCorrespondence, function(partName) {
        headerParts[partName] = null;
      });
    }
    Array.prototype.push.apply(references, getReferences(header, {
      references: regex.references,
      referenceParts: regex.referenceParts
    }));
    _.forEach(lines, function(line) {
      if (options.fieldPattern) {
        const fieldMatch = options.fieldPattern.exec(line);
        if (fieldMatch) {
          currentProcessedField = fieldMatch[1];
          return;
        }
        if (currentProcessedField) {
          otherFields[currentProcessedField] = append(otherFields[currentProcessedField], line);
          return;
        }
      }
      let referenceMatched;
      const notesMatch = line.match(regex.notes);
      if (notesMatch) {
        continueNote = true;
        isBody = false;
        footer = append(footer, line);
        const note = {
          title: notesMatch[1],
          text: notesMatch[2]
        };
        notes.push(note);
        return;
      }
      const lineReferences = getReferences(line, {
        references: regex.references,
        referenceParts: regex.referenceParts
      });
      if (lineReferences.length > 0) {
        isBody = false;
        referenceMatched = true;
        continueNote = false;
      }
      Array.prototype.push.apply(references, lineReferences);
      if (referenceMatched) {
        footer = append(footer, line);
        return;
      }
      if (continueNote) {
        notes[notes.length - 1].text = append(notes[notes.length - 1].text, line);
        footer = append(footer, line);
        return;
      }
      if (isBody) {
        body = append(body, line);
      } else {
        footer = append(footer, line);
      }
    });
    if (options.breakingHeaderPattern && notes.length === 0) {
      const breakingHeader = header.match(options.breakingHeaderPattern);
      if (breakingHeader) {
        const noteText = breakingHeader[3];
        notes.push({
          title: "BREAKING CHANGE",
          text: noteText
        });
      }
    }
    while (mentionsMatch = regex.mentions.exec(raw)) {
      mentions.push(mentionsMatch[1]);
    }
    const revertMatch = raw.match(options.revertPattern);
    if (revertMatch) {
      revert = {};
      _.forEach(revertCorrespondence, function(partName, index) {
        const partValue = revertMatch[index + 1] || null;
        revert[partName] = partValue;
      });
    } else {
      revert = null;
    }
    _.map(notes, function(note) {
      note.text = trimOffNewlines(note.text);
      return note;
    });
    const msg = _.merge(headerParts, mergeParts, {
      merge,
      header,
      body: body ? trimOffNewlines(body) : null,
      footer: footer ? trimOffNewlines(footer) : null,
      notes,
      references,
      mentions,
      revert
    }, otherFields);
    return msg;
  }
  module2.exports = parser;
});

// node_modules/conventional-commits-parser/lib/regex.js
var require_regex = __commonJS((exports2, module2) => {
  "use strict";
  var reNomatch = /(?!.*)/;
  function join(array, joiner) {
    return array.map(function(val) {
      return val.trim();
    }).filter(function(val) {
      return val.length;
    }).join(joiner);
  }
  function getNotesRegex(noteKeywords, notesPattern) {
    if (!noteKeywords) {
      return reNomatch;
    }
    const noteKeywordsSelection = join(noteKeywords, "|");
    if (!notesPattern) {
      return new RegExp("^[\\s|*]*(" + noteKeywordsSelection + ")[:\\s]+(.*)", "i");
    }
    return notesPattern(noteKeywordsSelection);
  }
  function getReferencePartsRegex(issuePrefixes, issuePrefixesCaseSensitive) {
    if (!issuePrefixes) {
      return reNomatch;
    }
    const flags = issuePrefixesCaseSensitive ? "g" : "gi";
    return new RegExp("(?:.*?)??\\s*([\\w-\\.\\/]*?)??(" + join(issuePrefixes, "|") + ")([\\w-]*\\d+)", flags);
  }
  function getReferencesRegex(referenceActions) {
    if (!referenceActions) {
      return /()(.+)/gi;
    }
    const joinedKeywords = join(referenceActions, "|");
    return new RegExp("(" + joinedKeywords + ")(?:\\s+(.*?))(?=(?:" + joinedKeywords + ")|$)", "gi");
  }
  module2.exports = function(options) {
    options = options || {};
    const reNotes = getNotesRegex(options.noteKeywords, options.notesPattern);
    const reReferenceParts = getReferencePartsRegex(options.issuePrefixes, options.issuePrefixesCaseSensitive);
    const reReferences = getReferencesRegex(options.referenceActions);
    return {
      notes: reNotes,
      referenceParts: reReferenceParts,
      references: reReferences,
      mentions: /@([\w-]+)/g
    };
  };
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports2, module2) => {
  "use strict";
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module2.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/through2/node_modules/readable-stream/errors.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  module2.exports.codes = codes;
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module2.exports = {
    getHighWaterMark
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util = require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module2.exports = util.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = require_stream();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module2.exports = eos;
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module2.exports = createReadableStreamAsyncIterator;
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports2, module2) => {
  "use strict";
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module2.exports = from;
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream();
  var Buffer2 = require("buffer").Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
      ;
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var _require$codes = require_errors().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  require_inherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  require_inherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports2, module2) => {
  "use strict";
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = require_errors().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module2.exports = pipeline;
});

// node_modules/through2/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream.Readable;
    Object.assign(module2.exports, Stream);
    module2.exports.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/through2/through2.js
var require_through2 = __commonJS((exports2, module2) => {
  var {Transform} = require_readable();
  function inherits(fn, sup) {
    fn.super_ = sup;
    fn.prototype = Object.create(sup.prototype, {
      constructor: {value: fn, enumerable: false, writable: true, configurable: true}
    });
  }
  function through2(construct) {
    return (options, transform, flush) => {
      if (typeof options === "function") {
        flush = transform;
        transform = options;
        options = {};
      }
      if (typeof transform !== "function") {
        transform = (chunk, enc, cb) => cb(null, chunk);
      }
      if (typeof flush !== "function") {
        flush = null;
      }
      return construct(options, transform, flush);
    };
  }
  var make = through2((options, transform, flush) => {
    const t2 = new Transform(options);
    t2._transform = transform;
    if (flush) {
      t2._flush = flush;
    }
    return t2;
  });
  var ctor = through2((options, transform, flush) => {
    function Through2(override) {
      if (!(this instanceof Through2)) {
        return new Through2(override);
      }
      this.options = Object.assign({}, options, override);
      Transform.call(this, this.options);
      this._transform = transform;
      if (flush) {
        this._flush = flush;
      }
    }
    inherits(Through2, Transform);
    return Through2;
  });
  var obj = through2(function(options, transform, flush) {
    const t2 = new Transform(Object.assign({objectMode: true, highWaterMark: 16}, options));
    t2._transform = transform;
    if (flush) {
      t2._flush = flush;
    }
    return t2;
  });
  module2.exports = make;
  module2.exports.ctor = ctor;
  module2.exports.obj = obj;
});

// node_modules/conventional-commits-parser/index.js
var require_conventional_commits_parser = __commonJS((exports2, module2) => {
  "use strict";
  var parser = require_parser();
  var regex = require_regex();
  var through = require_through2();
  var _ = require_lodash();
  function assignOpts(options) {
    options = _.extend({
      headerPattern: /^(\w*)(?:\(([\w$.\-*/ ]*)\))?: (.*)$/,
      headerCorrespondence: ["type", "scope", "subject"],
      referenceActions: [
        "close",
        "closes",
        "closed",
        "fix",
        "fixes",
        "fixed",
        "resolve",
        "resolves",
        "resolved"
      ],
      issuePrefixes: ["#"],
      noteKeywords: ["BREAKING CHANGE"],
      fieldPattern: /^-(.*?)-$/,
      revertPattern: /^Revert\s"([\s\S]*)"\s*This reverts commit (\w*)\./,
      revertCorrespondence: ["header", "hash"],
      warn: function() {
      },
      mergePattern: null,
      mergeCorrespondence: null
    }, options);
    if (typeof options.headerPattern === "string") {
      options.headerPattern = new RegExp(options.headerPattern);
    }
    if (typeof options.headerCorrespondence === "string") {
      options.headerCorrespondence = options.headerCorrespondence.split(",");
    }
    if (typeof options.referenceActions === "string") {
      options.referenceActions = options.referenceActions.split(",");
    }
    if (typeof options.issuePrefixes === "string") {
      options.issuePrefixes = options.issuePrefixes.split(",");
    }
    if (typeof options.noteKeywords === "string") {
      options.noteKeywords = options.noteKeywords.split(",");
    }
    if (typeof options.fieldPattern === "string") {
      options.fieldPattern = new RegExp(options.fieldPattern);
    }
    if (typeof options.revertPattern === "string") {
      options.revertPattern = new RegExp(options.revertPattern);
    }
    if (typeof options.revertCorrespondence === "string") {
      options.revertCorrespondence = options.revertCorrespondence.split(",");
    }
    if (typeof options.mergePattern === "string") {
      options.mergePattern = new RegExp(options.mergePattern);
    }
    return options;
  }
  function conventionalCommitsParser(options) {
    options = assignOpts(options);
    const reg = regex(options);
    return through.obj(function(data, enc, cb) {
      let commit;
      try {
        commit = parser(data.toString(), options, reg);
        cb(null, commit);
      } catch (err) {
        if (options.warn === true) {
          cb(err);
        } else {
          options.warn(err.toString());
          cb(null, "");
        }
      }
    });
  }
  function sync(commit, options) {
    options = assignOpts(options);
    const reg = regex(options);
    return parser(commit, options, reg);
  }
  module2.exports = conventionalCommitsParser;
  module2.exports.sync = sync;
});

// node_modules/lodash.ismatch/index.js
var require_lodash2 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var UNORDERED_COMPARE_FLAG = 1;
  var PARTIAL_COMPARE_FLAG = 2;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise2 = getNative(root, "Promise");
  var Set2 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
  }
  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
      objTag = getTag2(object);
      objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
      othTag = getTag2(other);
      othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
  }
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
            return seen.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getTag2 = baseGetTag;
  if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
    getTag2 = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isMatch(object, source) {
    return object === source || baseIsMatch(object, source, getMatchData(source));
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  module2.exports = isMatch;
});

// node_modules/modify-values/index.js
var require_modify_values = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(obj, modifier) {
    var key;
    var val;
    var ret = {};
    var keys = Object.keys(Object(obj));
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      val = obj[key];
      ret[key] = modifier(val, key);
    }
    return ret;
  };
});

// node_modules/conventional-commits-filter/index.js
var require_conventional_commits_filter = __commonJS((exports2, module2) => {
  "use strict";
  var isMatch = require_lodash2();
  var modifyValues = require_modify_values();
  function modifyValue(val) {
    if (typeof val === "string") {
      return val.trim();
    }
    return val;
  }
  function conventionalCommitsFilter(commits) {
    if (!Array.isArray(commits)) {
      throw new TypeError("Expected an array");
    }
    let ret = [];
    const ignores = [];
    const remove = [];
    commits.forEach(function(commit) {
      if (commit.revert) {
        ignores.push(commit);
      }
      ret.push(commit);
    });
    ret = ret.filter(function(commit) {
      let ignoreThis = false;
      commit = commit.raw ? modifyValues(commit.raw, modifyValue) : modifyValues(commit, modifyValue);
      ignores.some(function(ignoreCommit) {
        const ignore = modifyValues(ignoreCommit.revert, modifyValue);
        ignoreThis = isMatch(commit, ignore);
        if (ignoreThis) {
          remove.push(ignoreCommit.hash);
        }
        return ignoreThis;
      });
      return !ignoreThis;
    });
    ret = ret.filter(function(commit) {
      return remove.indexOf(commit.hash) !== 0;
    });
    return ret;
  }
  module2.exports = conventionalCommitsFilter;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node2();
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var Module = require("module");
  var fs = require("fs");
  var resolveFrom = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory !== "string") {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    }
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
      fromDirectory = fs.realpathSync(fromDirectory);
    } catch (error) {
      if (error.code === "ENOENT") {
        fromDirectory = path.resolve(fromDirectory);
      } else if (silent) {
        return;
      } else {
        throw error;
      }
    }
    const fromFile = path.join(fromDirectory, "noop.js");
    const resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDirectory)
    });
    if (silent) {
      try {
        return resolveFileName();
      } catch (error) {
        return;
      }
    }
    return resolveFileName();
  };
  module2.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
  module2.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
});

// node_modules/import-from/index.js
var require_import_from = __commonJS((exports2, module2) => {
  "use strict";
  var resolveFrom = require_resolve_from();
  module2.exports = (fromDirectory, moduleId) => require(resolveFrom(fromDirectory, moduleId));
  module2.exports.silent = (fromDirectory, moduleId) => {
    try {
      return require(resolveFrom(fromDirectory, moduleId));
    } catch (_) {
    }
  };
});

// node_modules/q/q.js
var require_q = __commonJS((exports2, module2) => {
  /*!
   *
   * Copyright 2009-2017 Kris Kowal under the terms of the MIT
   * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */
  (function(definition) {
    "use strict";
    if (typeof bootstrap === "function") {
      bootstrap("promise", definition);
    } else if (typeof exports2 === "object" && typeof module2 === "object") {
      module2.exports = definition();
    } else if (typeof define === "function" && define.amd) {
      define(definition);
    } else if (typeof ses !== "undefined") {
      if (!ses.ok()) {
        return;
      } else {
        ses.makeQ = definition;
      }
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
      var global2 = typeof window !== "undefined" ? window : self;
      var previousQ = global2.Q;
      global2.Q = definition();
      global2.Q.noConflict = function() {
        global2.Q = previousQ;
        return this;
      };
    } else {
      throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }
  })(function() {
    "use strict";
    var hasStacks = false;
    try {
      throw new Error();
    } catch (e) {
      hasStacks = !!e.stack;
    }
    var qStartingLine = captureLine();
    var qFileName;
    var noop = function() {
    };
    var nextTick = function() {
      var head = {task: void 0, next: null};
      var tail = head;
      var flushing = false;
      var requestTick = void 0;
      var isNodeJS = false;
      var laterQueue = [];
      function flush() {
        var task, domain;
        while (head.next) {
          head = head.next;
          task = head.task;
          head.task = void 0;
          domain = head.domain;
          if (domain) {
            head.domain = void 0;
            domain.enter();
          }
          runSingle(task, domain);
        }
        while (laterQueue.length) {
          task = laterQueue.pop();
          runSingle(task);
        }
        flushing = false;
      }
      function runSingle(task, domain) {
        try {
          task();
        } catch (e) {
          if (isNodeJS) {
            if (domain) {
              domain.exit();
            }
            setTimeout(flush, 0);
            if (domain) {
              domain.enter();
            }
            throw e;
          } else {
            setTimeout(function() {
              throw e;
            }, 0);
          }
        }
        if (domain) {
          domain.exit();
        }
      }
      nextTick = function(task) {
        tail = tail.next = {
          task,
          domain: isNodeJS && process.domain,
          next: null
        };
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
        isNodeJS = true;
        requestTick = function() {
          process.nextTick(flush);
        };
      } else if (typeof setImmediate === "function") {
        if (typeof window !== "undefined") {
          requestTick = setImmediate.bind(window, flush);
        } else {
          requestTick = function() {
            setImmediate(flush);
          };
        }
      } else if (typeof MessageChannel !== "undefined") {
        var channel = new MessageChannel();
        channel.port1.onmessage = function() {
          requestTick = requestPortTick;
          channel.port1.onmessage = flush;
          flush();
        };
        var requestPortTick = function() {
          channel.port2.postMessage(0);
        };
        requestTick = function() {
          setTimeout(flush, 0);
          requestPortTick();
        };
      } else {
        requestTick = function() {
          setTimeout(flush, 0);
        };
      }
      nextTick.runAfter = function(task) {
        laterQueue.push(task);
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      return nextTick;
    }();
    var call = Function.call;
    function uncurryThis(f) {
      return function() {
        return call.apply(f, arguments);
      };
    }
    var array_slice = uncurryThis(Array.prototype.slice);
    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {
      var index = 0, length = this.length;
      if (arguments.length === 1) {
        do {
          if (index in this) {
            basis = this[index++];
            break;
          }
          if (++index >= length) {
            throw new TypeError();
          }
        } while (1);
      }
      for (; index < length; index++) {
        if (index in this) {
          basis = callback(basis, this[index], index);
        }
      }
      return basis;
    });
    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === value) {
          return i;
        }
      }
      return -1;
    });
    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {
      var self2 = this;
      var collect = [];
      array_reduce(self2, function(undefined2, value, index) {
        collect.push(callback.call(thisp, value, index, self2));
      }, void 0);
      return collect;
    });
    var object_create = Object.create || function(prototype) {
      function Type() {
      }
      Type.prototype = prototype;
      return new Type();
    };
    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
      obj[prop] = descriptor.value;
      return obj;
    };
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var object_keys = Object.keys || function(object) {
      var keys = [];
      for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    var object_toString = uncurryThis(Object.prototype.toString);
    function isObject(value) {
      return value === Object(value);
    }
    function isStopIteration(exception) {
      return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
    }
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
      QReturnValue = ReturnValue;
    } else {
      QReturnValue = function(value) {
        this.value = value;
      };
    }
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error, promise2) {
      if (hasStacks && promise2.stack && typeof error === "object" && error !== null && error.stack) {
        var stacks = [];
        for (var p = promise2; !!p; p = p.source) {
          if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
            object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
            stacks.unshift(p.stack);
          }
        }
        stacks.unshift(error.stack);
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
      }
    }
    function filterStackString(stackString) {
      var lines = stackString.split("\n");
      var desiredLines = [];
      for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];
        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
          desiredLines.push(line);
        }
      }
      return desiredLines.join("\n");
    }
    function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function getFileNameAndLineNumber(stackLine) {
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
      }
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
      }
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
      }
    }
    function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
      if (!fileNameAndLineNumber) {
        return false;
      }
      var fileName = fileNameAndLineNumber[0];
      var lineNumber = fileNameAndLineNumber[1];
      return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
    }
    function captureLine() {
      if (!hasStacks) {
        return;
      }
      try {
        throw new Error();
      } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
          return;
        }
        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
      }
    }
    function deprecate(callback, name, alternative) {
      return function() {
        if (typeof console !== "undefined" && typeof console.warn === "function") {
          console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
      };
    }
    function Q(value) {
      if (value instanceof Promise2) {
        return value;
      }
      if (isPromiseAlike(value)) {
        return coerce(value);
      } else {
        return fulfill(value);
      }
    }
    Q.resolve = Q;
    Q.nextTick = nextTick;
    Q.longStackSupport = false;
    var longStackCounter = 1;
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
      Q.longStackSupport = true;
    }
    Q.defer = defer;
    function defer() {
      var messages = [], progressListeners = [], resolvedPromise;
      var deferred = object_create(defer.prototype);
      var promise2 = object_create(Promise2.prototype);
      promise2.promiseDispatch = function(resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
          messages.push(args);
          if (op === "when" && operands[1]) {
            progressListeners.push(operands[1]);
          }
        } else {
          Q.nextTick(function() {
            resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
          });
        }
      };
      promise2.valueOf = function() {
        if (messages) {
          return promise2;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
          resolvedPromise = nearerValue;
        }
        return nearerValue;
      };
      promise2.inspect = function() {
        if (!resolvedPromise) {
          return {state: "pending"};
        }
        return resolvedPromise.inspect();
      };
      if (Q.longStackSupport && hasStacks) {
        try {
          throw new Error();
        } catch (e) {
          promise2.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          promise2.stackCounter = longStackCounter++;
        }
      }
      function become(newPromise) {
        resolvedPromise = newPromise;
        if (Q.longStackSupport && hasStacks) {
          promise2.source = newPromise;
        }
        array_reduce(messages, function(undefined2, message) {
          Q.nextTick(function() {
            newPromise.promiseDispatch.apply(newPromise, message);
          });
        }, void 0);
        messages = void 0;
        progressListeners = void 0;
      }
      deferred.promise = promise2;
      deferred.resolve = function(value) {
        if (resolvedPromise) {
          return;
        }
        become(Q(value));
      };
      deferred.fulfill = function(value) {
        if (resolvedPromise) {
          return;
        }
        become(fulfill(value));
      };
      deferred.reject = function(reason) {
        if (resolvedPromise) {
          return;
        }
        become(reject(reason));
      };
      deferred.notify = function(progress2) {
        if (resolvedPromise) {
          return;
        }
        array_reduce(progressListeners, function(undefined2, progressListener) {
          Q.nextTick(function() {
            progressListener(progress2);
          });
        }, void 0);
      };
      return deferred;
    }
    defer.prototype.makeNodeResolver = function() {
      var self2 = this;
      return function(error, value) {
        if (error) {
          self2.reject(error);
        } else if (arguments.length > 2) {
          self2.resolve(array_slice(arguments, 1));
        } else {
          self2.resolve(value);
        }
      };
    };
    Q.Promise = promise;
    Q.promise = promise;
    function promise(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
      }
      var deferred = defer();
      try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
      } catch (reason) {
        deferred.reject(reason);
      }
      return deferred.promise;
    }
    promise.race = race;
    promise.all = all;
    promise.reject = reject;
    promise.resolve = Q;
    Q.passByCopy = function(object) {
      return object;
    };
    Promise2.prototype.passByCopy = function() {
      return this;
    };
    Q.join = function(x, y) {
      return Q(x).join(y);
    };
    Promise2.prototype.join = function(that) {
      return Q([this, that]).spread(function(x, y) {
        if (x === y) {
          return x;
        } else {
          throw new Error("Q can't join: not the same: " + x + " " + y);
        }
      });
    };
    Q.race = race;
    function race(answerPs) {
      return promise(function(resolve, reject2) {
        for (var i = 0, len = answerPs.length; i < len; i++) {
          Q(answerPs[i]).then(resolve, reject2);
        }
      });
    }
    Promise2.prototype.race = function() {
      return this.then(Q.race);
    };
    Q.makePromise = Promise2;
    function Promise2(descriptor, fallback, inspect) {
      if (fallback === void 0) {
        fallback = function(op) {
          return reject(new Error("Promise does not support operation: " + op));
        };
      }
      if (inspect === void 0) {
        inspect = function() {
          return {state: "unknown"};
        };
      }
      var promise2 = object_create(Promise2.prototype);
      promise2.promiseDispatch = function(resolve, op, args) {
        var result;
        try {
          if (descriptor[op]) {
            result = descriptor[op].apply(promise2, args);
          } else {
            result = fallback.call(promise2, op, args);
          }
        } catch (exception) {
          result = reject(exception);
        }
        if (resolve) {
          resolve(result);
        }
      };
      promise2.inspect = inspect;
      if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
          promise2.exception = inspected.reason;
        }
        promise2.valueOf = function() {
          var inspected2 = inspect();
          if (inspected2.state === "pending" || inspected2.state === "rejected") {
            return promise2;
          }
          return inspected2.value;
        };
      }
      return promise2;
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.then = function(fulfilled, rejected, progressed) {
      var self2 = this;
      var deferred = defer();
      var done = false;
      function _fulfilled(value) {
        try {
          return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
          return reject(exception);
        }
      }
      function _rejected(exception) {
        if (typeof rejected === "function") {
          makeStackTraceLong(exception, self2);
          try {
            return rejected(exception);
          } catch (newException) {
            return reject(newException);
          }
        }
        return reject(exception);
      }
      function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
      }
      Q.nextTick(function() {
        self2.promiseDispatch(function(value) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_fulfilled(value));
        }, "when", [function(exception) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_rejected(exception));
        }]);
      });
      self2.promiseDispatch(void 0, "when", [void 0, function(value) {
        var newValue;
        var threw = false;
        try {
          newValue = _progressed(value);
        } catch (e) {
          threw = true;
          if (Q.onerror) {
            Q.onerror(e);
          } else {
            throw e;
          }
        }
        if (!threw) {
          deferred.notify(newValue);
        }
      }]);
      return deferred.promise;
    };
    Q.tap = function(promise2, callback) {
      return Q(promise2).tap(callback);
    };
    Promise2.prototype.tap = function(callback) {
      callback = Q(callback);
      return this.then(function(value) {
        return callback.fcall(value).thenResolve(value);
      });
    };
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
      return Q(value).then(fulfilled, rejected, progressed);
    }
    Promise2.prototype.thenResolve = function(value) {
      return this.then(function() {
        return value;
      });
    };
    Q.thenResolve = function(promise2, value) {
      return Q(promise2).thenResolve(value);
    };
    Promise2.prototype.thenReject = function(reason) {
      return this.then(function() {
        throw reason;
      });
    };
    Q.thenReject = function(promise2, reason) {
      return Q(promise2).thenReject(reason);
    };
    Q.nearer = nearer;
    function nearer(value) {
      if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
          return inspected.value;
        }
      }
      return value;
    }
    Q.isPromise = isPromise;
    function isPromise(object) {
      return object instanceof Promise2;
    }
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
      return isObject(object) && typeof object.then === "function";
    }
    Q.isPending = isPending;
    function isPending(object) {
      return isPromise(object) && object.inspect().state === "pending";
    }
    Promise2.prototype.isPending = function() {
      return this.inspect().state === "pending";
    };
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
      return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    Promise2.prototype.isFulfilled = function() {
      return this.inspect().state === "fulfilled";
    };
    Q.isRejected = isRejected;
    function isRejected(object) {
      return isPromise(object) && object.inspect().state === "rejected";
    }
    Promise2.prototype.isRejected = function() {
      return this.inspect().state === "rejected";
    };
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    function resetUnhandledRejections() {
      unhandledReasons.length = 0;
      unhandledRejections.length = 0;
      if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
      }
    }
    function trackRejection(promise2, reason) {
      if (!trackUnhandledRejections) {
        return;
      }
      if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function() {
          if (array_indexOf(unhandledRejections, promise2) !== -1) {
            process.emit("unhandledRejection", reason, promise2);
            reportedUnhandledRejections.push(promise2);
          }
        });
      }
      unhandledRejections.push(promise2);
      if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
      } else {
        unhandledReasons.push("(no stack) " + reason);
      }
    }
    function untrackRejection(promise2) {
      if (!trackUnhandledRejections) {
        return;
      }
      var at = array_indexOf(unhandledRejections, promise2);
      if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            var atReport = array_indexOf(reportedUnhandledRejections, promise2);
            if (atReport !== -1) {
              process.emit("rejectionHandled", unhandledReasons[at], promise2);
              reportedUnhandledRejections.splice(atReport, 1);
            }
          });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
      }
    }
    Q.resetUnhandledRejections = resetUnhandledRejections;
    Q.getUnhandledReasons = function() {
      return unhandledReasons.slice();
    };
    Q.stopUnhandledRejectionTracking = function() {
      resetUnhandledRejections();
      trackUnhandledRejections = false;
    };
    resetUnhandledRejections();
    Q.reject = reject;
    function reject(reason) {
      var rejection = Promise2({
        when: function(rejected) {
          if (rejected) {
            untrackRejection(this);
          }
          return rejected ? rejected(reason) : this;
        }
      }, function fallback() {
        return this;
      }, function inspect() {
        return {state: "rejected", reason};
      });
      trackRejection(rejection, reason);
      return rejection;
    }
    Q.fulfill = fulfill;
    function fulfill(value) {
      return Promise2({
        when: function() {
          return value;
        },
        get: function(name) {
          return value[name];
        },
        set: function(name, rhs) {
          value[name] = rhs;
        },
        delete: function(name) {
          delete value[name];
        },
        post: function(name, args) {
          if (name === null || name === void 0) {
            return value.apply(void 0, args);
          } else {
            return value[name].apply(value, args);
          }
        },
        apply: function(thisp, args) {
          return value.apply(thisp, args);
        },
        keys: function() {
          return object_keys(value);
        }
      }, void 0, function inspect() {
        return {state: "fulfilled", value};
      });
    }
    function coerce(promise2) {
      var deferred = defer();
      Q.nextTick(function() {
        try {
          promise2.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
          deferred.reject(exception);
        }
      });
      return deferred.promise;
    }
    Q.master = master;
    function master(object) {
      return Promise2({
        isDef: function() {
        }
      }, function fallback(op, args) {
        return dispatch(object, op, args);
      }, function() {
        return Q(object).inspect();
      });
    }
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
      return Q(value).spread(fulfilled, rejected);
    }
    Promise2.prototype.spread = function(fulfilled, rejected) {
      return this.all().then(function(array) {
        return fulfilled.apply(void 0, array);
      }, rejected);
    };
    Q.async = async;
    function async(makeGenerator) {
      return function() {
        function continuer(verb, arg) {
          var result;
          if (typeof StopIteration === "undefined") {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              return reject(exception);
            }
            if (result.done) {
              return Q(result.value);
            } else {
              return when(result.value, callback, errback);
            }
          } else {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              if (isStopIteration(exception)) {
                return Q(exception.value);
              } else {
                return reject(exception);
              }
            }
            return when(result, callback, errback);
          }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
      };
    }
    Q.spawn = spawn;
    function spawn(makeGenerator) {
      Q.done(Q.async(makeGenerator)());
    }
    Q["return"] = _return;
    function _return(value) {
      throw new QReturnValue(value);
    }
    Q.promised = promised;
    function promised(callback) {
      return function() {
        return spread([this, all(arguments)], function(self2, args) {
          return callback.apply(self2, args);
        });
      };
    }
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
      return Q(object).dispatch(op, args);
    }
    Promise2.prototype.dispatch = function(op, args) {
      var self2 = this;
      var deferred = defer();
      Q.nextTick(function() {
        self2.promiseDispatch(deferred.resolve, op, args);
      });
      return deferred.promise;
    };
    Q.get = function(object, key) {
      return Q(object).dispatch("get", [key]);
    };
    Promise2.prototype.get = function(key) {
      return this.dispatch("get", [key]);
    };
    Q.set = function(object, key, value) {
      return Q(object).dispatch("set", [key, value]);
    };
    Promise2.prototype.set = function(key, value) {
      return this.dispatch("set", [key, value]);
    };
    Q.del = Q["delete"] = function(object, key) {
      return Q(object).dispatch("delete", [key]);
    };
    Promise2.prototype.del = Promise2.prototype["delete"] = function(key) {
      return this.dispatch("delete", [key]);
    };
    Q.mapply = Q.post = function(object, name, args) {
      return Q(object).dispatch("post", [name, args]);
    };
    Promise2.prototype.mapply = Promise2.prototype.post = function(name, args) {
      return this.dispatch("post", [name, args]);
    };
    Q.send = Q.mcall = Q.invoke = function(object, name) {
      return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    Promise2.prototype.send = Promise2.prototype.mcall = Promise2.prototype.invoke = function(name) {
      return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    Q.fapply = function(object, args) {
      return Q(object).dispatch("apply", [void 0, args]);
    };
    Promise2.prototype.fapply = function(args) {
      return this.dispatch("apply", [void 0, args]);
    };
    Q["try"] = Q.fcall = function(object) {
      return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
    };
    Promise2.prototype.fcall = function() {
      return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };
    Q.fbind = function(object) {
      var promise2 = Q(object);
      var args = array_slice(arguments, 1);
      return function fbound() {
        return promise2.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Promise2.prototype.fbind = function() {
      var promise2 = this;
      var args = array_slice(arguments);
      return function fbound() {
        return promise2.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Q.keys = function(object) {
      return Q(object).dispatch("keys", []);
    };
    Promise2.prototype.keys = function() {
      return this.dispatch("keys", []);
    };
    Q.all = all;
    function all(promises) {
      return when(promises, function(promises2) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises2, function(undefined2, promise2, index) {
          var snapshot;
          if (isPromise(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
            promises2[index] = snapshot.value;
          } else {
            ++pendingCount;
            when(promise2, function(value) {
              promises2[index] = value;
              if (--pendingCount === 0) {
                deferred.resolve(promises2);
              }
            }, deferred.reject, function(progress2) {
              deferred.notify({index, value: progress2});
            });
          }
        }, void 0);
        if (pendingCount === 0) {
          deferred.resolve(promises2);
        }
        return deferred.promise;
      });
    }
    Promise2.prototype.all = function() {
      return all(this);
    };
    Q.any = any;
    function any(promises) {
      if (promises.length === 0) {
        return Q.resolve();
      }
      var deferred = Q.defer();
      var pendingCount = 0;
      array_reduce(promises, function(prev, current, index) {
        var promise2 = promises[index];
        pendingCount++;
        when(promise2, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
          deferred.resolve(result);
        }
        function onRejected(err) {
          pendingCount--;
          if (pendingCount === 0) {
            var rejection = err || new Error("" + err);
            rejection.message = "Q can't get fulfillment value from any promise, all promises were rejected. Last error message: " + rejection.message;
            deferred.reject(rejection);
          }
        }
        function onProgress(progress2) {
          deferred.notify({
            index,
            value: progress2
          });
        }
      }, void 0);
      return deferred.promise;
    }
    Promise2.prototype.any = function() {
      return any(this);
    };
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
      return when(promises, function(promises2) {
        promises2 = array_map(promises2, Q);
        return when(all(array_map(promises2, function(promise2) {
          return when(promise2, noop, noop);
        })), function() {
          return promises2;
        });
      });
    }
    Promise2.prototype.allResolved = function() {
      return allResolved(this);
    };
    Q.allSettled = allSettled;
    function allSettled(promises) {
      return Q(promises).allSettled();
    }
    Promise2.prototype.allSettled = function() {
      return this.then(function(promises) {
        return all(array_map(promises, function(promise2) {
          promise2 = Q(promise2);
          function regardless() {
            return promise2.inspect();
          }
          return promise2.then(regardless, regardless);
        }));
      });
    };
    Q.fail = Q["catch"] = function(object, rejected) {
      return Q(object).then(void 0, rejected);
    };
    Promise2.prototype.fail = Promise2.prototype["catch"] = function(rejected) {
      return this.then(void 0, rejected);
    };
    Q.progress = progress;
    function progress(object, progressed) {
      return Q(object).then(void 0, void 0, progressed);
    }
    Promise2.prototype.progress = function(progressed) {
      return this.then(void 0, void 0, progressed);
    };
    Q.fin = Q["finally"] = function(object, callback) {
      return Q(object)["finally"](callback);
    };
    Promise2.prototype.fin = Promise2.prototype["finally"] = function(callback) {
      if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
      }
      callback = Q(callback);
      return this.then(function(value) {
        return callback.fcall().then(function() {
          return value;
        });
      }, function(reason) {
        return callback.fcall().then(function() {
          throw reason;
        });
      });
    };
    Q.done = function(object, fulfilled, rejected, progress2) {
      return Q(object).done(fulfilled, rejected, progress2);
    };
    Promise2.prototype.done = function(fulfilled, rejected, progress2) {
      var onUnhandledError = function(error) {
        Q.nextTick(function() {
          makeStackTraceLong(error, promise2);
          if (Q.onerror) {
            Q.onerror(error);
          } else {
            throw error;
          }
        });
      };
      var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
      if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
      }
      promise2.then(void 0, onUnhandledError);
    };
    Q.timeout = function(object, ms, error) {
      return Q(object).timeout(ms, error);
    };
    Promise2.prototype.timeout = function(ms, error) {
      var deferred = defer();
      var timeoutId = setTimeout(function() {
        if (!error || typeof error === "string") {
          error = new Error(error || "Timed out after " + ms + " ms");
          error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
      }, ms);
      this.then(function(value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
      }, function(exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
      }, deferred.notify);
      return deferred.promise;
    };
    Q.delay = function(object, timeout) {
      if (timeout === void 0) {
        timeout = object;
        object = void 0;
      }
      return Q(object).delay(timeout);
    };
    Promise2.prototype.delay = function(timeout) {
      return this.then(function(value) {
        var deferred = defer();
        setTimeout(function() {
          deferred.resolve(value);
        }, timeout);
        return deferred.promise;
      });
    };
    Q.nfapply = function(callback, args) {
      return Q(callback).nfapply(args);
    };
    Promise2.prototype.nfapply = function(args) {
      var deferred = defer();
      var nodeArgs = array_slice(args);
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfcall = function(callback) {
      var args = array_slice(arguments, 1);
      return Q(callback).nfapply(args);
    };
    Promise2.prototype.nfcall = function() {
      var nodeArgs = array_slice(arguments);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfbind = Q.denodeify = function(callback) {
      if (callback === void 0) {
        throw new Error("Q can't wrap an undefined function");
      }
      var baseArgs = array_slice(arguments, 1);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
      var args = array_slice(arguments);
      args.unshift(this);
      return Q.denodeify.apply(void 0, args);
    };
    Q.nbind = function(callback, thisp) {
      var baseArgs = array_slice(arguments, 2);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
          return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise2.prototype.nbind = function() {
      var args = array_slice(arguments, 0);
      args.unshift(this);
      return Q.nbind.apply(void 0, args);
    };
    Q.nmapply = Q.npost = function(object, name, args) {
      return Q(object).npost(name, args);
    };
    Promise2.prototype.nmapply = Promise2.prototype.npost = function(name, args) {
      var nodeArgs = array_slice(args || []);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nsend = Q.nmcall = Q.ninvoke = function(object, name) {
      var nodeArgs = array_slice(arguments, 2);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Promise2.prototype.nsend = Promise2.prototype.nmcall = Promise2.prototype.ninvoke = function(name) {
      var nodeArgs = array_slice(arguments, 1);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
      return Q(object).nodeify(nodeback);
    }
    Promise2.prototype.nodeify = function(nodeback) {
      if (nodeback) {
        this.then(function(value) {
          Q.nextTick(function() {
            nodeback(null, value);
          });
        }, function(error) {
          Q.nextTick(function() {
            nodeback(error);
          });
        });
      } else {
        return this;
      }
    };
    Q.noConflict = function() {
      throw new Error("Q.noConflict only works when Q is used as a global");
    };
    var qEndingLine = captureLine();
    return Q;
  });
});

// node_modules/conventional-changelog-angular/parser-opts.js
var require_parser_opts = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    headerPattern: /^(\w*)(?:\((.*)\))?: (.*)$/,
    headerCorrespondence: [
      "type",
      "scope",
      "subject"
    ],
    noteKeywords: ["BREAKING CHANGE"],
    revertPattern: /^(?:Revert|revert:)\s"?([\s\S]+?)"?\s*This reverts commit (\w*)\./i,
    revertCorrespondence: ["header", "hash"]
  };
});

// node_modules/array-ify/index.js
var require_array_ify = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(val) {
    return Array.isArray(val) ? val : [val];
  };
});

// node_modules/is-obj/index.js
var require_is_obj = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (value) => {
    const type = typeof value;
    return value !== null && (type === "object" || type === "function");
  };
});

// node_modules/dot-prop/index.js
var require_dot_prop = __commonJS((exports2, module2) => {
  "use strict";
  var isObj = require_is_obj();
  var disallowedKeys = [
    "__proto__",
    "prototype",
    "constructor"
  ];
  var isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.includes(segment));
  function getPathSegments(path) {
    const pathArray = path.split(".");
    const parts = [];
    for (let i = 0; i < pathArray.length; i++) {
      let p = pathArray[i];
      while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
        p = p.slice(0, -1) + ".";
        p += pathArray[++i];
      }
      parts.push(p);
    }
    if (!isValidPath(parts)) {
      return [];
    }
    return parts;
  }
  module2.exports = {
    get(object, path, value) {
      if (!isObj(object) || typeof path !== "string") {
        return value === void 0 ? object : value;
      }
      const pathArray = getPathSegments(path);
      if (pathArray.length === 0) {
        return;
      }
      for (let i = 0; i < pathArray.length; i++) {
        if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {
          return value;
        }
        object = object[pathArray[i]];
        if (object === void 0 || object === null) {
          if (i !== pathArray.length - 1) {
            return value;
          }
          break;
        }
      }
      return object;
    },
    set(object, path, value) {
      if (!isObj(object) || typeof path !== "string") {
        return object;
      }
      const root = object;
      const pathArray = getPathSegments(path);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        if (!isObj(object[p])) {
          object[p] = {};
        }
        if (i === pathArray.length - 1) {
          object[p] = value;
        }
        object = object[p];
      }
      return root;
    },
    delete(object, path) {
      if (!isObj(object) || typeof path !== "string") {
        return false;
      }
      const pathArray = getPathSegments(path);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        if (i === pathArray.length - 1) {
          delete object[p];
          return true;
        }
        object = object[p];
        if (!isObj(object)) {
          return false;
        }
      }
    },
    has(object, path) {
      if (!isObj(object) || typeof path !== "string") {
        return false;
      }
      const pathArray = getPathSegments(path);
      if (pathArray.length === 0) {
        return false;
      }
      for (let i = 0; i < pathArray.length; i++) {
        if (isObj(object)) {
          if (!(pathArray[i] in object)) {
            return false;
          }
          object = object[pathArray[i]];
        } else {
          return false;
        }
      }
      return true;
    }
  };
});

// node_modules/compare-func/index.js
var require_compare_func = __commonJS((exports2, module2) => {
  "use strict";
  var arrayify = require_array_ify();
  var dotPropGet = require_dot_prop().get;
  function compareFunc(prop) {
    return function(a, b) {
      var ret = 0;
      arrayify(prop).some(function(el) {
        var x;
        var y;
        if (typeof el === "function") {
          x = el(a);
          y = el(b);
        } else if (typeof el === "string") {
          x = dotPropGet(a, el);
          y = dotPropGet(b, el);
        } else {
          x = a;
          y = b;
        }
        if (x === y) {
          ret = 0;
          return;
        }
        if (typeof x === "string" && typeof y === "string") {
          ret = x.localeCompare(y);
          return ret !== 0;
        }
        ret = x < y ? -1 : 1;
        return true;
      });
      return ret;
    };
  }
  module2.exports = compareFunc;
});

// node_modules/conventional-changelog-angular/writer-opts.js
var require_writer_opts = __commonJS((exports2, module2) => {
  "use strict";
  var compareFunc = require_compare_func();
  var Q = require_q();
  var readFile = Q.denodeify(require("fs").readFile);
  var resolve = require("path").resolve;
  module2.exports = Q.all([
    readFile(resolve(__dirname, "./templates/template.hbs"), "utf-8"),
    readFile(resolve(__dirname, "./templates/header.hbs"), "utf-8"),
    readFile(resolve(__dirname, "./templates/commit.hbs"), "utf-8"),
    readFile(resolve(__dirname, "./templates/footer.hbs"), "utf-8")
  ]).spread((template, header, commit, footer) => {
    const writerOpts = getWriterOpts();
    writerOpts.mainTemplate = template;
    writerOpts.headerPartial = header;
    writerOpts.commitPartial = commit;
    writerOpts.footerPartial = footer;
    return writerOpts;
  });
  function getWriterOpts() {
    return {
      transform: (commit, context) => {
        let discard = true;
        const issues = [];
        commit.notes.forEach((note) => {
          note.title = "BREAKING CHANGES";
          discard = false;
        });
        if (commit.type === "feat") {
          commit.type = "Features";
        } else if (commit.type === "fix") {
          commit.type = "Bug Fixes";
        } else if (commit.type === "perf") {
          commit.type = "Performance Improvements";
        } else if (commit.type === "revert" || commit.revert) {
          commit.type = "Reverts";
        } else if (discard) {
          return;
        } else if (commit.type === "docs") {
          commit.type = "Documentation";
        } else if (commit.type === "style") {
          commit.type = "Styles";
        } else if (commit.type === "refactor") {
          commit.type = "Code Refactoring";
        } else if (commit.type === "test") {
          commit.type = "Tests";
        } else if (commit.type === "build") {
          commit.type = "Build System";
        } else if (commit.type === "ci") {
          commit.type = "Continuous Integration";
        }
        if (commit.scope === "*") {
          commit.scope = "";
        }
        if (typeof commit.hash === "string") {
          commit.shortHash = commit.hash.substring(0, 7);
        }
        if (typeof commit.subject === "string") {
          let url = context.repository ? `${context.host}/${context.owner}/${context.repository}` : context.repoUrl;
          if (url) {
            url = `${url}/issues/`;
            commit.subject = commit.subject.replace(/#([0-9]+)/g, (_, issue) => {
              issues.push(issue);
              return `[#${issue}](${url}${issue})`;
            });
          }
          if (context.host) {
            commit.subject = commit.subject.replace(/\B@([a-z0-9](?:-?[a-z0-9/]){0,38})/g, (_, username) => {
              if (username.includes("/")) {
                return `@${username}`;
              }
              return `[@${username}](${context.host}/${username})`;
            });
          }
        }
        commit.references = commit.references.filter((reference) => {
          if (issues.indexOf(reference.issue) === -1) {
            return true;
          }
          return false;
        });
        return commit;
      },
      groupBy: "type",
      commitGroupsSort: "title",
      commitsSort: ["scope", "subject"],
      noteGroupsSort: "title",
      notesSort: compareFunc
    };
  }
});

// node_modules/conventional-changelog-angular/conventional-changelog.js
var require_conventional_changelog = __commonJS((exports2, module2) => {
  "use strict";
  var Q = require_q();
  var parserOpts = require_parser_opts();
  var writerOpts = require_writer_opts();
  module2.exports = Q.all([parserOpts, writerOpts]).spread((parserOpts2, writerOpts2) => {
    return {parserOpts: parserOpts2, writerOpts: writerOpts2};
  });
});

// node_modules/conventional-changelog-angular/conventional-recommended-bump.js
var require_conventional_recommended_bump = __commonJS((exports2, module2) => {
  "use strict";
  var parserOpts = require_parser_opts();
  module2.exports = {
    parserOpts,
    whatBump: (commits) => {
      let level = 2;
      let breakings = 0;
      let features = 0;
      commits.forEach((commit) => {
        if (commit.notes.length > 0) {
          breakings += commit.notes.length;
          level = 0;
        } else if (commit.type === "feat") {
          features += 1;
          if (level === 2) {
            level = 1;
          }
        }
      });
      return {
        level,
        reason: breakings === 1 ? `There is ${breakings} BREAKING CHANGE and ${features} features` : `There are ${breakings} BREAKING CHANGES and ${features} features`
      };
    }
  };
});

// node_modules/conventional-changelog-angular/index.js
var require_conventional_changelog_angular = __commonJS((exports2, module2) => {
  "use strict";
  var Q = require_q();
  var conventionalChangelog = require_conventional_changelog();
  var parserOpts = require_parser_opts();
  var recommendedBumpOpts = require_conventional_recommended_bump();
  var writerOpts = require_writer_opts();
  module2.exports = Q.all([conventionalChangelog, parserOpts, recommendedBumpOpts, writerOpts]).spread((conventionalChangelog2, parserOpts2, recommendedBumpOpts2, writerOpts2) => {
    return {conventionalChangelog: conventionalChangelog2, parserOpts: parserOpts2, recommendedBumpOpts: recommendedBumpOpts2, writerOpts: writerOpts2};
  });
});

// node_modules/@semantic-release/commit-analyzer/lib/load-parser-config.js
var require_load_parser_config = __commonJS((exports2, module2) => {
  var {promisify} = require("util");
  var {isPlainObject} = require_lodash();
  var importFrom = require_import_from();
  var conventionalChangelogAngular = require_conventional_changelog_angular();
  module2.exports = async ({preset, config, parserOpts, presetConfig}, {cwd}) => {
    let loadedConfig;
    if (preset) {
      const presetPackage = `conventional-changelog-${preset.toLowerCase()}`;
      loadedConfig = importFrom.silent(__dirname, presetPackage) || importFrom(cwd, presetPackage);
    } else if (config) {
      loadedConfig = importFrom.silent(__dirname, config) || importFrom(cwd, config);
    } else {
      loadedConfig = conventionalChangelogAngular;
    }
    loadedConfig = await (typeof loadedConfig === "function" ? isPlainObject(presetConfig) ? loadedConfig(presetConfig) : promisify(loadedConfig)() : loadedConfig);
    return {...loadedConfig.parserOpts, ...parserOpts};
  };
});

// node_modules/@semantic-release/commit-analyzer/lib/default-release-types.js
var require_default_release_types = __commonJS((exports2, module2) => {
  module2.exports = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
});

// node_modules/@semantic-release/commit-analyzer/lib/load-release-rules.js
var require_load_release_rules = __commonJS((exports2, module2) => {
  var {isUndefined} = require_lodash();
  var importFrom = require_import_from();
  var RELEASE_TYPES = require_default_release_types();
  module2.exports = ({releaseRules}, {cwd}) => {
    let loadedReleaseRules;
    if (releaseRules) {
      loadedReleaseRules = typeof releaseRules === "string" ? importFrom.silent(__dirname, releaseRules) || importFrom(cwd, releaseRules) : releaseRules;
      if (!Array.isArray(loadedReleaseRules)) {
        throw new TypeError('Error in commit-analyzer configuration: "releaseRules" must be an array of rules');
      }
      loadedReleaseRules.forEach((rule) => {
        if (!rule || isUndefined(rule.release)) {
          throw new Error('Error in commit-analyzer configuration: rules must be an object with a "release" property');
        } else if (!RELEASE_TYPES.includes(rule.release) && rule.release !== null && rule.release !== false) {
          throw new Error(`Error in commit-analyzer configuration: "${rule.release}" is not a valid release type. Valid values are: ${JSON.stringify(RELEASE_TYPES)}`);
        }
      });
    }
    return loadedReleaseRules;
  };
});

// node_modules/braces/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports2.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min) || !exports2.isInteger(max))
      return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = require_utils2();
  module2.exports = (ast, options = {}) => {
    let stringify = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils2.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils2.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify(child);
        }
      }
      return output;
    };
    return stringify(ast);
  };
});

// node_modules/is-number/index.js
var require_is_number = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports2, module2) => {
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isNumber = require_is_number();
  var toRegexRange = (min, max, options) => {
    if (isNumber(min) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max === void 0 || min === max) {
      return String(min);
    }
    if (isNumber(max) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = {relaxZeros: true, ...options};
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min, max);
    let b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
      let result = min + "|" + max;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {min, max, a, b};
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([max]);
    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: start, count: [], digits: 0};
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return {pattern, count: [count], digits};
  }
  function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for (let i = 0; i < ranges.length; i++) {
      let max2 = ranges[i];
      let obj = rangeToPattern(String(start), String(max2), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max2 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max2, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max2 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let {string} = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module2.exports = toRegexRange;
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var util = require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, {wrap: false, ...options});
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {negatives: [], positives: []};
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, {wrap: false, options});
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, {transform: step});
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = {...options};
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module2.exports = fill;
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var utils2 = require_utils2();
  var compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils2.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils2.reduce(node.nodes);
        let range = fill(...args, {...options, wrap: false, toRegex: true});
        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module2.exports = compile;
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var stringify = require_stringify();
  var utils2 = require_utils2();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils2.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils2.reduce(node.nodes);
        if (utils2.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify(node, options);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      let enclose = utils2.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils2.flatten(walk(ast));
  };
  module2.exports = expand;
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "'",
    CHAR_SPACE: " ",
    CHAR_TAB: "	",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  var stringify = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants();
  var parse = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    let ast = {type: "root", input, nodes: []};
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    let memo = {};
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({type: "bos"});
    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({type: "text", value: "\\" + value});
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({type: "paren", nodes: []});
        stack.push(block);
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({type: "text", value});
          continue;
        }
        block = stack.pop();
        push({type: "text", value});
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({type: "open", value});
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({type: "text", value});
          continue;
        }
        let type = "close";
        block = stack.pop();
        block.close = true;
        push({type, value});
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, {type: "text", value: stringify(block)}];
        }
        push({type: "comma", value});
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({type: "text", value});
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({type: "dot", value});
        continue;
      }
      push({type: "text", value});
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({type: "eos"});
    return ast;
  };
  module2.exports = parse;
});

// node_modules/braces/index.js
var require_braces = __commonJS((exports2, module2) => {
  "use strict";
  var stringify = require_stringify();
  var compile = require_compile();
  var expand = require_expand();
  var parse = require_parse();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module2.exports = braces;
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path.sep,
    extglobChars(chars) {
      return {
        "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
        "?": {type: "qmark", open: "(?:", close: ")?"},
        "+": {type: "plus", open: "(?:", close: ")+"},
        "*": {type: "star", open: "(?:", close: ")*"},
        "@": {type: "at", open: "(?:", close: ")"}
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS((exports2) => {
  "use strict";
  var path = require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants2();
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
  exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports2.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = require_utils3();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants2();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {value: "", depth: 0, isGlob: false};
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {value: "", depth: 0, isGlob: false};
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils2.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils2.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module2.exports = scan;
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  var utils2 = require_utils3();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils2.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = {...options};
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = {type: "bos", value: "", output: opts.prepend || ""};
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils2.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils2.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index];
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({type, value: value2, output: state.output ? "" : ONE_CHAR});
      push({type: "paren", extglob: true, value: advance(), output});
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }
        if (token.prev.type === "bos" && eos()) {
          state.negatedExtglob = true;
        }
      }
      push({type: "paren", extglob: true, value, output});
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : `\\${m}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils2.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({type: "text", value});
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance() || "";
        } else {
          value += advance() || "";
        }
        if (state.brackets === 0) {
          push({type: "text", value});
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({value});
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils2.escapeRegex(value);
        prev.value += value;
        append({value});
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({type: "text", value});
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({type: "paren", value});
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({type: "paren", value, output: state.parens ? ")" : "\\)"});
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({type: "bracket", value});
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({type: "text", value, output: `\\${value}`});
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({value});
        if (opts.literalBrackets === false || utils2.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils2.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({type: "text", value, output: value});
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({type: "brace", value, output});
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({type: "text", value});
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({type: "comma", value, output});
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({type: "slash", value, output: SLASH_LITERAL});
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({type: "text", value, output: DOT_LITERAL});
          continue;
        }
        push({type: "dot", value, output: DOT_LITERAL});
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils2.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({type: "text", value, output});
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({type: "qmark", value, output: QMARK_NO_DOT});
          continue;
        }
        push({type: "qmark", value, output: QMARK});
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({type: "plus", value, output: PLUS_LITERAL});
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({type: "plus", value});
          continue;
        }
        push({type: "plus", value: PLUS_LITERAL});
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({type: "at", extglob: true, value, output: ""});
          continue;
        }
        push({type: "text", value});
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({type: "text", value});
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({type: "star", value, output: ""});
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({type: "star", value, output: ""});
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({type: "slash", value: "/", output: ""});
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = {type: "star", value, output: star};
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils2.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils2.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils2.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse.fastpaths = (input, options) => {
    const opts = {...options};
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils2.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {negated: false, prefix: ""};
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils2.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module2.exports = parse;
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var scan = require_scan();
  var parse = require_parse2();
  var utils2 = require_utils3();
  var constants = require_constants2();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils2.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
      const result = {glob, state, regex, posix, input, output, match, isMatch};
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, {glob, posix} = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return {isMatch: false, output: ""};
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils2.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return {isMatch: Boolean(match), match, output};
  };
  picomatch.matchBase = (input, glob, options, posix = utils2.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options));
    return parse(pattern, {...options, fastpaths: false});
  };
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return parsed.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${parsed.output})${append}`;
    if (parsed && parsed.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = parsed;
    }
    return regex;
  };
  picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    const opts = options || {};
    let parsed = {negated: false, fastpaths: true};
    let prefix = "";
    let output;
    if (input.startsWith("./")) {
      input = input.slice(2);
      prefix = parsed.prefix = "./";
    }
    if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      output = parse.fastpaths(input, options);
    }
    if (output === void 0) {
      parsed = parse(input, options);
      parsed.prefix = prefix + (parsed.prefix || "");
    } else {
      parsed.output = output;
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module2.exports = picomatch;
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_picomatch();
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var braces = require_braces();
  var picomatch = require_picomatch2();
  var utils2 = require_utils3();
  var isEmptyString = (val) => typeof val === "string" && (val === "" || val === "./");
  var micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), {...options, onResult}, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = micromatch(list, patterns, {...options, onResult});
    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, {...options, contains: true});
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils2.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils2.isWindows(options);
    let regex = picomatch.makeRe(String(glob), {...options, capture: true});
    let match = regex.exec(posix ? utils2.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === void 0 ? "" : v);
    }
  };
  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch.scan = (...args) => picomatch.scan(...args);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern, {...options, expand: true});
  };
  module2.exports = micromatch;
});

// node_modules/@semantic-release/commit-analyzer/lib/compare-release-types.js
var require_compare_release_types = __commonJS((exports2, module2) => {
  var RELEASE_TYPES = require_default_release_types();
  module2.exports = (currentReleaseType, releaseType) => !currentReleaseType || RELEASE_TYPES.indexOf(releaseType) < RELEASE_TYPES.indexOf(currentReleaseType);
});

// node_modules/@semantic-release/commit-analyzer/lib/analyze-commit.js
var require_analyze_commit = __commonJS((exports2, module2) => {
  var {isMatchWith, isString} = require_lodash();
  var micromatch = require_micromatch();
  var debug = require_src()("semantic-release:commit-analyzer");
  var RELEASE_TYPES = require_default_release_types();
  var compareReleaseTypes = require_compare_release_types();
  module2.exports = (releaseRules, commit) => {
    let releaseType;
    releaseRules.filter(({breaking, revert, release, ...rule}) => (!breaking || commit.notes && commit.notes.length > 0) && (!revert || commit.revert) && isMatchWith(commit, rule, (obj, src) => isString(src) && isString(obj) ? micromatch.isMatch(obj, src) : void 0)).every((match) => {
      if (compareReleaseTypes(releaseType, match.release)) {
        releaseType = match.release;
        debug("The rule %o match commit with release type %o", match, releaseType);
        if (releaseType === RELEASE_TYPES[0]) {
          debug("Release type %o is the highest possible. Stop analysis.", releaseType);
          return false;
        }
      } else {
        debug("The rule %o match commit with release type %o but the higher release type %o has already been found for this commit", match, match.release, releaseType);
      }
      return true;
    });
    return releaseType;
  };
});

// node_modules/@semantic-release/commit-analyzer/lib/default-release-rules.js
var require_default_release_rules = __commonJS((exports2, module2) => {
  module2.exports = [
    {breaking: true, release: "major"},
    {revert: true, release: "patch"},
    {type: "feat", release: "minor"},
    {type: "fix", release: "patch"},
    {type: "perf", release: "patch"},
    {emoji: ":racehorse:", release: "patch"},
    {emoji: ":bug:", release: "patch"},
    {emoji: ":penguin:", release: "patch"},
    {emoji: ":apple:", release: "patch"},
    {emoji: ":checkered_flag:", release: "patch"},
    {tag: "BUGFIX", release: "patch"},
    {tag: "FEATURE", release: "minor"},
    {tag: "SECURITY", release: "patch"},
    {tag: "Breaking", release: "major"},
    {tag: "Fix", release: "patch"},
    {tag: "Update", release: "minor"},
    {tag: "New", release: "minor"},
    {component: "perf", release: "patch"},
    {component: "deps", release: "patch"},
    {type: "FEAT", release: "minor"},
    {type: "FIX", release: "patch"}
  ];
});

// node_modules/@semantic-release/commit-analyzer/index.js
var require_commit_analyzer = __commonJS((exports2, module2) => {
  var {isUndefined} = require_lodash();
  var parser = require_conventional_commits_parser().sync;
  var filter = require_conventional_commits_filter();
  var debug = require_src()("semantic-release:commit-analyzer");
  var loadParserConfig = require_load_parser_config();
  var loadReleaseRules = require_load_release_rules();
  var analyzeCommit = require_analyze_commit();
  var compareReleaseTypes = require_compare_release_types();
  var RELEASE_TYPES = require_default_release_types();
  var DEFAULT_RELEASE_RULES = require_default_release_rules();
  async function analyzeCommits2(pluginConfig, context) {
    const {commits, logger} = context;
    const releaseRules = loadReleaseRules(pluginConfig, context);
    const config = await loadParserConfig(pluginConfig, context);
    let releaseType = null;
    filter(commits.filter(({message, hash}) => {
      if (!message.trim()) {
        debug("Skip commit %s with empty message", hash);
        return false;
      }
      return true;
    }).map(({message, ...commitProps}) => ({rawMsg: message, message, ...commitProps, ...parser(message, config)}))).every(({rawMsg, ...commit}) => {
      logger.log(`Analyzing commit: %s`, rawMsg);
      let commitReleaseType;
      if (releaseRules) {
        debug("Analyzing with custom rules");
        commitReleaseType = analyzeCommit(releaseRules, commit);
      }
      if (isUndefined(commitReleaseType)) {
        debug("Analyzing with default rules");
        commitReleaseType = analyzeCommit(DEFAULT_RELEASE_RULES, commit);
      }
      if (commitReleaseType) {
        logger.log("The release type for the commit is %s", commitReleaseType);
      } else {
        logger.log("The commit should not trigger a release");
      }
      if (commitReleaseType && compareReleaseTypes(releaseType, commitReleaseType)) {
        releaseType = commitReleaseType;
      }
      if (releaseType === RELEASE_TYPES[0]) {
        return false;
      }
      return true;
    });
    logger.log("Analysis of %s commits complete: %s release", commits.length, releaseType || "no");
    return releaseType;
  }
  module2.exports = {analyzeCommits: analyzeCommits2};
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS((exports2, module2) => {
  var once = require_once();
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// node_modules/pump/index.js
var require_pump = __commonJS((exports2, module2) => {
  var once = require_once();
  var eos = require_end_of_stream2();
  var fs = require("fs");
  var noop = function() {
  };
  var ancient = /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream) {
    if (!ancient)
      return false;
    if (!fs)
      return false;
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
  };
  var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, {readable: reading, writable: writing}, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream))
        return stream.close(noop);
      if (isRequest(stream))
        return stream.abort();
      if (isFn(stream.destroy))
        return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  module2.exports = pump;
});

// node_modules/@semantic-release/release-notes-generator/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {PassThrough: PassThroughStream} = require("stream");
  module2.exports = (options) => {
    options = {...options};
    const {array} = options;
    let {encoding} = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// node_modules/@semantic-release/release-notes-generator/node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {constants: BufferConstants} = require("buffer");
  var pump = require_pump();
  var bufferStream = require_buffer_stream();
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  async function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const {maxBuffer} = options;
    let stream;
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream.getBufferedValue();
  }
  module2.exports = getStream;
  module2.exports.default = getStream;
  module2.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: "buffer"});
  module2.exports.array = (stream, options) => getStream(stream, {...options, array: true});
  module2.exports.MaxBufferError = MaxBufferError;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module2.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = require_stream2();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  util.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex2();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require_stream_readable2();
  var Writable = require_stream_writable2();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream2();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = require("util");
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy2();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex2();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var Duplex = require_stream_duplex2();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform2();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable2();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable2();
    exports2.Duplex = require_stream_duplex2();
    exports2.Transform = require_stream_transform2();
    exports2.PassThrough = require_stream_passthrough2();
  }
});

// node_modules/from2/index.js
var require_from2 = __commonJS((exports2, module2) => {
  var Readable = require_readable2().Readable;
  var inherits = require_inherits();
  module2.exports = from2;
  from2.ctor = ctor;
  from2.obj = obj;
  var Proto = ctor();
  function toFunction(list) {
    list = list.slice();
    return function(_, cb) {
      var err = null;
      var item = list.length ? list.shift() : null;
      if (item instanceof Error) {
        err = item;
        item = null;
      }
      cb(err, item);
    };
  }
  function from2(opts, read) {
    if (typeof opts !== "object" || Array.isArray(opts)) {
      read = opts;
      opts = {};
    }
    var rs = new Proto(opts);
    rs._from = Array.isArray(read) ? toFunction(read) : read || noop;
    return rs;
  }
  function ctor(opts, read) {
    if (typeof opts === "function") {
      read = opts;
      opts = {};
    }
    opts = defaults(opts);
    inherits(Class, Readable);
    function Class(override) {
      if (!(this instanceof Class))
        return new Class(override);
      this._reading = false;
      this._callback = check;
      this.destroyed = false;
      Readable.call(this, override || opts);
      var self2 = this;
      var hwm = this._readableState.highWaterMark;
      function check(err, data) {
        if (self2.destroyed)
          return;
        if (err)
          return self2.destroy(err);
        if (data === null)
          return self2.push(null);
        self2._reading = false;
        if (self2.push(data))
          self2._read(hwm);
      }
    }
    Class.prototype._from = read || noop;
    Class.prototype._read = function(size) {
      if (this._reading || this.destroyed)
        return;
      this._reading = true;
      this._from(size, this._callback);
    };
    Class.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      var self2 = this;
      process.nextTick(function() {
        if (err)
          self2.emit("error", err);
        self2.emit("close");
      });
    };
    return Class;
  }
  function obj(opts, read) {
    if (typeof opts === "function" || Array.isArray(opts)) {
      read = opts;
      opts = {};
    }
    opts = defaults(opts);
    opts.objectMode = true;
    opts.highWaterMark = 16;
    return from2(opts, read);
  }
  function noop() {
  }
  function defaults(opts) {
    opts = opts || {};
    return opts;
  }
});

// node_modules/p-is-promise/index.js
var require_p_is_promise = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = (value) => value !== null && (typeof value === "object" || typeof value === "function");
  module2.exports = (value) => value instanceof Promise || isObject(value) && typeof value.then === "function" && typeof value.catch === "function";
});

// node_modules/into-stream/index.js
var require_into_stream = __commonJS((exports2, module2) => {
  "use strict";
  var from = require_from2();
  var pIsPromise = require_p_is_promise();
  var intoStream = (input) => {
    if (Array.isArray(input)) {
      input = input.slice();
    }
    let promise;
    let iterator;
    prepare(input);
    function prepare(value) {
      input = value;
      if (input instanceof ArrayBuffer || ArrayBuffer.isView(input) && !Buffer.isBuffer(input)) {
        input = Buffer.from(input);
      }
      promise = pIsPromise(input) ? input : null;
      const shouldIterate = !promise && input[Symbol.iterator] && typeof input !== "string" && !Buffer.isBuffer(input);
      iterator = shouldIterate ? input[Symbol.iterator]() : null;
    }
    return from(function reader(size, callback) {
      if (promise) {
        (async () => {
          try {
            await prepare(await promise);
            reader.call(this, size, callback);
          } catch (error) {
            callback(error);
          }
        })();
        return;
      }
      if (iterator) {
        const object = iterator.next();
        setImmediate(callback, null, object.done ? null : object.value);
        return;
      }
      if (input.length === 0) {
        setImmediate(callback, null, null);
        return;
      }
      const chunk = input.slice(0, size);
      input = input.slice(size);
      setImmediate(callback, null, chunk);
    });
  };
  module2.exports = intoStream;
  module2.exports.default = intoStream;
  module2.exports.object = (input) => {
    if (Array.isArray(input)) {
      input = input.slice();
    }
    let promise;
    let iterator;
    prepare(input);
    function prepare(value) {
      input = value;
      promise = pIsPromise(input) ? input : null;
      iterator = !promise && input[Symbol.iterator] ? input[Symbol.iterator]() : null;
    }
    return from.obj(function reader(size, callback) {
      if (promise) {
        (async () => {
          try {
            await prepare(await promise);
            reader.call(this, size, callback);
          } catch (error) {
            callback(error);
          }
        })();
        return;
      }
      if (iterator) {
        const object = iterator.next();
        setImmediate(callback, null, object.done ? null : object.value);
        return;
      }
      this.push(input);
      setImmediate(callback, null, null);
    });
  };
});

// node_modules/dateformat/lib/dateformat.js
var require_dateformat = __commonJS((exports2, module2) => {
  (function(global2) {
    "use strict";
    var dateFormat = function() {
      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
      var timezoneClip = /[^-+\dA-Z]/g;
      return function(date, mask, utc, gmt) {
        if (arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
          mask = date;
          date = void 0;
        }
        date = date || new Date();
        if (!(date instanceof Date)) {
          date = new Date(date);
        }
        if (isNaN(date)) {
          throw TypeError("Invalid date");
        }
        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
        var maskSlice = mask.slice(0, 4);
        if (maskSlice === "UTC:" || maskSlice === "GMT:") {
          mask = mask.slice(4);
          utc = true;
          if (maskSlice === "GMT:") {
            gmt = true;
          }
        }
        var _ = utc ? "getUTC" : "get";
        var d = date[_ + "Date"]();
        var D = date[_ + "Day"]();
        var m = date[_ + "Month"]();
        var y = date[_ + "FullYear"]();
        var H = date[_ + "Hours"]();
        var M = date[_ + "Minutes"]();
        var s = date[_ + "Seconds"]();
        var L = date[_ + "Milliseconds"]();
        var o = utc ? 0 : date.getTimezoneOffset();
        var W = getWeek(date);
        var N = getDayOfWeek(date);
        var flags = {
          d,
          dd: pad(d),
          ddd: dateFormat.i18n.dayNames[D],
          dddd: dateFormat.i18n.dayNames[D + 7],
          m: m + 1,
          mm: pad(m + 1),
          mmm: dateFormat.i18n.monthNames[m],
          mmmm: dateFormat.i18n.monthNames[m + 12],
          yy: String(y).slice(2),
          yyyy: y,
          h: H % 12 || 12,
          hh: pad(H % 12 || 12),
          H,
          HH: pad(H),
          M,
          MM: pad(M),
          s,
          ss: pad(s),
          l: pad(L, 3),
          L: pad(Math.round(L / 10)),
          t: H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
          tt: H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
          T: H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
          TT: H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
          Z: gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
          o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
          S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
          W,
          N
        };
        return mask.replace(token, function(match) {
          if (match in flags) {
            return flags[match];
          }
          return match.slice(1, match.length - 1);
        });
      };
    }();
    dateFormat.masks = {
      default: "ddd mmm dd yyyy HH:MM:ss",
      shortDate: "m/d/yy",
      mediumDate: "mmm d, yyyy",
      longDate: "mmmm d, yyyy",
      fullDate: "dddd, mmmm d, yyyy",
      shortTime: "h:MM TT",
      mediumTime: "h:MM:ss TT",
      longTime: "h:MM:ss TT Z",
      isoDate: "yyyy-mm-dd",
      isoTime: "HH:MM:ss",
      isoDateTime: "yyyy-mm-dd'T'HH:MM:sso",
      isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
      expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z"
    };
    dateFormat.i18n = {
      dayNames: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat",
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ],
      monthNames: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      timeNames: [
        "a",
        "p",
        "am",
        "pm",
        "A",
        "P",
        "AM",
        "PM"
      ]
    };
    function pad(val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    }
    function getWeek(date) {
      var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
      var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
      firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
      var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
      targetThursday.setHours(targetThursday.getHours() - ds);
      var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
      return 1 + Math.floor(weekDiff);
    }
    function getDayOfWeek(date) {
      var dow = date.getDay();
      if (dow === 0) {
        dow = 7;
      }
      return dow;
    }
    function kindOf(val) {
      if (val === null) {
        return "null";
      }
      if (val === void 0) {
        return "undefined";
      }
      if (typeof val !== "object") {
        return typeof val;
      }
      if (Array.isArray(val)) {
        return "array";
      }
      return {}.toString.call(val).slice(8, -1).toLowerCase();
    }
    ;
    if (typeof define === "function" && define.amd) {
      define(function() {
        return dateFormat;
      });
    } else if (typeof exports2 === "object") {
      module2.exports = dateFormat;
    } else {
      global2.dateFormat = dateFormat;
    }
  })(exports2);
});

// node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils4 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.extend = extend;
  exports2.indexOf = indexOf;
  exports2.escapeExpression = escapeExpression;
  exports2.isEmpty = isEmpty;
  exports2.createFrame = createFrame;
  exports2.blockParams = blockParams;
  exports2.appendContextPath = appendContextPath;
  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;",
    "=": "&#x3D;"
  };
  var badChars = /[&<>"'`=]/g;
  var possible = /[&<>"'`=]/;
  function escapeChar(chr) {
    return escape[chr];
  }
  function extend(obj) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }
    return obj;
  }
  var toString = Object.prototype.toString;
  exports2.toString = toString;
  var isFunction = function isFunction2(value) {
    return typeof value === "function";
  };
  if (isFunction(/x/)) {
    exports2.isFunction = isFunction = function(value) {
      return typeof value === "function" && toString.call(value) === "[object Function]";
    };
  }
  exports2.isFunction = isFunction;
  var isArray = Array.isArray || function(value) {
    return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
  };
  exports2.isArray = isArray;
  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }
  function escapeExpression(string) {
    if (typeof string !== "string") {
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return "";
      } else if (!string) {
        return string + "";
      }
      string = "" + string;
    }
    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }
  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }
  function createFrame(object) {
    var frame = extend({}, object);
    frame._parent = object;
    return frame;
  }
  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }
  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + "." : "") + id;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function Exception(message, node) {
    var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;
      message += " - " + line + ":" + column;
    }
    var tmp = Error.prototype.constructor.call(this, message);
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }
    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;
        if (Object.defineProperty) {
          Object.defineProperty(this, "column", {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, "endColumn", {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
    }
  }
  Exception.prototype = new Error();
  exports2["default"] = Exception;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var _utils = require_utils4();
  exports2["default"] = function(instance) {
    instance.registerHelper("blockHelperMissing", function(context, options) {
      var inverse = options.inverse, fn = options.fn;
      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
          options = {data};
        }
        return fn(context, options);
      }
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _utils = require_utils4();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports2["default"] = function(instance) {
    instance.registerHelper("each", function(context, options) {
      if (!options) {
        throw new _exception2["default"]("Must pass iterator to #each");
      }
      var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
      if (options.data && options.ids) {
        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      if (options.data) {
        data = _utils.createFrame(options.data);
      }
      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;
          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }
        ret = ret + fn(context[field], {
          data,
          blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
        });
      }
      if (context && typeof context === "object") {
        if (_utils.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (global.Symbol && context[global.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[global.Symbol.iterator]();
          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function() {
            var priorKey = void 0;
            Object.keys(context).forEach(function(key) {
              if (priorKey !== void 0) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== void 0) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret;
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports2["default"] = function(instance) {
    instance.registerHelper("helperMissing", function() {
      if (arguments.length === 1) {
        return void 0;
      } else {
        throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _utils = require_utils4();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports2["default"] = function(instance) {
    instance.registerHelper("if", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#if requires exactly one argument");
      }
      if (_utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      }
      if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    instance.registerHelper("unless", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#unless requires exactly one argument");
      }
      return instance.helpers["if"].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = function(instance) {
    instance.registerHelper("log", function() {
      var args = [void 0], options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }
      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;
      instance.log.apply(instance, args);
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = function(instance) {
    instance.registerHelper("lookup", function(obj, field, options) {
      if (!obj) {
        return obj;
      }
      return options.lookupProperty(obj, field);
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _utils = require_utils4();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports2["default"] = function(instance) {
    instance.registerHelper("with", function(context, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#with requires exactly one argument");
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      var fn = options.fn;
      if (!_utils.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }
        return fn(context, {
          data,
          blockParams: _utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.registerDefaultHelpers = registerDefaultHelpers;
  exports2.moveHelperToHooks = moveHelperToHooks;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _helpersBlockHelperMissing = require_block_helper_missing();
  var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
  var _helpersEach = require_each();
  var _helpersEach2 = _interopRequireDefault(_helpersEach);
  var _helpersHelperMissing = require_helper_missing();
  var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
  var _helpersIf = require_if();
  var _helpersIf2 = _interopRequireDefault(_helpersIf);
  var _helpersLog = require_log();
  var _helpersLog2 = _interopRequireDefault(_helpersLog);
  var _helpersLookup = require_lookup();
  var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
  var _helpersWith = require_with();
  var _helpersWith2 = _interopRequireDefault(_helpersWith);
  function registerDefaultHelpers(instance) {
    _helpersBlockHelperMissing2["default"](instance);
    _helpersEach2["default"](instance);
    _helpersHelperMissing2["default"](instance);
    _helpersIf2["default"](instance);
    _helpersLog2["default"](instance);
    _helpersLookup2["default"](instance);
    _helpersWith2["default"](instance);
  }
  function moveHelperToHooks(instance, helperName, keepHelper) {
    if (instance.helpers[helperName]) {
      instance.hooks[helperName] = instance.helpers[helperName];
      if (!keepHelper) {
        delete instance.helpers[helperName];
      }
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var _utils = require_utils4();
  exports2["default"] = function(instance) {
    instance.registerDecorator("inline", function(fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function(context, options2) {
          var original = container.partials;
          container.partials = _utils.extend({}, original, props.partials);
          var ret2 = fn(context, options2);
          container.partials = original;
          return ret2;
        };
      }
      props.partials[options.args[0]] = options.fn;
      return ret;
    });
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.registerDefaultDecorators = registerDefaultDecorators;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _decoratorsInline = require_inline();
  var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
  function registerDefaultDecorators(instance) {
    _decoratorsInline2["default"](instance);
  }
});

// node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var _utils = require_utils4();
  var logger = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    lookupLevel: function lookupLevel(level) {
      if (typeof level === "string") {
        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }
      return level;
    },
    log: function log(level) {
      level = logger.lookupLevel(level);
      if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
        var method = logger.methodMap[level];
        if (!console[method]) {
          method = "log";
        }
        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }
        console[method].apply(console, message);
      }
    }
  };
  exports2["default"] = logger;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.createNewLookupObject = createNewLookupObject;
  var _utils = require_utils4();
  function createNewLookupObject() {
    for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    return _utils.extend.apply(void 0, [Object.create(null)].concat(sources));
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.createProtoAccessControl = createProtoAccessControl;
  exports2.resultIsAllowed = resultIsAllowed;
  exports2.resetLoggedProperties = resetLoggedProperties;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  var _createNewLookupObject = require_create_new_lookup_object();
  var _logger = require_logger();
  var logger = _interopRequireWildcard(_logger);
  var loggedProperties = Object.create(null);
  function createProtoAccessControl(runtimeOptions) {
    var defaultMethodWhiteList = Object.create(null);
    defaultMethodWhiteList["constructor"] = false;
    defaultMethodWhiteList["__defineGetter__"] = false;
    defaultMethodWhiteList["__defineSetter__"] = false;
    defaultMethodWhiteList["__lookupGetter__"] = false;
    var defaultPropertyWhiteList = Object.create(null);
    defaultPropertyWhiteList["__proto__"] = false;
    return {
      properties: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
        defaultValue: runtimeOptions.allowProtoPropertiesByDefault
      },
      methods: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
        defaultValue: runtimeOptions.allowProtoMethodsByDefault
      }
    };
  }
  function resultIsAllowed(result, protoAccessControl, propertyName) {
    if (typeof result === "function") {
      return checkWhiteList(protoAccessControl.methods, propertyName);
    } else {
      return checkWhiteList(protoAccessControl.properties, propertyName);
    }
  }
  function checkWhiteList(protoAccessControlForType, propertyName) {
    if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
      return protoAccessControlForType.whitelist[propertyName] === true;
    }
    if (protoAccessControlForType.defaultValue !== void 0) {
      return protoAccessControlForType.defaultValue;
    }
    logUnexpecedPropertyAccessOnce(propertyName);
    return false;
  }
  function logUnexpecedPropertyAccessOnce(propertyName) {
    if (loggedProperties[propertyName] !== true) {
      loggedProperties[propertyName] = true;
      logger.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
    }
  }
  function resetLoggedProperties() {
    Object.keys(loggedProperties).forEach(function(propertyName) {
      delete loggedProperties[propertyName];
    });
  }
});

// node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.HandlebarsEnvironment = HandlebarsEnvironment;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _utils = require_utils4();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _helpers = require_helpers();
  var _decorators = require_decorators();
  var _logger = require_logger();
  var _logger2 = _interopRequireDefault(_logger);
  var _internalProtoAccess = require_proto_access();
  var VERSION = "4.7.6";
  exports2.VERSION = VERSION;
  var COMPILER_REVISION = 8;
  exports2.COMPILER_REVISION = COMPILER_REVISION;
  var LAST_COMPATIBLE_COMPILER_REVISION = 7;
  exports2.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: "<= 1.0.rc.2",
    2: "== 1.0.0-rc.3",
    3: "== 1.0.0-rc.4",
    4: "== 1.x.x",
    5: "== 2.0.0-alpha.x",
    6: ">= 2.0.0-beta.1",
    7: ">= 4.0.0 <4.3.0",
    8: ">= 4.3.0"
  };
  exports2.REVISION_CHANGES = REVISION_CHANGES;
  var objectType = "[object Object]";
  function HandlebarsEnvironment(helpers, partials, decorators) {
    this.helpers = helpers || {};
    this.partials = partials || {};
    this.decorators = decorators || {};
    _helpers.registerDefaultHelpers(this);
    _decorators.registerDefaultDecorators(this);
  }
  HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,
    logger: _logger2["default"],
    log: _logger2["default"].log,
    registerHelper: function registerHelper(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2["default"]("Arg not supported with multiple helpers");
        }
        _utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function unregisterHelper(name) {
      delete this.helpers[name];
    },
    registerPartial: function registerPartial(name, partial) {
      if (_utils.toString.call(name) === objectType) {
        _utils.extend(this.partials, name);
      } else {
        if (typeof partial === "undefined") {
          throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function unregisterPartial(name) {
      delete this.partials[name];
    },
    registerDecorator: function registerDecorator(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2["default"]("Arg not supported with multiple decorators");
        }
        _utils.extend(this.decorators, name);
      } else {
        this.decorators[name] = fn;
      }
    },
    unregisterDecorator: function unregisterDecorator(name) {
      delete this.decorators[name];
    },
    resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
      _internalProtoAccess.resetLoggedProperties();
    }
  };
  var log = _logger2["default"].log;
  exports2.log = log;
  exports2.createFrame = _utils.createFrame;
  exports2.logger = _logger2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }
  SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    return "" + this.string;
  };
  exports2["default"] = SafeString;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.wrapHelper = wrapHelper;
  function wrapHelper(helper, transformOptionsFn) {
    if (typeof helper !== "function") {
      return helper;
    }
    var wrapper = function wrapper2() {
      var options = arguments[arguments.length - 1];
      arguments[arguments.length - 1] = transformOptionsFn(options);
      return helper.apply(this, arguments);
    };
    return wrapper;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.checkRevision = checkRevision;
  exports2.template = template;
  exports2.wrapProgram = wrapProgram;
  exports2.resolvePartial = resolvePartial;
  exports2.invokePartial = invokePartial;
  exports2.noop = noop;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  var _utils = require_utils4();
  var Utils = _interopRequireWildcard(_utils);
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _base = require_base();
  var _helpers = require_helpers();
  var _internalWrapHelper = require_wrapHelper();
  var _internalProtoAccess = require_proto_access();
  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
    if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
      return;
    }
    if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
    } else {
      throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
    }
  }
  function template(templateSpec, env) {
    if (!env) {
      throw new _exception2["default"]("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
    }
    templateSpec.main.decorator = templateSpec.main_d;
    env.VM.checkRevision(templateSpec.compiler);
    var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
    function invokePartialWrapper(partial, context, options) {
      if (options.hash) {
        context = Utils.extend({}, context, options.hash);
        if (options.ids) {
          options.ids[0] = true;
        }
      }
      partial = env.VM.resolvePartial.call(this, partial, context, options);
      var extendedOptions = Utils.extend({}, options, {
        hooks: this.hooks,
        protoAccessControl: this.protoAccessControl
      });
      var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
      if (result == null && env.compile) {
        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
        result = options.partials[options.name](context, extendedOptions);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split("\n");
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }
            lines[i] = options.indent + lines[i];
          }
          result = lines.join("\n");
        }
        return result;
      } else {
        throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
      }
    }
    var container = {
      strict: function strict(obj, name, loc) {
        if (!obj || !(name in obj)) {
          throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
            loc
          });
        }
        return obj[name];
      },
      lookupProperty: function lookupProperty(parent, propertyName) {
        var result = parent[propertyName];
        if (result == null) {
          return result;
        }
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return result;
        }
        if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
          return result;
        }
        return void 0;
      },
      lookup: function lookup(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          var result = depths[i] && container.lookupProperty(depths[i], name);
          if (result != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function lambda(current, context) {
        return typeof current === "function" ? current.call(context) : current;
      },
      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,
      fn: function fn(i) {
        var ret2 = templateSpec[i];
        ret2.decorator = templateSpec[i + "_d"];
        return ret2;
      },
      programs: [],
      program: function program(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i], fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = wrapProgram(this, i, fn);
        }
        return programWrapper;
      },
      data: function data(value, depth) {
        while (value && depth--) {
          value = value._parent;
        }
        return value;
      },
      mergeIfNeeded: function mergeIfNeeded(param, common) {
        var obj = param || common;
        if (param && common && param !== common) {
          obj = Utils.extend({}, common, param);
        }
        return obj;
      },
      nullContext: Object.seal({}),
      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };
    function ret(context) {
      var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
      var data = options.data;
      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
      if (templateSpec.useDepths) {
        if (options.depths) {
          depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
        } else {
          depths = [context];
        }
      }
      function main(context2) {
        return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
      }
      main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
      return main(context, options);
    }
    ret.isTop = true;
    ret._setup = function(options) {
      if (!options.partial) {
        var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
        wrapHelpersToPassLookupProperty(mergedHelpers, container);
        container.helpers = mergedHelpers;
        if (templateSpec.usePartial) {
          container.partials = container.mergeIfNeeded(options.partials, env.partials);
        }
        if (templateSpec.usePartial || templateSpec.useDecorators) {
          container.decorators = Utils.extend({}, env.decorators, options.decorators);
        }
        container.hooks = {};
        container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
        var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
        _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
        _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
      } else {
        container.protoAccessControl = options.protoAccessControl;
        container.helpers = options.helpers;
        container.partials = options.partials;
        container.decorators = options.decorators;
        container.hooks = options.hooks;
      }
    };
    ret._child = function(i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new _exception2["default"]("must pass block params");
      }
      if (templateSpec.useDepths && !depths) {
        throw new _exception2["default"]("must pass parent depths");
      }
      return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  }
  function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    function prog(context) {
      var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
      var currentDepths = depths;
      if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
        currentDepths = [context].concat(depths);
      }
      return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    }
    prog = executeDecorators(fn, prog, container, depths, data, blockParams);
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  }
  function resolvePartial(partial, context, options) {
    if (!partial) {
      if (options.name === "@partial-block") {
        partial = options.data["partial-block"];
      } else {
        partial = options.partials[options.name];
      }
    } else if (!partial.call && !options.name) {
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  }
  function invokePartial(partial, context, options) {
    var currentPartialBlock = options.data && options.data["partial-block"];
    options.partial = true;
    if (options.ids) {
      options.data.contextPath = options.ids[0] || options.data.contextPath;
    }
    var partialBlock = void 0;
    if (options.fn && options.fn !== noop) {
      (function() {
        options.data = _base.createFrame(options.data);
        var fn = options.fn;
        partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
          var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          options2.data = _base.createFrame(options2.data);
          options2.data["partial-block"] = currentPartialBlock;
          return fn(context2, options2);
        };
        if (fn.partials) {
          options.partials = Utils.extend({}, options.partials, fn.partials);
        }
      })();
    }
    if (partial === void 0 && partialBlock) {
      partial = partialBlock;
    }
    if (partial === void 0) {
      throw new _exception2["default"]("The partial " + options.name + " could not be found");
    } else if (partial instanceof Function) {
      return partial(context, options);
    }
  }
  function noop() {
    return "";
  }
  function initData(context, data) {
    if (!data || !("root" in data)) {
      data = data ? _base.createFrame(data) : {};
      data.root = context;
    }
    return data;
  }
  function executeDecorators(fn, prog, container, depths, data, blockParams) {
    if (fn.decorator) {
      var props = {};
      prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
      Utils.extend(prog, props);
    }
    return prog;
  }
  function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
    Object.keys(mergedHelpers).forEach(function(helperName) {
      var helper = mergedHelpers[helperName];
      mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
    });
  }
  function passLookupPropertyOption(helper, container) {
    var lookupProperty = container.lookupProperty;
    return _internalWrapHelper.wrapHelper(helper, function(options) {
      return Utils.extend({lookupProperty}, options);
    });
  }
});

// node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = function(Handlebars) {
    var root = typeof global !== "undefined" ? global : window, $Handlebars = root.Handlebars;
    Handlebars.noConflict = function() {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  var _handlebarsBase = require_base();
  var base = _interopRequireWildcard(_handlebarsBase);
  var _handlebarsSafeString = require_safe_string();
  var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
  var _handlebarsException = require_exception();
  var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
  var _handlebarsUtils = require_utils4();
  var Utils = _interopRequireWildcard(_handlebarsUtils);
  var _handlebarsRuntime = require_runtime();
  var runtime = _interopRequireWildcard(_handlebarsRuntime);
  var _handlebarsNoConflict = require_no_conflict();
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
  function create() {
    var hb = new base.HandlebarsEnvironment();
    Utils.extend(hb, base);
    hb.SafeString = _handlebarsSafeString2["default"];
    hb.Exception = _handlebarsException2["default"];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;
    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };
    return hb;
  }
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2["default"](inst);
  inst["default"] = inst;
  exports2["default"] = inst;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var AST = {
    helpers: {
      helperExpression: function helperExpression(node) {
        return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
      },
      scopedId: function scopedId(path) {
        return /^\.|this\b/.test(path.original);
      },
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };
  exports2["default"] = AST;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var handlebars = function() {
    var parser = {
      trace: function trace() {
      },
      yy: {},
      symbols_: {error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1},
      terminals_: {2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP"},
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return $$[$0 - 1];
            break;
          case 2:
            this.$ = yy.prepareProgram($$[$0]);
            break;
          case 3:
            this.$ = $$[$0];
            break;
          case 4:
            this.$ = $$[$0];
            break;
          case 5:
            this.$ = $$[$0];
            break;
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
            this.$ = $$[$0];
            break;
          case 8:
            this.$ = $$[$0];
            break;
          case 9:
            this.$ = {
              type: "CommentStatement",
              value: yy.stripComment($$[$0]),
              strip: yy.stripFlags($$[$0], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 10:
            this.$ = {
              type: "ContentStatement",
              original: $$[$0],
              value: $$[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 11:
            this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 12:
            this.$ = {path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1]};
            break;
          case 13:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
            break;
          case 14:
            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
            break;
          case 15:
            this.$ = {open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0])};
            break;
          case 16:
            this.$ = {path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0])};
            break;
          case 17:
            this.$ = {path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0])};
            break;
          case 18:
            this.$ = {strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0]};
            break;
          case 19:
            var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
            program.chained = true;
            this.$ = {strip: $$[$0 - 2].strip, program, chain: true};
            break;
          case 20:
            this.$ = $$[$0];
            break;
          case 21:
            this.$ = {path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0])};
            break;
          case 22:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 23:
            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
            break;
          case 24:
            this.$ = {
              type: "PartialStatement",
              name: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              indent: "",
              strip: yy.stripFlags($$[$0 - 4], $$[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 25:
            this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
            break;
          case 26:
            this.$ = {path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0])};
            break;
          case 27:
            this.$ = $$[$0];
            break;
          case 28:
            this.$ = $$[$0];
            break;
          case 29:
            this.$ = {
              type: "SubExpression",
              path: $$[$0 - 3],
              params: $$[$0 - 2],
              hash: $$[$0 - 1],
              loc: yy.locInfo(this._$)
            };
            break;
          case 30:
            this.$ = {type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$)};
            break;
          case 31:
            this.$ = {type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$)};
            break;
          case 32:
            this.$ = yy.id($$[$0 - 1]);
            break;
          case 33:
            this.$ = $$[$0];
            break;
          case 34:
            this.$ = $$[$0];
            break;
          case 35:
            this.$ = {type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$)};
            break;
          case 36:
            this.$ = {type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$)};
            break;
          case 37:
            this.$ = {type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$)};
            break;
          case 38:
            this.$ = {type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$)};
            break;
          case 39:
            this.$ = {type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$)};
            break;
          case 40:
            this.$ = $$[$0];
            break;
          case 41:
            this.$ = $$[$0];
            break;
          case 42:
            this.$ = yy.preparePath(true, $$[$0], this._$);
            break;
          case 43:
            this.$ = yy.preparePath(false, $$[$0], this._$);
            break;
          case 44:
            $$[$0 - 2].push({part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1]});
            this.$ = $$[$0 - 2];
            break;
          case 45:
            this.$ = [{part: yy.id($$[$0]), original: $$[$0]}];
            break;
          case 46:
            this.$ = [];
            break;
          case 47:
            $$[$0 - 1].push($$[$0]);
            break;
          case 48:
            this.$ = [];
            break;
          case 49:
            $$[$0 - 1].push($$[$0]);
            break;
          case 50:
            this.$ = [];
            break;
          case 51:
            $$[$0 - 1].push($$[$0]);
            break;
          case 58:
            this.$ = [];
            break;
          case 59:
            $$[$0 - 1].push($$[$0]);
            break;
          case 64:
            this.$ = [];
            break;
          case 65:
            $$[$0 - 1].push($$[$0]);
            break;
          case 70:
            this.$ = [];
            break;
          case 71:
            $$[$0 - 1].push($$[$0]);
            break;
          case 78:
            this.$ = [];
            break;
          case 79:
            $$[$0 - 1].push($$[$0]);
            break;
          case 82:
            this.$ = [];
            break;
          case 83:
            $$[$0 - 1].push($$[$0]);
            break;
          case 86:
            this.$ = [];
            break;
          case 87:
            $$[$0 - 1].push($$[$0]);
            break;
          case 90:
            this.$ = [];
            break;
          case 91:
            $$[$0 - 1].push($$[$0]);
            break;
          case 94:
            this.$ = [];
            break;
          case 95:
            $$[$0 - 1].push($$[$0]);
            break;
          case 98:
            this.$ = [$$[$0]];
            break;
          case 99:
            $$[$0 - 1].push($$[$0]);
            break;
          case 100:
            this.$ = [$$[$0]];
            break;
          case 101:
            $$[$0 - 1].push($$[$0]);
            break;
        }
      },
      table: [{3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {1: [3]}, {5: [1, 4]}, {5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24]}, {1: [2, 1]}, {5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47]}, {5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3]}, {5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4]}, {5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5]}, {5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6]}, {5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7]}, {5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8]}, {5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9]}, {20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {15: [2, 48], 17: 39, 18: [2, 48]}, {20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10]}, {20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78]}, {23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33]}, {23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34]}, {23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35]}, {23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36]}, {23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37]}, {23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38]}, {23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39]}, {23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50]}, {72: [1, 35], 86: 51}, {23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45]}, {52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82]}, {25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54]}, {28: 59, 43: 60, 44: [1, 58], 47: [2, 56]}, {13: 62, 15: [1, 20], 18: [1, 61]}, {33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86]}, {33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40]}, {33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41]}, {20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {26: 65, 47: [1, 66]}, {30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58]}, {33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64]}, {21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50]}, {33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90]}, {20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {72: [1, 79]}, {23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50]}, {20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {26: 83, 47: [1, 66]}, {47: [2, 55]}, {4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {47: [2, 20]}, {20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46]}, {26: 87, 47: [1, 66]}, {47: [2, 57]}, {5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11]}, {15: [2, 49], 18: [2, 49]}, {20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94]}, {5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25]}, {20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {33: [1, 105]}, {33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79]}, {33: [2, 81]}, {23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27]}, {23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28]}, {23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30]}, {23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98]}, {23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45]}, {23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44]}, {54: [1, 109]}, {54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83]}, {54: [2, 85]}, {5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13]}, {38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76]}, {33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70]}, {47: [2, 18]}, {5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14]}, {33: [1, 113]}, {33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87]}, {33: [2, 89]}, {20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {33: [1, 117]}, {32: 118, 33: [2, 62], 74: 119, 75: [1, 120]}, {33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59]}, {33: [2, 61], 75: [2, 61]}, {33: [2, 68], 37: 121, 74: 122, 75: [1, 120]}, {33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65]}, {33: [2, 67], 75: [2, 67]}, {23: [1, 123]}, {23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51]}, {23: [2, 53]}, {33: [1, 124]}, {33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91]}, {33: [2, 93]}, {5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22]}, {23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99]}, {73: [1, 108]}, {20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23]}, {47: [2, 19]}, {47: [2, 77]}, {20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33}, {5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24]}, {68: [1, 129]}, {65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95]}, {68: [2, 97]}, {5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21]}, {33: [1, 130]}, {33: [2, 63]}, {72: [1, 132], 76: 131}, {33: [1, 133]}, {33: [2, 69]}, {15: [2, 12], 18: [2, 12]}, {14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26]}, {23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31]}, {33: [2, 74], 42: 134, 74: 135, 75: [1, 120]}, {33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71]}, {33: [2, 73], 75: [2, 73]}, {23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29]}, {14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15]}, {72: [1, 137], 77: [1, 136]}, {72: [2, 100], 77: [2, 100]}, {14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16]}, {33: [1, 138]}, {33: [2, 75]}, {33: [2, 32]}, {72: [2, 101], 77: [2, 101]}, {14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17]}],
      defaultActions: {4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32]},
      parseError: function parseError(str, hash) {
        throw new Error(str);
      },
      parse: function parse(input) {
        var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
        this.lexer.setInput(input);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        this.yy.parser = this;
        if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
        var ranges = this.lexer.options && this.lexer.options.ranges;
        if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
        function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
        }
        function lex() {
          var token;
          token = self2.lexer.lex() || 1;
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token;
        }
        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            if (!recovering) {
              expected = [];
              for (p in table[state])
                if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
              if (this.lexer.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }
              this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected});
            }
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {first_line: 1, first_column: 0, last_line: 1, last_column: 0};
          if (this.options.ranges)
            this.yylloc.range = [0, 0];
          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges)
            this.yylloc.range[1]++;
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1)
            this.yylineno -= lines.length - 1;
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input)
            this.done = true;
          var token, match, tempMatch, index, col, lines;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (!this.options.flex)
                break;
            }
          }
          if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines)
              this.yylineno += lines.length;
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input)
              this.done = false;
            if (token)
              return token;
            else
              return;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {text: "", token: null, line: this.yylineno});
          }
        },
        lex: function lex() {
          var r = this.next();
          if (typeof r !== "undefined") {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          return this.conditionStack.pop();
        },
        _currentRules: function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function topState() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function begin(condition) {
          this.begin(condition);
        }
      };
      lexer2.options = {};
      lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        function strip(start, end) {
          return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
        }
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            if (yy_.yytext.slice(-2) === "\\\\") {
              strip(0, 1);
              this.begin("mu");
            } else if (yy_.yytext.slice(-1) === "\\") {
              strip(0, 1);
              this.begin("emu");
            } else {
              this.begin("mu");
            }
            if (yy_.yytext)
              return 15;
            break;
          case 1:
            return 15;
            break;
          case 2:
            this.popState();
            return 15;
            break;
          case 3:
            this.begin("raw");
            return 15;
            break;
          case 4:
            this.popState();
            if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
              return 15;
            } else {
              strip(5, 9);
              return "END_RAW_BLOCK";
            }
            break;
          case 5:
            return 15;
            break;
          case 6:
            this.popState();
            return 14;
            break;
          case 7:
            return 65;
            break;
          case 8:
            return 68;
            break;
          case 9:
            return 19;
            break;
          case 10:
            this.popState();
            this.begin("raw");
            return 23;
            break;
          case 11:
            return 55;
            break;
          case 12:
            return 60;
            break;
          case 13:
            return 29;
            break;
          case 14:
            return 47;
            break;
          case 15:
            this.popState();
            return 44;
            break;
          case 16:
            this.popState();
            return 44;
            break;
          case 17:
            return 34;
            break;
          case 18:
            return 39;
            break;
          case 19:
            return 51;
            break;
          case 20:
            return 48;
            break;
          case 21:
            this.unput(yy_.yytext);
            this.popState();
            this.begin("com");
            break;
          case 22:
            this.popState();
            return 14;
            break;
          case 23:
            return 48;
            break;
          case 24:
            return 73;
            break;
          case 25:
            return 72;
            break;
          case 26:
            return 72;
            break;
          case 27:
            return 87;
            break;
          case 28:
            break;
          case 29:
            this.popState();
            return 54;
            break;
          case 30:
            this.popState();
            return 33;
            break;
          case 31:
            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
            return 80;
            break;
          case 32:
            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
            return 80;
            break;
          case 33:
            return 85;
            break;
          case 34:
            return 82;
            break;
          case 35:
            return 82;
            break;
          case 36:
            return 83;
            break;
          case 37:
            return 84;
            break;
          case 38:
            return 81;
            break;
          case 39:
            return 75;
            break;
          case 40:
            return 77;
            break;
          case 41:
            return 72;
            break;
          case 42:
            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
            return 72;
            break;
          case 43:
            return "INVALID";
            break;
          case 44:
            return 5;
            break;
        }
      };
      lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
      lexer2.conditions = {mu: {rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: false}, emu: {rules: [2], inclusive: false}, com: {rules: [6], inclusive: false}, raw: {rules: [3, 4, 5], inclusive: false}, INITIAL: {rules: [0, 1, 44], inclusive: true}};
      return lexer2;
    }();
    parser.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();
  exports2["default"] = handlebars;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  function Visitor() {
    this.parents = [];
  }
  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,
    acceptKey: function acceptKey(node, name) {
      var value = this.accept(node[name]);
      if (this.mutating) {
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
        }
        node[name] = value;
      }
    },
    acceptRequired: function acceptRequired(node, name) {
      this.acceptKey(node, name);
      if (!node[name]) {
        throw new _exception2["default"](node.type + " requires " + name);
      }
    },
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);
        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },
    accept: function accept(object) {
      if (!object) {
        return;
      }
      if (!this[object.type]) {
        throw new _exception2["default"]("Unknown type: " + object.type, object);
      }
      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object;
      var ret = this[object.type](object);
      this.current = this.parents.shift();
      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },
    Program: function Program(program) {
      this.acceptArray(program.body);
    },
    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,
    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,
    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement(partial) {
      visitPartial.call(this, partial);
      this.acceptKey(partial, "program");
    },
    ContentStatement: function ContentStatement() {
    },
    CommentStatement: function CommentStatement() {
    },
    SubExpression: visitSubExpression,
    PathExpression: function PathExpression() {
    },
    StringLiteral: function StringLiteral() {
    },
    NumberLiteral: function NumberLiteral() {
    },
    BooleanLiteral: function BooleanLiteral() {
    },
    UndefinedLiteral: function UndefinedLiteral() {
    },
    NullLiteral: function NullLiteral() {
    },
    Hash: function Hash(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, "value");
    }
  };
  function visitSubExpression(mustache) {
    this.acceptRequired(mustache, "path");
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, "hash");
  }
  function visitBlock(block) {
    visitSubExpression.call(this, block);
    this.acceptKey(block, "program");
    this.acceptKey(block, "inverse");
  }
  function visitPartial(partial) {
    this.acceptRequired(partial, "name");
    this.acceptArray(partial.params);
    this.acceptKey(partial, "hash");
  }
  exports2["default"] = Visitor;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _visitor = require_visitor();
  var _visitor2 = _interopRequireDefault(_visitor);
  function WhitespaceControl() {
    var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = options;
  }
  WhitespaceControl.prototype = new _visitor2["default"]();
  WhitespaceControl.prototype.Program = function(program) {
    var doStandalone = !this.options.ignoreStandalone;
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;
    var body = program.body;
    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i], strip = this.accept(current);
      if (!strip) {
        continue;
      }
      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }
      if (doStandalone && inlineStandalone) {
        omitRight(body, i);
        if (omitLeft(body, i)) {
          if (current.type === "PartialStatement") {
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body);
        omitLeft(body, i);
      }
      if (doStandalone && closeStandalone) {
        omitRight(body, i);
        omitLeft((current.inverse || current.program).body);
      }
    }
    return program;
  };
  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
    this.accept(block.program);
    this.accept(block.inverse);
    var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }
    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };
    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }
    if (inverse) {
      var inverseStrip = block.inverseStrip;
      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }
      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }
      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }
    return strip;
  };
  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
    return mustache.strip;
  };
  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
    var strip = node.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };
  function isPrevWhitespace(body, i, isRoot) {
    if (i === void 0) {
      i = body.length;
    }
    var prev = body[i - 1], sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }
    if (prev.type === "ContentStatement") {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }
  function isNextWhitespace(body, i, isRoot) {
    if (i === void 0) {
      i = -1;
    }
    var next = body[i + 1], sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }
    if (next.type === "ContentStatement") {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  }
  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
    current.rightStripped = current.value !== original;
  }
  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }
  exports2["default"] = WhitespaceControl;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers2 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.SourceLocation = SourceLocation;
  exports2.id = id;
  exports2.stripFlags = stripFlags;
  exports2.stripComment = stripComment;
  exports2.preparePath = preparePath;
  exports2.prepareMustache = prepareMustache;
  exports2.prepareRawBlock = prepareRawBlock;
  exports2.prepareBlock = prepareBlock;
  exports2.prepareProgram = prepareProgram;
  exports2.preparePartialBlock = preparePartialBlock;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  function validateClose(open, close) {
    close = close.path ? close.path.original : close;
    if (open.path.original !== close) {
      var errorNode = {loc: open.path.loc};
      throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
    }
  }
  function SourceLocation(source, locInfo) {
    this.source = source;
    this.start = {
      line: locInfo.first_line,
      column: locInfo.first_column
    };
    this.end = {
      line: locInfo.last_line,
      column: locInfo.last_column
    };
  }
  function id(token) {
    if (/^\[.*\]$/.test(token)) {
      return token.substring(1, token.length - 1);
    } else {
      return token;
    }
  }
  function stripFlags(open, close) {
    return {
      open: open.charAt(2) === "~",
      close: close.charAt(close.length - 3) === "~"
    };
  }
  function stripComment(comment) {
    return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
  }
  function preparePath(data, parts, loc) {
    loc = this.locInfo(loc);
    var original = data ? "@" : "", dig = [], depth = 0;
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i].part, isLiteral = parts[i].original !== part;
      original += (parts[i].separator || "") + part;
      if (!isLiteral && (part === ".." || part === "." || part === "this")) {
        if (dig.length > 0) {
          throw new _exception2["default"]("Invalid path: " + original, {loc});
        } else if (part === "..") {
          depth++;
        }
      } else {
        dig.push(part);
      }
    }
    return {
      type: "PathExpression",
      data,
      depth,
      parts: dig,
      original,
      loc
    };
  }
  function prepareMustache(path, params, hash, open, strip, locInfo) {
    var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
    var decorator = /\*/.test(open);
    return {
      type: decorator ? "Decorator" : "MustacheStatement",
      path,
      params,
      hash,
      escaped,
      strip,
      loc: this.locInfo(locInfo)
    };
  }
  function prepareRawBlock(openRawBlock, contents, close, locInfo) {
    validateClose(openRawBlock, close);
    locInfo = this.locInfo(locInfo);
    var program = {
      type: "Program",
      body: contents,
      strip: {},
      loc: locInfo
    };
    return {
      type: "BlockStatement",
      path: openRawBlock.path,
      params: openRawBlock.params,
      hash: openRawBlock.hash,
      program,
      openStrip: {},
      inverseStrip: {},
      closeStrip: {},
      loc: locInfo
    };
  }
  function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    if (close && close.path) {
      validateClose(openBlock, close);
    }
    var decorator = /\*/.test(openBlock.open);
    program.blockParams = openBlock.blockParams;
    var inverse = void 0, inverseStrip = void 0;
    if (inverseAndProgram) {
      if (decorator) {
        throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
      }
      if (inverseAndProgram.chain) {
        inverseAndProgram.program.body[0].closeStrip = close.strip;
      }
      inverseStrip = inverseAndProgram.strip;
      inverse = inverseAndProgram.program;
    }
    if (inverted) {
      inverted = inverse;
      inverse = program;
      program = inverted;
    }
    return {
      type: decorator ? "DecoratorBlock" : "BlockStatement",
      path: openBlock.path,
      params: openBlock.params,
      hash: openBlock.hash,
      program,
      inverse,
      openStrip: openBlock.strip,
      inverseStrip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }
  function prepareProgram(statements, loc) {
    if (!loc && statements.length) {
      var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
      if (firstLoc && lastLoc) {
        loc = {
          source: firstLoc.source,
          start: {
            line: firstLoc.start.line,
            column: firstLoc.start.column
          },
          end: {
            line: lastLoc.end.line,
            column: lastLoc.end.column
          }
        };
      }
    }
    return {
      type: "Program",
      body: statements,
      strip: {},
      loc
    };
  }
  function preparePartialBlock(open, program, close, locInfo) {
    validateClose(open, close);
    return {
      type: "PartialBlockStatement",
      name: open.path,
      params: open.params,
      hash: open.hash,
      program,
      openStrip: open.strip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.parseWithoutProcessing = parseWithoutProcessing;
  exports2.parse = parse;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _parser = require_parser2();
  var _parser2 = _interopRequireDefault(_parser);
  var _whitespaceControl = require_whitespace_control();
  var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
  var _helpers = require_helpers2();
  var Helpers = _interopRequireWildcard(_helpers);
  var _utils = require_utils4();
  exports2.parser = _parser2["default"];
  var yy = {};
  _utils.extend(yy, Helpers);
  function parseWithoutProcessing(input, options) {
    if (input.type === "Program") {
      return input;
    }
    _parser2["default"].yy = yy;
    yy.locInfo = function(locInfo) {
      return new yy.SourceLocation(options && options.srcName, locInfo);
    };
    var ast = _parser2["default"].parse(input);
    return ast;
  }
  function parse(input, options) {
    var ast = parseWithoutProcessing(input, options);
    var strip = new _whitespaceControl2["default"](options);
    return strip.accept(ast);
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.Compiler = Compiler;
  exports2.precompile = precompile;
  exports2.compile = compile;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _utils = require_utils4();
  var _ast = require_ast();
  var _ast2 = _interopRequireDefault(_ast);
  var slice = [].slice;
  function Compiler() {
  }
  Compiler.prototype = {
    compiler: Compiler,
    equals: function equals(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }
      len = this.children.length;
      for (var i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }
      return true;
    },
    guid: 0,
    compile: function compile2(program, options) {
      this.sourceNode = [];
      this.opcodes = [];
      this.children = [];
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;
      options.blockParams = options.blockParams || [];
      options.knownHelpers = _utils.extend(Object.create(null), {
        helperMissing: true,
        blockHelperMissing: true,
        each: true,
        if: true,
        unless: true,
        with: true,
        log: true,
        lookup: true
      }, options.knownHelpers);
      return this.accept(program);
    },
    compileProgram: function compileProgram(program) {
      var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
      this.usePartial = this.usePartial || result.usePartial;
      this.children[guid] = result;
      this.useDepths = this.useDepths || result.useDepths;
      return guid;
    },
    accept: function accept(node) {
      if (!this[node.type]) {
        throw new _exception2["default"]("Unknown type: " + node.type, node);
      }
      this.sourceNode.unshift(node);
      var ret = this[node.type](node);
      this.sourceNode.shift();
      return ret;
    },
    Program: function Program(program) {
      this.options.blockParams.unshift(program.blockParams);
      var body = program.body, bodyLength = body.length;
      for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
      }
      this.options.blockParams.shift();
      this.isSimple = bodyLength === 1;
      this.blockParams = program.blockParams ? program.blockParams.length : 0;
      return this;
    },
    BlockStatement: function BlockStatement(block) {
      transformLiteralToPath(block);
      var program = block.program, inverse = block.inverse;
      program = program && this.compileProgram(program);
      inverse = inverse && this.compileProgram(inverse);
      var type = this.classifySexpr(block);
      if (type === "helper") {
        this.helperSexpr(block, program, inverse);
      } else if (type === "simple") {
        this.simpleSexpr(block);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("blockValue", block.path.original);
      } else {
        this.ambiguousSexpr(block, program, inverse);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("ambiguousBlockValue");
      }
      this.opcode("append");
    },
    DecoratorBlock: function DecoratorBlock(decorator) {
      var program = decorator.program && this.compileProgram(decorator.program);
      var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
      this.useDecorators = true;
      this.opcode("registerDecorator", params.length, path.original);
    },
    PartialStatement: function PartialStatement(partial) {
      this.usePartial = true;
      var program = partial.program;
      if (program) {
        program = this.compileProgram(partial.program);
      }
      var params = partial.params;
      if (params.length > 1) {
        throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
      } else if (!params.length) {
        if (this.options.explicitPartialContext) {
          this.opcode("pushLiteral", "undefined");
        } else {
          params.push({type: "PathExpression", parts: [], depth: 0});
        }
      }
      var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
      if (isDynamic) {
        this.accept(partial.name);
      }
      this.setupFullMustacheParams(partial, program, void 0, true);
      var indent = partial.indent || "";
      if (this.options.preventIndent && indent) {
        this.opcode("appendContent", indent);
        indent = "";
      }
      this.opcode("invokePartial", isDynamic, partialName, indent);
      this.opcode("append");
    },
    PartialBlockStatement: function PartialBlockStatement(partialBlock) {
      this.PartialStatement(partialBlock);
    },
    MustacheStatement: function MustacheStatement(mustache) {
      this.SubExpression(mustache);
      if (mustache.escaped && !this.options.noEscape) {
        this.opcode("appendEscaped");
      } else {
        this.opcode("append");
      }
    },
    Decorator: function Decorator(decorator) {
      this.DecoratorBlock(decorator);
    },
    ContentStatement: function ContentStatement(content) {
      if (content.value) {
        this.opcode("appendContent", content.value);
      }
    },
    CommentStatement: function CommentStatement() {
    },
    SubExpression: function SubExpression(sexpr) {
      transformLiteralToPath(sexpr);
      var type = this.classifySexpr(sexpr);
      if (type === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },
    ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
      var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
      this.opcode("getContext", path.depth);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      path.strict = true;
      this.accept(path);
      this.opcode("invokeAmbiguous", name, isBlock);
    },
    simpleSexpr: function simpleSexpr(sexpr) {
      var path = sexpr.path;
      path.strict = true;
      this.accept(path);
      this.opcode("resolvePossibleLambda");
    },
    helperSexpr: function helperSexpr(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
      if (this.options.knownHelpers[name]) {
        this.opcode("invokeKnownHelper", params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        path.strict = true;
        path.falsy = true;
        this.accept(path);
        this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
      }
    },
    PathExpression: function PathExpression(path) {
      this.addDepth(path.depth);
      this.opcode("getContext", path.depth);
      var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
      if (blockParamId) {
        this.opcode("lookupBlockParam", blockParamId, path.parts);
      } else if (!name) {
        this.opcode("pushContext");
      } else if (path.data) {
        this.options.data = true;
        this.opcode("lookupData", path.depth, path.parts, path.strict);
      } else {
        this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
      }
    },
    StringLiteral: function StringLiteral(string) {
      this.opcode("pushString", string.value);
    },
    NumberLiteral: function NumberLiteral(number) {
      this.opcode("pushLiteral", number.value);
    },
    BooleanLiteral: function BooleanLiteral(bool) {
      this.opcode("pushLiteral", bool.value);
    },
    UndefinedLiteral: function UndefinedLiteral() {
      this.opcode("pushLiteral", "undefined");
    },
    NullLiteral: function NullLiteral() {
      this.opcode("pushLiteral", "null");
    },
    Hash: function Hash(hash) {
      var pairs = hash.pairs, i = 0, l = pairs.length;
      this.opcode("pushHash");
      for (; i < l; i++) {
        this.pushParam(pairs[i].value);
      }
      while (i--) {
        this.opcode("assignToHash", pairs[i].key);
      }
      this.opcode("popHash");
    },
    opcode: function opcode(name) {
      this.opcodes.push({
        opcode: name,
        args: slice.call(arguments, 1),
        loc: this.sourceNode[0].loc
      });
    },
    addDepth: function addDepth(depth) {
      if (!depth) {
        return;
      }
      this.useDepths = true;
    },
    classifySexpr: function classifySexpr(sexpr) {
      var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
      var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
      var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
      var isEligible = !isBlockParam && (isHelper || isSimple);
      if (isEligible && !isHelper) {
        var _name = sexpr.path.parts[0], options = this.options;
        if (options.knownHelpers[_name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }
      if (isHelper) {
        return "helper";
      } else if (isEligible) {
        return "ambiguous";
      } else {
        return "simple";
      }
    },
    pushParams: function pushParams(params) {
      for (var i = 0, l = params.length; i < l; i++) {
        this.pushParam(params[i]);
      }
    },
    pushParam: function pushParam(val) {
      var value = val.value != null ? val.value : val.original || "";
      if (this.stringParams) {
        if (value.replace) {
          value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
        }
        if (val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode("getContext", val.depth || 0);
        this.opcode("pushStringParam", value, val.type);
        if (val.type === "SubExpression") {
          this.accept(val);
        }
      } else {
        if (this.trackIds) {
          var blockParamIndex = void 0;
          if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
            blockParamIndex = this.blockParamIndex(val.parts[0]);
          }
          if (blockParamIndex) {
            var blockParamChild = val.parts.slice(1).join(".");
            this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
          } else {
            value = val.original || value;
            if (value.replace) {
              value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
            }
            this.opcode("pushId", val.type, value);
          }
        }
        this.accept(val);
      }
    },
    setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
      var params = sexpr.params;
      this.pushParams(params);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      if (sexpr.hash) {
        this.accept(sexpr.hash);
      } else {
        this.opcode("emptyHash", omitEmpty);
      }
      return params;
    },
    blockParamIndex: function blockParamIndex(name) {
      for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
        var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
        if (blockParams && param >= 0) {
          return [depth, param];
        }
      }
    }
  };
  function precompile(input, options, env) {
    if (input == null || typeof input !== "string" && input.type !== "Program") {
      throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
    }
    options = options || {};
    if (!("data" in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }
    var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }
  function compile(input, options, env) {
    if (options === void 0)
      options = {};
    if (input == null || typeof input !== "string" && input.type !== "Program") {
      throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    }
    options = _utils.extend({}, options);
    if (!("data" in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }
    var compiled = void 0;
    function compileInput() {
      var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
      return env.template(templateSpec);
    }
    function ret(context, execOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, execOptions);
    }
    ret._setup = function(setupOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(setupOptions);
    };
    ret._child = function(i, data, blockParams, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, blockParams, depths);
    };
    return ret;
  }
  function argEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
      for (var i = 0; i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }
  function transformLiteralToPath(sexpr) {
    if (!sexpr.path.parts) {
      var literal = sexpr.path;
      sexpr.path = {
        type: "PathExpression",
        data: false,
        depth: 0,
        parts: [literal.original + ""],
        original: literal.original + "",
        loc: literal.loc
      };
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports2) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports2.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports2.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports2) => {
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports2.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map/lib/util.js
var require_util2 = __commonJS((exports2) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports2.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports2.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports2.urlGenerate = urlGenerate;
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports2.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports2.normalize = normalize;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports2.join = join;
  exports2.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports2.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports2.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports2.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports2.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  exports2.computeSourceURL = computeSourceURL;
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports2) => {
  var util = require_util2();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports2.ArraySet = ArraySet;
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports2) => {
  var util = require_util2();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {generatedLine: -1, generatedColumn: 0};
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports2.MappingList = MappingList;
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports2) => {
  var base64VLQ = require_base64_vlq();
  var util = require_util2();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports2.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports2) => {
  exports2.GREATEST_LOWER_BOUND = 1;
  exports2.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports2) => {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  exports2.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports2) => {
  var util = require_util2();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports2.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports2) => {
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util2();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {code: generated.code, map};
  };
  exports2.SourceNode = SourceNode;
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports2) => {
  exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports2.SourceNode = require_source_node().SourceNode;
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  var _utils = require_utils4();
  var SourceNode = void 0;
  try {
    if (typeof define !== "function" || !define.amd) {
      SourceMap = require_source_map();
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {
  }
  var SourceMap;
  if (!SourceNode) {
    SourceNode = function(line, column, srcFile, chunks) {
      this.src = "";
      if (chunks) {
        this.add(chunks);
      }
    };
    SourceNode.prototype = {
      add: function add(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return {code: this.toString()};
      },
      toString: function toString() {
        return this.src;
      }
    };
  }
  function castChunk(chunk, codeGen, loc) {
    if (_utils.isArray(chunk)) {
      var ret = [];
      for (var i = 0, len = chunk.length; i < len; i++) {
        ret.push(codeGen.wrap(chunk[i], loc));
      }
      return ret;
    } else if (typeof chunk === "boolean" || typeof chunk === "number") {
      return chunk + "";
    }
    return chunk;
  }
  function CodeGen(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  }
  CodeGen.prototype = {
    isEmpty: function isEmpty() {
      return !this.source.length;
    },
    prepend: function prepend(source, loc) {
      this.source.unshift(this.wrap(source, loc));
    },
    push: function push(source, loc) {
      this.source.push(this.wrap(source, loc));
    },
    merge: function merge() {
      var source = this.empty();
      this.each(function(line) {
        source.add(["  ", line, "\n"]);
      });
      return source;
    },
    each: function each(iter) {
      for (var i = 0, len = this.source.length; i < len; i++) {
        iter(this.source[i]);
      }
    },
    empty: function empty() {
      var loc = this.currentLocation || {start: {}};
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || {start: {}} : arguments[1];
      if (chunk instanceof SourceNode) {
        return chunk;
      }
      chunk = castChunk(chunk, this, loc);
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },
    functionCall: function functionCall(fn, type, params) {
      params = this.generateList(params);
      return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
    },
    quotedString: function quotedString(str) {
      return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
    },
    objectLiteral: function objectLiteral(obj) {
      var _this = this;
      var pairs = [];
      Object.keys(obj).forEach(function(key) {
        var value = castChunk(obj[key], _this);
        if (value !== "undefined") {
          pairs.push([_this.quotedString(key), ":", value]);
        }
      });
      var ret = this.generateList(pairs);
      ret.prepend("{");
      ret.add("}");
      return ret;
    },
    generateList: function generateList(entries) {
      var ret = this.empty();
      for (var i = 0, len = entries.length; i < len; i++) {
        if (i) {
          ret.add(",");
        }
        ret.add(castChunk(entries[i], this));
      }
      return ret;
    },
    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend("[");
      ret.add("]");
      return ret;
    }
  };
  exports2["default"] = CodeGen;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _base = require_base();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _utils = require_utils4();
  var _codeGen = require_code_gen();
  var _codeGen2 = _interopRequireDefault(_codeGen);
  function Literal(value) {
    this.value = value;
  }
  function JavaScriptCompiler() {
  }
  JavaScriptCompiler.prototype = {
    nameLookup: function nameLookup(parent, name) {
      return this.internalNameLookup(parent, name);
    },
    depthedLookup: function depthedLookup(name) {
      return [this.aliasable("container.lookup"), '(depths, "', name, '")'];
    },
    compilerInfo: function compilerInfo() {
      var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
      return [revision, versions];
    },
    appendToBuffer: function appendToBuffer(source, location, explicit) {
      if (!_utils.isArray(source)) {
        source = [source];
      }
      source = this.source.wrap(source, location);
      if (this.environment.isSimple) {
        return ["return ", source, ";"];
      } else if (explicit) {
        return ["buffer += ", source, ";"];
      } else {
        source.appendToBuffer = true;
        return source;
      }
    },
    initializeBuffer: function initializeBuffer() {
      return this.quotedString("");
    },
    internalNameLookup: function internalNameLookup(parent, name) {
      this.lookupPropertyFunctionIsUsed = true;
      return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
    },
    lookupPropertyFunctionIsUsed: false,
    compile: function compile(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;
      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };
      this.preamble();
      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = {list: []};
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];
      this.compileChildren(environment, options);
      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
      var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];
        this.source.currentLocation = opcode.loc;
        firstLoc = firstLoc || opcode.loc;
        this[opcode.opcode].apply(this, opcode.args);
      }
      this.source.currentLocation = firstLoc;
      this.pushSource("");
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception2["default"]("Compile completed with content left on stack");
      }
      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;
        this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
        this.decorators.push("return fn;");
        if (asObject) {
          this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
        } else {
          this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
          this.decorators.push("}\n");
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = void 0;
      }
      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        if (this.decorators) {
          ret.main_d = this.decorators;
          ret.useDecorators = true;
        }
        var _context = this.context;
        var programs = _context.programs;
        var decorators = _context.decorators;
        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
            if (decorators[i]) {
              ret[i + "_d"] = decorators[i];
              ret.useDecorators = true;
            }
          }
        }
        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }
        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          this.source.currentLocation = {start: {line: 1, column: 0}};
          ret = this.objectLiteral(ret);
          if (options.srcName) {
            ret = ret.toStringWithSourceMap({file: options.destName});
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }
        return ret;
      } else {
        return fn;
      }
    },
    preamble: function preamble() {
      this.lastContext = 0;
      this.source = new _codeGen2["default"](this.options.srcName);
      this.decorators = new _codeGen2["default"](this.options.srcName);
    },
    createFunctionContext: function createFunctionContext(asObject) {
      var _this = this;
      var varDeclarations = "";
      var locals = this.stackVars.concat(this.registers.list);
      if (locals.length > 0) {
        varDeclarations += ", " + locals.join(", ");
      }
      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function(alias) {
        var node = _this.aliases[alias];
        if (node.children && node.referenceCount > 1) {
          varDeclarations += ", alias" + ++aliasCount + "=" + alias;
          node.children[0] = "alias" + aliasCount;
        }
      });
      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
      }
      var params = ["container", "depth0", "helpers", "partials", "data"];
      if (this.useBlockParams || this.useDepths) {
        params.push("blockParams");
      }
      if (this.useDepths) {
        params.push("depths");
      }
      var source = this.mergeSource(varDeclarations);
      if (asObject) {
        params.push(source);
        return Function.apply(this, params);
      } else {
        return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
      this.source.each(function(line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend("  + ");
          } else {
            bufferStart = line;
          }
          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend("buffer += ");
            }
            bufferEnd.add(";");
            bufferStart = bufferEnd = void 0;
          }
          sourceSeen = true;
          if (!isSimple) {
            appendOnly = false;
          }
        }
      });
      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend("return ");
          bufferEnd.add(";");
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
        if (bufferStart) {
          bufferStart.prepend("return buffer + ");
          bufferEnd.add(";");
        } else {
          this.source.push("return buffer;");
        }
      }
      if (varDeclarations) {
        this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
      }
      return this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
    },
    blockValue: function blockValue(name) {
      var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
      this.setupHelperArgs(name, 0, params);
      var blockName = this.popStack();
      params.splice(1, 0, blockName);
      this.push(this.source.functionCall(blockHelperMissing, "call", params));
    },
    ambiguousBlockValue: function ambiguousBlockValue() {
      var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
      this.setupHelperArgs("", 0, params, true);
      this.flushInline();
      var current = this.topStack();
      params.splice(1, 0, current);
      this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
    },
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }
      this.pendingContent = content;
    },
    append: function append() {
      if (this.isInline()) {
        this.replaceStack(function(current) {
          return [" != null ? ", current, ' : ""'];
        });
        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
        if (this.environment.isSimple) {
          this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
        }
      }
    },
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
    },
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;
      if (!scoped && this.options.compat && !this.lastContext) {
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }
      this.resolvePath("context", parts, i, falsy, strict);
    },
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;
      this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
      this.resolvePath("context", parts, 1);
    },
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral("data");
      } else {
        this.pushStackLiteral("container.data(data, " + depth + ")");
      }
      this.resolvePath("data", parts, 0, true, strict);
    },
    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
      var _this2 = this;
      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, type));
        return;
      }
      var len = parts.length;
      for (; i < len; i++) {
        this.replaceStack(function(current) {
          var lookup = _this2.nameLookup(current, parts[i], type);
          if (!falsy) {
            return [" != null ? ", lookup, " : ", current];
          } else {
            return [" && ", lookup];
          }
        });
      }
    },
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
    },
    pushStringParam: function pushStringParam(string, type) {
      this.pushContext();
      this.pushString(type);
      if (type !== "SubExpression") {
        if (typeof string === "string") {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },
    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push("{}");
      }
      if (this.stringParams) {
        this.push("{}");
        this.push("{}");
      }
      this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {values: {}, types: [], contexts: [], ids: []};
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();
      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }
      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }
      this.push(this.objectLiteral(hash.values));
    },
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },
    registerDecorator: function registerDecorator(paramSize, name) {
      var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
      this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
    },
    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
      var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
      var possibleFunctionCalls = [];
      if (isSimple) {
        possibleFunctionCalls.push(helper.name);
      }
      possibleFunctionCalls.push(nonHelper);
      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
      }
      var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
      var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
      this.push(functionCall);
    },
    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);
      for (var i = 1; i < items.length; i++) {
        result.push(separator, items[i]);
      }
      return result;
    },
    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(this.source.functionCall(helper.name, "call", helper.callParams));
    },
    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
      this.useRegister("helper");
      var nonHelper = this.popStack();
      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);
      var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
      var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
      if (!this.options.strict) {
        lookup[0] = "(helper = ";
        lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
      }
      this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
    },
    invokePartial: function invokePartial(isDynamic, name, indent) {
      var params = [], options = this.setupParams(name, 1, params);
      if (isDynamic) {
        name = this.popStack();
        delete options.name;
      }
      if (indent) {
        options.indent = JSON.stringify(indent);
      }
      options.helpers = "helpers";
      options.partials = "partials";
      options.decorators = "container.decorators";
      if (!isDynamic) {
        params.unshift(this.nameLookup("partials", name, "partial"));
      } else {
        params.unshift(name);
      }
      if (this.options.compat) {
        options.depths = "depths";
      }
      options = this.objectLiteral(options);
      params.push(options);
      this.push(this.source.functionCall("container.invokePartial", "", params));
    },
    assignToHash: function assignToHash(key) {
      var value = this.popStack(), context = void 0, type = void 0, id = void 0;
      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }
      var hash = this.hash;
      if (context) {
        hash.contexts[key] = context;
      }
      if (type) {
        hash.types[key] = type;
      }
      if (id) {
        hash.ids[key] = id;
      }
      hash.values[key] = value;
    },
    pushId: function pushId(type, name, child) {
      if (type === "BlockParam") {
        this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
      } else if (type === "PathExpression") {
        this.pushString(name);
      } else if (type === "SubExpression") {
        this.pushStackLiteral("true");
      } else {
        this.pushStackLiteral("null");
      }
    },
    compiler: JavaScriptCompiler,
    compileChildren: function compileChildren(environment, options) {
      var children = environment.children, child = void 0, compiler = void 0;
      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler = new this.compiler();
        var existing = this.matchExistingProgram(child);
        if (existing == null) {
          this.context.programs.push("");
          var index = this.context.programs.length;
          child.index = index;
          child.name = "program" + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index] = compiler.decorators;
          this.context.environments[index] = child;
          this.useDepths = this.useDepths || compiler.useDepths;
          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = "program" + existing.index;
          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },
    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
      if (this.useBlockParams || this.useDepths) {
        programParams.push("blockParams");
      }
      if (this.useDepths) {
        programParams.push("depths");
      }
      return "container.program(" + programParams.join(", ") + ")";
    },
    useRegister: function useRegister(name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },
    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }
      this.inlineStack.push(expr);
      return expr;
    },
    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },
    pushSource: function pushSource(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = void 0;
      }
      if (source) {
        this.source.push(source);
      }
    },
    replaceStack: function replaceStack(callback) {
      var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
      if (!this.isInline()) {
        throw new _exception2["default"]("replaceStack on non-inline");
      }
      var top = this.popStack(true);
      if (top instanceof Literal) {
        stack = [top.value];
        prefix = ["(", stack];
        usedLiteral = true;
      } else {
        createdStack = true;
        var _name = this.incrStack();
        prefix = ["((", this.push(_name), " = ", top, ")"];
        stack = this.topStack();
      }
      var item = callback.call(this, stack);
      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push(prefix.concat(item, ")"));
    },
    incrStack: function incrStack() {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push("stack" + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function topStackName() {
      return "stack" + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, " = ", entry, ";"]);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },
    popStack: function popStack(wrapped) {
      var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          if (!this.stackSlot) {
            throw new _exception2["default"]("Invalid stack pop");
          }
          this.stackSlot--;
        }
        return item;
      }
    },
    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },
    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return "depths[" + context + "]";
      } else {
        return "depth" + context;
      }
    },
    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },
    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },
    aliasable: function aliasable(name) {
      var ret = this.aliases[name];
      if (ret) {
        ret.referenceCount++;
        return ret;
      }
      ret = this.aliases[name] = this.source.wrap(name);
      ret.aliasable = true;
      ret.referenceCount = 1;
      return ret;
    },
    setupHelper: function setupHelper(paramSize, name, blockHelper) {
      var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
      return {
        params,
        paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params)
      };
    },
    setupParams: function setupParams(helper, paramSize, params) {
      var options = {}, contexts = [], types = [], ids = [], objectArgs = !params, param = void 0;
      if (objectArgs) {
        params = [];
      }
      options.name = this.quotedString(helper);
      options.hash = this.popStack();
      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }
      var inverse = this.popStack(), program = this.popStack();
      if (program || inverse) {
        options.fn = program || "container.noop";
        options.inverse = inverse || "container.noop";
      }
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;
        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }
      if (objectArgs) {
        options.args = this.source.generateArray(params);
      }
      if (this.trackIds) {
        options.ids = this.source.generateArray(ids);
      }
      if (this.stringParams) {
        options.types = this.source.generateArray(types);
        options.contexts = this.source.generateArray(contexts);
      }
      if (this.options.data) {
        options.data = "data";
      }
      if (this.useBlockParams) {
        options.blockParams = "blockParams";
      }
      return options;
    },
    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
      var options = this.setupParams(helper, paramSize, params);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);
      if (useRegister) {
        this.useRegister("options");
        params.push("options");
        return ["options=", options];
      } else if (params) {
        params.push(options);
        return "";
      } else {
        return options;
      }
    }
  };
  (function() {
    var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    for (var i = 0, l = reservedWords.length; i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();
  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };
  function strictLookup(requireTerminal, compiler, parts, type) {
    var stack = compiler.popStack(), i = 0, len = parts.length;
    if (requireTerminal) {
      len--;
    }
    for (; i < len; i++) {
      stack = compiler.nameLookup(stack, parts[i], type);
    }
    if (requireTerminal) {
      return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
    } else {
      return stack;
    }
  }
  exports2["default"] = JavaScriptCompiler;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _handlebarsRuntime = require_handlebars_runtime();
  var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
  var _handlebarsCompilerAst = require_ast();
  var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
  var _handlebarsCompilerBase = require_base2();
  var _handlebarsCompilerCompiler = require_compiler();
  var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
  var _handlebarsCompilerVisitor = require_visitor();
  var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
  var _handlebarsNoConflict = require_no_conflict();
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
  var _create = _handlebarsRuntime2["default"].create;
  function create() {
    var hb = _create();
    hb.compile = function(input, options) {
      return _handlebarsCompilerCompiler.compile(input, options, hb);
    };
    hb.precompile = function(input, options) {
      return _handlebarsCompilerCompiler.precompile(input, options, hb);
    };
    hb.AST = _handlebarsCompilerAst2["default"];
    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
    hb.Parser = _handlebarsCompilerBase.parser;
    hb.parse = _handlebarsCompilerBase.parse;
    hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
    return hb;
  }
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2["default"](inst);
  inst.Visitor = _handlebarsCompilerVisitor2["default"];
  inst["default"] = inst;
  exports2["default"] = inst;
  module2.exports = exports2["default"];
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
var require_printer = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.print = print;
  exports2.PrintVisitor = PrintVisitor;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var _visitor = require_visitor();
  var _visitor2 = _interopRequireDefault(_visitor);
  function print(ast) {
    return new PrintVisitor().accept(ast);
  }
  function PrintVisitor() {
    this.padding = 0;
  }
  PrintVisitor.prototype = new _visitor2["default"]();
  PrintVisitor.prototype.pad = function(string) {
    var out = "";
    for (var i = 0, l = this.padding; i < l; i++) {
      out += "  ";
    }
    out += string + "\n";
    return out;
  };
  PrintVisitor.prototype.Program = function(program) {
    var out = "", body = program.body, i = void 0, l = void 0;
    if (program.blockParams) {
      var blockParams = "BLOCK PARAMS: [";
      for (i = 0, l = program.blockParams.length; i < l; i++) {
        blockParams += " " + program.blockParams[i];
      }
      blockParams += " ]";
      out += this.pad(blockParams);
    }
    for (i = 0, l = body.length; i < l; i++) {
      out += this.accept(body[i]);
    }
    this.padding--;
    return out;
  };
  PrintVisitor.prototype.MustacheStatement = function(mustache) {
    return this.pad("{{ " + this.SubExpression(mustache) + " }}");
  };
  PrintVisitor.prototype.Decorator = function(mustache) {
    return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
  };
  PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block) {
    var out = "";
    out += this.pad((block.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
    this.padding++;
    out += this.pad(this.SubExpression(block));
    if (block.program) {
      out += this.pad("PROGRAM:");
      this.padding++;
      out += this.accept(block.program);
      this.padding--;
    }
    if (block.inverse) {
      if (block.program) {
        this.padding++;
      }
      out += this.pad("{{^}}");
      this.padding++;
      out += this.accept(block.inverse);
      this.padding--;
      if (block.program) {
        this.padding--;
      }
    }
    this.padding--;
    return out;
  };
  PrintVisitor.prototype.PartialStatement = function(partial) {
    var content = "PARTIAL:" + partial.name.original;
    if (partial.params[0]) {
      content += " " + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += " " + this.accept(partial.hash);
    }
    return this.pad("{{> " + content + " }}");
  };
  PrintVisitor.prototype.PartialBlockStatement = function(partial) {
    var content = "PARTIAL BLOCK:" + partial.name.original;
    if (partial.params[0]) {
      content += " " + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += " " + this.accept(partial.hash);
    }
    content += " " + this.pad("PROGRAM:");
    this.padding++;
    content += this.accept(partial.program);
    this.padding--;
    return this.pad("{{> " + content + " }}");
  };
  PrintVisitor.prototype.ContentStatement = function(content) {
    return this.pad("CONTENT[ '" + content.value + "' ]");
  };
  PrintVisitor.prototype.CommentStatement = function(comment) {
    return this.pad("{{! '" + comment.value + "' }}");
  };
  PrintVisitor.prototype.SubExpression = function(sexpr) {
    var params = sexpr.params, paramStrings = [], hash = void 0;
    for (var i = 0, l = params.length; i < l; i++) {
      paramStrings.push(this.accept(params[i]));
    }
    params = "[" + paramStrings.join(", ") + "]";
    hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
    return this.accept(sexpr.path) + " " + params + hash;
  };
  PrintVisitor.prototype.PathExpression = function(id) {
    var path = id.parts.join("/");
    return (id.data ? "@" : "") + "PATH:" + path;
  };
  PrintVisitor.prototype.StringLiteral = function(string) {
    return '"' + string.value + '"';
  };
  PrintVisitor.prototype.NumberLiteral = function(number) {
    return "NUMBER{" + number.value + "}";
  };
  PrintVisitor.prototype.BooleanLiteral = function(bool) {
    return "BOOLEAN{" + bool.value + "}";
  };
  PrintVisitor.prototype.UndefinedLiteral = function() {
    return "UNDEFINED";
  };
  PrintVisitor.prototype.NullLiteral = function() {
    return "NULL";
  };
  PrintVisitor.prototype.Hash = function(hash) {
    var pairs = hash.pairs, joinedPairs = [];
    for (var i = 0, l = pairs.length; i < l; i++) {
      joinedPairs.push(this.accept(pairs[i]));
    }
    return "HASH{" + joinedPairs.join(", ") + "}";
  };
  PrintVisitor.prototype.HashPair = function(pair) {
    return pair.key + "=" + this.accept(pair.value);
  };
});

// node_modules/handlebars/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  var handlebars = require_handlebars()["default"];
  var printer = require_printer();
  handlebars.PrintVisitor = printer.PrintVisitor;
  handlebars.print = printer.print;
  module2.exports = handlebars;
  function extension(module3, filename) {
    var fs = require("fs");
    var templateString = fs.readFileSync(filename, "utf8");
    module3.exports = handlebars.compile(templateString);
  }
  if (require.extensions) {
    require.extensions[".handlebars"] = extension;
    require.extensions[".hbs"] = extension;
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = stringify;
  exports2.getSerialize = serializer;
  function stringify(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  }
  function serializer(replacer, cycleReplacer) {
    var stack = [], keys = [];
    if (cycleReplacer == null)
      cycleReplacer = function(key, value) {
        if (stack[0] === value)
          return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value))
          value = cycleReplacer.call(this, key, value);
      } else
        stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
});

// node_modules/conventional-changelog-writer/lib/util.js
var require_util3 = __commonJS((exports2, module2) => {
  "use strict";
  var compareFunc = require_compare_func();
  var conventionalCommitsFilter = require_conventional_commits_filter();
  var Handlebars = require_lib();
  var semver = require_semver();
  var _ = require_lodash();
  var stringify = require_stringify2();
  function compileTemplates(templates) {
    const main = templates.mainTemplate;
    const headerPartial = templates.headerPartial;
    const commitPartial = templates.commitPartial;
    const footerPartial = templates.footerPartial;
    const partials = templates.partials;
    if (_.isString(headerPartial)) {
      Handlebars.registerPartial("header", headerPartial);
    }
    if (_.isString(commitPartial)) {
      Handlebars.registerPartial("commit", commitPartial);
    }
    if (_.isString(footerPartial)) {
      Handlebars.registerPartial("footer", footerPartial);
    }
    _.forEach(partials, function(partial, name) {
      if (_.isString(partial)) {
        Handlebars.registerPartial(name, partial);
      }
    });
    return Handlebars.compile(main, {
      noEscape: true
    });
  }
  function functionify(strOrArr) {
    if (strOrArr && !_.isFunction(strOrArr)) {
      return compareFunc(strOrArr);
    }
    return strOrArr;
  }
  function getCommitGroups(groupBy, commits, groupsSort, commitsSort) {
    const commitGroups = [];
    const commitGroupsObj = _.groupBy(commits, function(commit) {
      return commit[groupBy] || "";
    });
    _.forEach(commitGroupsObj, function(commits2, title) {
      if (title === "") {
        title = false;
      }
      if (commitsSort) {
        commits2.sort(commitsSort);
      }
      commitGroups.push({
        title,
        commits: commits2
      });
    });
    if (groupsSort) {
      commitGroups.sort(groupsSort);
    }
    return commitGroups;
  }
  function getNoteGroups(notes, noteGroupsSort, notesSort) {
    const retGroups = [];
    _.forEach(notes, function(note) {
      const title = note.title;
      let titleExists = false;
      _.forEach(retGroups, function(group) {
        if (group.title === title) {
          titleExists = true;
          group.notes.push(note);
          return false;
        }
      });
      if (!titleExists) {
        retGroups.push({
          title,
          notes: [note]
        });
      }
    });
    if (noteGroupsSort) {
      retGroups.sort(noteGroupsSort);
    }
    if (notesSort) {
      _.forEach(retGroups, function(group) {
        group.notes.sort(notesSort);
      });
    }
    return retGroups;
  }
  function processCommit(chunk, transform, context) {
    let commit;
    try {
      chunk = JSON.parse(chunk);
    } catch (e) {
    }
    commit = _.cloneDeep(chunk);
    if (_.isFunction(transform)) {
      commit = transform(commit, context);
      if (commit) {
        commit.raw = chunk;
      }
      return commit;
    }
    _.forEach(transform, function(el, path) {
      let value = _.get(commit, path);
      if (_.isFunction(el)) {
        value = el(value, path);
      } else {
        value = el;
      }
      _.set(commit, path, value);
    });
    commit.raw = chunk;
    return commit;
  }
  function getExtraContext(commits, notes, options) {
    const context = {};
    context.commitGroups = getCommitGroups(options.groupBy, commits, options.commitGroupsSort, options.commitsSort);
    context.noteGroups = getNoteGroups(notes, options.noteGroupsSort, options.notesSort);
    return context;
  }
  function generate(options, commits, context, keyCommit) {
    let notes = [];
    let filteredCommits;
    const compiled = compileTemplates(options);
    if (options.ignoreReverted) {
      filteredCommits = conventionalCommitsFilter(commits);
    } else {
      filteredCommits = _.clone(commits);
    }
    _.forEach(filteredCommits, function(commit) {
      _.map(commit.notes, function(note) {
        note.commit = commit;
        return note;
      });
      notes = notes.concat(commit.notes);
    });
    context = _.merge({}, context, keyCommit, getExtraContext(filteredCommits, notes, options));
    if (keyCommit && keyCommit.committerDate) {
      context.date = keyCommit.committerDate;
    }
    if (context.version && semver.valid(context.version)) {
      context.isPatch = context.isPatch || semver.patch(context.version) !== 0;
    }
    context = options.finalizeContext(context, options, filteredCommits, keyCommit, commits);
    options.debug("Your final context is:\n" + stringify(context, null, 2));
    return compiled(context);
  }
  module2.exports = {
    compileTemplates,
    functionify,
    getCommitGroups,
    getNoteGroups,
    processCommit,
    getExtraContext,
    generate
  };
});

// node_modules/conventional-changelog-writer/index.js
var require_conventional_changelog_writer = __commonJS((exports2, module2) => {
  "use strict";
  var dateFormat = require_dateformat();
  var join = require("path").join;
  var readFileSync = require("fs").readFileSync;
  var semverValid = require_semver().valid;
  var through = require_through2();
  var util = require_util3();
  var _ = require_lodash();
  function conventionalChangelogWriterInit(context, options) {
    context = _.extend({
      commit: "commits",
      issue: "issues",
      date: dateFormat(new Date(), "yyyy-mm-dd", true)
    }, context);
    if (!_.isBoolean(context.linkReferences) && (context.repository || context.repoUrl) && context.commit && context.issue) {
      context.linkReferences = true;
    }
    options = _.assign({
      groupBy: "type",
      commitsSort: "header",
      noteGroupsSort: "title",
      notesSort: "text",
      generateOn: function(commit) {
        return semverValid(commit.version);
      },
      finalizeContext: function(context2) {
        return context2;
      },
      debug: function() {
      },
      reverse: false,
      includeDetails: false,
      ignoreReverted: true,
      doFlush: true,
      mainTemplate: readFileSync(join(__dirname, "templates/template.hbs"), "utf-8"),
      headerPartial: readFileSync(join(__dirname, "templates/header.hbs"), "utf-8"),
      commitPartial: readFileSync(join(__dirname, "templates/commit.hbs"), "utf-8"),
      footerPartial: readFileSync(join(__dirname, "templates/footer.hbs"), "utf-8")
    }, options);
    if (!_.isFunction(options.transform) && _.isObject(options.transform) || _.isUndefined(options.transform)) {
      options.transform = _.assign({
        hash: function(hash) {
          if (_.isString(hash)) {
            return hash.substring(0, 7);
          }
        },
        header: function(header) {
          return header.substring(0, 100);
        },
        committerDate: function(date) {
          if (!date) {
            return;
          }
          return dateFormat(date, "yyyy-mm-dd", true);
        }
      }, options.transform);
    }
    let generateOn = options.generateOn;
    if (_.isString(generateOn)) {
      generateOn = function(commit) {
        return !_.isUndefined(commit[options.generateOn]);
      };
    } else if (!_.isFunction(generateOn)) {
      generateOn = function() {
        return false;
      };
    }
    options.commitGroupsSort = util.functionify(options.commitGroupsSort);
    options.commitsSort = util.functionify(options.commitsSort);
    options.noteGroupsSort = util.functionify(options.noteGroupsSort);
    options.notesSort = util.functionify(options.notesSort);
    return {context, options, generateOn};
  }
  function conventionalChangelogWriterParseStream(context, options) {
    let generateOn;
    ({context, options, generateOn} = conventionalChangelogWriterInit(context, options));
    let commits = [];
    let neverGenerated = true;
    let savedKeyCommit;
    let firstRelease = true;
    return through.obj(function(chunk, _enc, cb) {
      try {
        let result;
        const commit = util.processCommit(chunk, options.transform, context);
        const keyCommit = commit || chunk;
        if (options.reverse) {
          if (commit) {
            commits.push(commit);
          }
          if (generateOn(keyCommit, commits, context, options)) {
            neverGenerated = false;
            result = util.generate(options, commits, context, keyCommit);
            if (options.includeDetails) {
              this.push({
                log: result,
                keyCommit
              });
            } else {
              this.push(result);
            }
            commits = [];
          }
        } else {
          if (generateOn(keyCommit, commits, context, options)) {
            neverGenerated = false;
            result = util.generate(options, commits, context, savedKeyCommit);
            if (!firstRelease || options.doFlush) {
              if (options.includeDetails) {
                this.push({
                  log: result,
                  keyCommit: savedKeyCommit
                });
              } else {
                this.push(result);
              }
            }
            firstRelease = false;
            commits = [];
            savedKeyCommit = keyCommit;
          }
          if (commit) {
            commits.push(commit);
          }
        }
        cb();
      } catch (err) {
        cb(err);
      }
    }, function(cb) {
      if (!options.doFlush && (options.reverse || neverGenerated)) {
        cb(null);
        return;
      }
      try {
        const result = util.generate(options, commits, context, savedKeyCommit);
        if (options.includeDetails) {
          this.push({
            log: result,
            keyCommit: savedKeyCommit
          });
        } else {
          this.push(result);
        }
        cb();
      } catch (err) {
        cb(err);
      }
    });
  }
  conventionalChangelogWriterParseStream.parseArray = (rawCommits, context, options) => {
    let generateOn;
    rawCommits = [...rawCommits];
    ({context, options, generateOn} = conventionalChangelogWriterInit(context, options));
    let commits = [];
    let savedKeyCommit;
    if (options.reverse) {
      rawCommits.reverse();
    }
    const entries = [];
    for (const rawCommit of rawCommits) {
      const commit = util.processCommit(rawCommit, options.transform, context);
      const keyCommit = commit || rawCommit;
      if (generateOn(keyCommit, commits, context, options)) {
        entries.push(util.generate(options, commits, context, savedKeyCommit));
        savedKeyCommit = keyCommit;
        commits = [];
      }
      if (commit) {
        commits.push(commit);
      }
    }
    if (options.reverse) {
      entries.reverse();
      return util.generate(options, commits, context, savedKeyCommit) + entries.join("");
    } else {
      return entries.join("") + util.generate(options, commits, context, savedKeyCommit);
    }
  };
  module2.exports = conventionalChangelogWriterParseStream;
});

// node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = require_p_try();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run2 = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run2(fn, resolve, ...args);
      } else {
        queue.push(run2.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
  module2.exports.default = pLocate;
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var fs = require("fs");
  var {promisify} = require("util");
  var pLocate = require_p_locate();
  var fsStat = promisify(fs.stat);
  var fsLStat = promisify(fs.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch (_) {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch (_) {
      }
    }
  };
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var {promisify} = require("util");
  var pAccess = promisify(fs.access);
  module2.exports = async (path) => {
    try {
      await pAccess(path);
      return true;
    } catch (_) {
      return false;
    }
  };
  module2.exports.sync = (path) => {
    try {
      fs.accessSync(path);
      return true;
    } catch (_) {
      return false;
    }
  };
});

// node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var locatePath = require_locate_path();
  var pathExists = require_path_exists();
  var stop = Symbol("findUp.stop");
  module2.exports = async (name, options = {}) => {
    let directory = path.resolve(options.cwd || "");
    const {root} = path.parse(directory);
    const paths = [].concat(name);
    const runMatcher = async (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path.dirname(directory);
    }
  };
  module2.exports.sync = (name, options = {}) => {
    let directory = path.resolve(options.cwd || "");
    const {root} = path.parse(directory);
    const paths = [].concat(name);
    const runMatcher = (locateOptions) => {
      if (typeof name !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop) {
        return;
      }
      if (foundPath) {
        return path.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop;
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isArrayish(obj) {
    if (!obj) {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
  };
});

// node_modules/error-ex/index.js
var require_error_ex = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var isArrayish = require_is_arrayish();
  var errorEx = function errorEx2(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }
      message = message instanceof Error ? message.message : message || this.message;
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, "message", {
        configurable: true,
        enumerable: false,
        get: function() {
          var newMessage = message.split(/\r?\n/g);
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("message" in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;
              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }
          return newMessage.join("\n");
        },
        set: function(v) {
          message = v;
        }
      });
      var overwrittenStack = null;
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;
      stackDescriptor.set = function(newstack) {
        overwrittenStack = newstack;
      };
      stackDescriptor.get = function() {
        var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
        if (!overwrittenStack) {
          stack[0] = this.name + ": " + this.message;
        }
        var lineCount = 1;
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ("line" in modifier) {
            var line = modifier.line(this[key]);
            if (line) {
              stack.splice(lineCount++, 0, "    " + line);
            }
          }
          if ("stack" in modifier) {
            modifier.stack(this[key], stack);
          }
        }
        return stack.join("\n");
      };
      Object.defineProperty(this, "stack", stackDescriptor);
    };
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util.inherits(errorExError, Error);
    }
    return errorExError;
  };
  errorEx.append = function(str, def) {
    return {
      message: function(v, message) {
        v = v || def;
        if (v) {
          message[0] += " " + str.replace("%s", v.toString());
        }
        return message;
      }
    };
  };
  errorEx.line = function(str, def) {
    return {
      line: function(v) {
        v = v || def;
        if (v) {
          return str.replace("%s", v.toString());
        }
        return null;
      }
    };
  };
  module2.exports = errorEx;
});

// node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS((exports2, module2) => {
  "use strict";
  var hexify = (char) => {
    const h = char.charCodeAt(0).toString(16).toUpperCase();
    return "0x" + (h.length % 2 ? "0" : "") + h;
  };
  var parseError = (e, txt, context) => {
    if (!txt) {
      return {
        message: e.message + " while parsing empty string",
        position: 0
      };
    }
    const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
    const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
    const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
    if (errIdx !== null && errIdx !== void 0) {
      const start = errIdx <= context ? 0 : errIdx - context;
      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
      const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
      const near = txt === slice ? "" : "near ";
      return {
        message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
        position: errIdx
      };
    } else {
      return {
        message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
        position: 0
      };
    }
  };
  var JSONParseError = class extends SyntaxError {
    constructor(er, txt, context, caller) {
      context = context || 20;
      const metadata = parseError(er, txt, context);
      super(metadata.message);
      Object.assign(this, metadata);
      this.code = "EJSONPARSE";
      this.systemError = er;
      Error.captureStackTrace(this, caller || this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
    set name(n) {
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
  var kIndent = Symbol.for("indent");
  var kNewline = Symbol.for("newline");
  var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
  var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
  var parseJson = (txt, reviver, context) => {
    const parseText = stripBOM(txt);
    context = context || 20;
    try {
      const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
      const result = JSON.parse(parseText, reviver);
      if (result && typeof result === "object") {
        result[kNewline] = newline;
        result[kIndent] = indent;
      }
      return result;
    } catch (e) {
      if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
        const isEmptyArray = Array.isArray(txt) && txt.length === 0;
        throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
          code: "EJSONPARSE",
          systemError: e
        });
      }
      throw new JSONParseError(e, parseText, context, parseJson);
    }
  };
  var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
  module2.exports = parseJson;
  parseJson.JSONParseError = JSONParseError;
  parseJson.noExceptions = (txt, reviver) => {
    try {
      return JSON.parse(stripBOM(txt), reviver);
    } catch (e) {
    }
  };
});

// node_modules/lines-and-columns/dist/index.js
var require_dist = __commonJS((exports2) => {
  "use strict";
  var LF = "\n";
  var CR = "\r";
  var LinesAndColumns = function() {
    function LinesAndColumns2(string) {
      this.string = string;
      var offsets = [0];
      for (var offset = 0; offset < string.length; ) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;
          case CR:
            offset += CR.length;
            if (string[offset] === LF) {
              offset += LF.length;
            }
            offsets.push(offset);
            break;
          default:
            offset++;
            break;
        }
      }
      this.offsets = offsets;
    }
    LinesAndColumns2.prototype.locationForIndex = function(index) {
      if (index < 0 || index > this.string.length) {
        return null;
      }
      var line = 0;
      var offsets = this.offsets;
      while (offsets[line + 1] <= index) {
        line++;
      }
      var column = index - offsets[line];
      return {line, column};
    };
    LinesAndColumns2.prototype.indexForLocation = function(location) {
      var line = location.line, column = location.column;
      if (line < 0 || line >= this.offsets.length) {
        return null;
      }
      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }
      return this.offsets[line] + column;
    };
    LinesAndColumns2.prototype.lengthOfLine = function(line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
      return nextOffset - offset;
    };
    return LinesAndColumns2;
  }();
  exports2.__esModule = true;
  exports2["default"] = LinesAndColumns;
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  exports2.matchToToken = function(match) {
    var token = {type: "invalid", value: match[0], closed: void 0};
    if (match[1])
      token.type = "string", token.closed = !!(match[3] || match[4]);
    else if (match[5])
      token.type = "comment";
    else if (match[6])
      token.type = "comment", token.closed = !!match[7];
    else if (match[8])
      token.type = "regex";
    else if (match[9])
      token.type = "number";
    else if (match[10])
      token.type = "name";
    else if (match[11])
      token.type = "punctuator";
    else if (match[12])
      token.type = "whitespace";
    return token;
  };
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isIdentifierStart = isIdentifierStart;
  exports2.isIdentifierChar = isIdentifierChar;
  exports2.isIdentifierName = isIdentifierName;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    let isFirst = true;
    for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
      const char = _Array$from[_i];
      const cp = char.codePointAt(0);
      if (isFirst) {
        if (!isIdentifierStart(cp)) {
          return false;
        }
        isFirst = false;
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isReservedWord = isReservedWord;
  exports2.isStrictReservedWord = isStrictReservedWord;
  exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports2.isStrictBindReservedWord = isStrictBindReservedWord;
  exports2.isKeyword = isKeyword;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports2, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports2, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports2, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports2, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  Object.defineProperty(exports2, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module2.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var convert = module2.exports = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
  }
  var channels;
  var labels;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module2.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  "use strict";
  var colorConvert = require_color_convert();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/chalk/templates.js
var require_templates = __commonJS((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  }
  module2.exports = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// node_modules/chalk/index.js
var require_chalk = __commonJS((exports2, module2) => {
  "use strict";
  var escapeStringRegexp = require_escape_string_regexp();
  var ansiStyles = require_ansi_styles();
  var stdoutColor = require_supports_color().stdout;
  var template = require_templates();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
});

// node_modules/@babel/highlight/lib/index.js
var require_lib3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.shouldHighlight = shouldHighlight;
  exports2.getChalk = getChalk;
  exports2.default = highlight;
  var _jsTokens = _interopRequireWildcard(require_js_tokens());
  var _helperValidatorIdentifier = require_lib2();
  var _chalk = _interopRequireDefault(require_chalk());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function getDefs(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsx_tag: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var JSX_TAG = /^[a-z][\w-]*$/i;
  var BRACKET = /^[()[\]{}]$/;
  function getTokenType(match) {
    const [offset, text] = match.slice(-2);
    const token = (0, _jsTokens.matchToToken)(match);
    if (token.type === "name") {
      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isReservedWord)(token.value)) {
        return "keyword";
      }
      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
        return "jsx_tag";
      }
      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }
    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }
    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }
    return token.type;
  }
  function highlightTokens(defs, text) {
    return text.replace(_jsTokens.default, function(...args) {
      const type = getTokenType(args);
      const colorize = defs[type];
      if (colorize) {
        return args[0].split(NEWLINE).map((str) => colorize(str)).join("\n");
      } else {
        return args[0];
      }
    });
  }
  function shouldHighlight(options) {
    return _chalk.default.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    let chalk = _chalk.default;
    if (options.forceColor) {
      chalk = new _chalk.default.constructor({
        enabled: true,
        level: 1
      });
    }
    return chalk;
  }
  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk = getChalk(options);
      const defs = getDefs(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.codeFrameColumns = codeFrameColumns;
  exports2.default = _default;
  var _highlight = _interopRequireWildcard(require_lib3());
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var deprecationWarningShown = false;
  function getDefs(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start,
      end,
      markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk = (0, _highlight.getChalk)(opts);
    const defs = getDefs(chalk);
    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };
    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} | `;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }
        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line}`;
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
    }
    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }
  function _default(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
});

// node_modules/parse-json/index.js
var require_parse_json = __commonJS((exports2, module2) => {
  "use strict";
  var errorEx = require_error_ex();
  var fallback = require_json_parse_even_better_errors();
  var {default: LinesAndColumns} = require_dist();
  var {codeFrameColumns} = require_lib4();
  var JSONError = errorEx("JSONError", {
    fileName: errorEx.append("in %s"),
    codeFrame: errorEx.append("\n\n%s\n")
  });
  var parseJson = (string, reviver, filename) => {
    if (typeof reviver === "string") {
      filename = reviver;
      reviver = null;
    }
    try {
      try {
        return JSON.parse(string, reviver);
      } catch (error) {
        fallback(string, reviver);
        throw error;
      }
    } catch (error) {
      error.message = error.message.replace(/\n/g, "");
      const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
      const jsonError = new JSONError(error);
      if (filename) {
        jsonError.fileName = filename;
      }
      if (indexMatch && indexMatch.length > 0) {
        const lines = new LinesAndColumns(string);
        const index = Number(indexMatch[1]);
        const location = lines.locationForIndex(index);
        const codeFrame = codeFrameColumns(string, {start: {line: location.line + 1, column: location.column + 1}}, {highlightCode: true});
        jsonError.codeFrame = codeFrame;
      }
      throw jsonError;
    }
  };
  parseJson.JSONError = JSONError;
  module2.exports = parseJson;
});

// node_modules/read-pkg/node_modules/semver/semver.js
var require_semver2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS((exports2, module2) => {
  module2.exports = [
    "0BSD",
    "AAL",
    "ADSL",
    "AFL-1.1",
    "AFL-1.2",
    "AFL-2.0",
    "AFL-2.1",
    "AFL-3.0",
    "AGPL-1.0-only",
    "AGPL-1.0-or-later",
    "AGPL-3.0-only",
    "AGPL-3.0-or-later",
    "AMDPLPA",
    "AML",
    "AMPAS",
    "ANTLR-PD",
    "ANTLR-PD-fallback",
    "APAFML",
    "APL-1.0",
    "APSL-1.0",
    "APSL-1.1",
    "APSL-1.2",
    "APSL-2.0",
    "Abstyles",
    "Adobe-2006",
    "Adobe-Glyph",
    "Afmparse",
    "Aladdin",
    "Apache-1.0",
    "Apache-1.1",
    "Apache-2.0",
    "Artistic-1.0",
    "Artistic-1.0-Perl",
    "Artistic-1.0-cl8",
    "Artistic-2.0",
    "BSD-1-Clause",
    "BSD-2-Clause",
    "BSD-2-Clause-Patent",
    "BSD-2-Clause-Views",
    "BSD-3-Clause",
    "BSD-3-Clause-Attribution",
    "BSD-3-Clause-Clear",
    "BSD-3-Clause-LBNL",
    "BSD-3-Clause-No-Nuclear-License",
    "BSD-3-Clause-No-Nuclear-License-2014",
    "BSD-3-Clause-No-Nuclear-Warranty",
    "BSD-3-Clause-Open-MPI",
    "BSD-4-Clause",
    "BSD-4-Clause-UC",
    "BSD-Protection",
    "BSD-Source-Code",
    "BSL-1.0",
    "BUSL-1.1",
    "Bahyph",
    "Barr",
    "Beerware",
    "BitTorrent-1.0",
    "BitTorrent-1.1",
    "BlueOak-1.0.0",
    "Borceux",
    "CAL-1.0",
    "CAL-1.0-Combined-Work-Exception",
    "CATOSL-1.1",
    "CC-BY-1.0",
    "CC-BY-2.0",
    "CC-BY-2.5",
    "CC-BY-3.0",
    "CC-BY-3.0-AT",
    "CC-BY-3.0-US",
    "CC-BY-4.0",
    "CC-BY-NC-1.0",
    "CC-BY-NC-2.0",
    "CC-BY-NC-2.5",
    "CC-BY-NC-3.0",
    "CC-BY-NC-4.0",
    "CC-BY-NC-ND-1.0",
    "CC-BY-NC-ND-2.0",
    "CC-BY-NC-ND-2.5",
    "CC-BY-NC-ND-3.0",
    "CC-BY-NC-ND-3.0-IGO",
    "CC-BY-NC-ND-4.0",
    "CC-BY-NC-SA-1.0",
    "CC-BY-NC-SA-2.0",
    "CC-BY-NC-SA-2.5",
    "CC-BY-NC-SA-3.0",
    "CC-BY-NC-SA-4.0",
    "CC-BY-ND-1.0",
    "CC-BY-ND-2.0",
    "CC-BY-ND-2.5",
    "CC-BY-ND-3.0",
    "CC-BY-ND-4.0",
    "CC-BY-SA-1.0",
    "CC-BY-SA-2.0",
    "CC-BY-SA-2.0-UK",
    "CC-BY-SA-2.5",
    "CC-BY-SA-3.0",
    "CC-BY-SA-3.0-AT",
    "CC-BY-SA-4.0",
    "CC-PDDC",
    "CC0-1.0",
    "CDDL-1.0",
    "CDDL-1.1",
    "CDLA-Permissive-1.0",
    "CDLA-Sharing-1.0",
    "CECILL-1.0",
    "CECILL-1.1",
    "CECILL-2.0",
    "CECILL-2.1",
    "CECILL-B",
    "CECILL-C",
    "CERN-OHL-1.1",
    "CERN-OHL-1.2",
    "CERN-OHL-P-2.0",
    "CERN-OHL-S-2.0",
    "CERN-OHL-W-2.0",
    "CNRI-Jython",
    "CNRI-Python",
    "CNRI-Python-GPL-Compatible",
    "CPAL-1.0",
    "CPL-1.0",
    "CPOL-1.02",
    "CUA-OPL-1.0",
    "Caldera",
    "ClArtistic",
    "Condor-1.1",
    "Crossword",
    "CrystalStacker",
    "Cube",
    "D-FSL-1.0",
    "DOC",
    "DSDP",
    "Dotseqn",
    "ECL-1.0",
    "ECL-2.0",
    "EFL-1.0",
    "EFL-2.0",
    "EPICS",
    "EPL-1.0",
    "EPL-2.0",
    "EUDatagrid",
    "EUPL-1.0",
    "EUPL-1.1",
    "EUPL-1.2",
    "Entessa",
    "ErlPL-1.1",
    "Eurosym",
    "FSFAP",
    "FSFUL",
    "FSFULLR",
    "FTL",
    "Fair",
    "Frameworx-1.0",
    "FreeImage",
    "GFDL-1.1-invariants-only",
    "GFDL-1.1-invariants-or-later",
    "GFDL-1.1-no-invariants-only",
    "GFDL-1.1-no-invariants-or-later",
    "GFDL-1.1-only",
    "GFDL-1.1-or-later",
    "GFDL-1.2-invariants-only",
    "GFDL-1.2-invariants-or-later",
    "GFDL-1.2-no-invariants-only",
    "GFDL-1.2-no-invariants-or-later",
    "GFDL-1.2-only",
    "GFDL-1.2-or-later",
    "GFDL-1.3-invariants-only",
    "GFDL-1.3-invariants-or-later",
    "GFDL-1.3-no-invariants-only",
    "GFDL-1.3-no-invariants-or-later",
    "GFDL-1.3-only",
    "GFDL-1.3-or-later",
    "GL2PS",
    "GLWTPL",
    "GPL-1.0-only",
    "GPL-1.0-or-later",
    "GPL-2.0-only",
    "GPL-2.0-or-later",
    "GPL-3.0-only",
    "GPL-3.0-or-later",
    "Giftware",
    "Glide",
    "Glulxe",
    "HPND",
    "HPND-sell-variant",
    "HTMLTIDY",
    "HaskellReport",
    "Hippocratic-2.1",
    "IBM-pibs",
    "ICU",
    "IJG",
    "IPA",
    "IPL-1.0",
    "ISC",
    "ImageMagick",
    "Imlib2",
    "Info-ZIP",
    "Intel",
    "Intel-ACPI",
    "Interbase-1.0",
    "JPNIC",
    "JSON",
    "JasPer-2.0",
    "LAL-1.2",
    "LAL-1.3",
    "LGPL-2.0-only",
    "LGPL-2.0-or-later",
    "LGPL-2.1-only",
    "LGPL-2.1-or-later",
    "LGPL-3.0-only",
    "LGPL-3.0-or-later",
    "LGPLLR",
    "LPL-1.0",
    "LPL-1.02",
    "LPPL-1.0",
    "LPPL-1.1",
    "LPPL-1.2",
    "LPPL-1.3a",
    "LPPL-1.3c",
    "Latex2e",
    "Leptonica",
    "LiLiQ-P-1.1",
    "LiLiQ-R-1.1",
    "LiLiQ-Rplus-1.1",
    "Libpng",
    "Linux-OpenIB",
    "MIT",
    "MIT-0",
    "MIT-CMU",
    "MIT-advertising",
    "MIT-enna",
    "MIT-feh",
    "MIT-open-group",
    "MITNFA",
    "MPL-1.0",
    "MPL-1.1",
    "MPL-2.0",
    "MPL-2.0-no-copyleft-exception",
    "MS-PL",
    "MS-RL",
    "MTLL",
    "MakeIndex",
    "MirOS",
    "Motosoto",
    "MulanPSL-1.0",
    "MulanPSL-2.0",
    "Multics",
    "Mup",
    "NASA-1.3",
    "NBPL-1.0",
    "NCGL-UK-2.0",
    "NCSA",
    "NGPL",
    "NIST-PD",
    "NIST-PD-fallback",
    "NLOD-1.0",
    "NLPL",
    "NOSL",
    "NPL-1.0",
    "NPL-1.1",
    "NPOSL-3.0",
    "NRL",
    "NTP",
    "NTP-0",
    "Naumen",
    "Net-SNMP",
    "NetCDF",
    "Newsletr",
    "Nokia",
    "Noweb",
    "O-UDA-1.0",
    "OCCT-PL",
    "OCLC-2.0",
    "ODC-By-1.0",
    "ODbL-1.0",
    "OFL-1.0",
    "OFL-1.0-RFN",
    "OFL-1.0-no-RFN",
    "OFL-1.1",
    "OFL-1.1-RFN",
    "OFL-1.1-no-RFN",
    "OGC-1.0",
    "OGL-Canada-2.0",
    "OGL-UK-1.0",
    "OGL-UK-2.0",
    "OGL-UK-3.0",
    "OGTSL",
    "OLDAP-1.1",
    "OLDAP-1.2",
    "OLDAP-1.3",
    "OLDAP-1.4",
    "OLDAP-2.0",
    "OLDAP-2.0.1",
    "OLDAP-2.1",
    "OLDAP-2.2",
    "OLDAP-2.2.1",
    "OLDAP-2.2.2",
    "OLDAP-2.3",
    "OLDAP-2.4",
    "OLDAP-2.5",
    "OLDAP-2.6",
    "OLDAP-2.7",
    "OLDAP-2.8",
    "OML",
    "OPL-1.0",
    "OSET-PL-2.1",
    "OSL-1.0",
    "OSL-1.1",
    "OSL-2.0",
    "OSL-2.1",
    "OSL-3.0",
    "OpenSSL",
    "PDDL-1.0",
    "PHP-3.0",
    "PHP-3.01",
    "PSF-2.0",
    "Parity-6.0.0",
    "Parity-7.0.0",
    "Plexus",
    "PolyForm-Noncommercial-1.0.0",
    "PolyForm-Small-Business-1.0.0",
    "PostgreSQL",
    "Python-2.0",
    "QPL-1.0",
    "Qhull",
    "RHeCos-1.1",
    "RPL-1.1",
    "RPL-1.5",
    "RPSL-1.0",
    "RSA-MD",
    "RSCPL",
    "Rdisc",
    "Ruby",
    "SAX-PD",
    "SCEA",
    "SGI-B-1.0",
    "SGI-B-1.1",
    "SGI-B-2.0",
    "SHL-0.5",
    "SHL-0.51",
    "SISSL",
    "SISSL-1.2",
    "SMLNJ",
    "SMPPL",
    "SNIA",
    "SPL-1.0",
    "SSH-OpenSSH",
    "SSH-short",
    "SSPL-1.0",
    "SWL",
    "Saxpath",
    "Sendmail",
    "Sendmail-8.23",
    "SimPL-2.0",
    "Sleepycat",
    "Spencer-86",
    "Spencer-94",
    "Spencer-99",
    "SugarCRM-1.1.3",
    "TAPR-OHL-1.0",
    "TCL",
    "TCP-wrappers",
    "TMate",
    "TORQUE-1.1",
    "TOSL",
    "TU-Berlin-1.0",
    "TU-Berlin-2.0",
    "UCL-1.0",
    "UPL-1.0",
    "Unicode-DFS-2015",
    "Unicode-DFS-2016",
    "Unicode-TOU",
    "Unlicense",
    "VOSTROM",
    "VSL-1.0",
    "Vim",
    "W3C",
    "W3C-19980720",
    "W3C-20150513",
    "WTFPL",
    "Watcom-1.0",
    "Wsuipa",
    "X11",
    "XFree86-1.1",
    "XSkat",
    "Xerox",
    "Xnet",
    "YPL-1.0",
    "YPL-1.1",
    "ZPL-1.1",
    "ZPL-2.0",
    "ZPL-2.1",
    "Zed",
    "Zend-2.0",
    "Zimbra-1.3",
    "Zimbra-1.4",
    "Zlib",
    "blessing",
    "bzip2-1.0.5",
    "bzip2-1.0.6",
    "copyleft-next-0.3.0",
    "copyleft-next-0.3.1",
    "curl",
    "diffmark",
    "dvipdfm",
    "eGenix",
    "etalab-2.0",
    "gSOAP-1.3b",
    "gnuplot",
    "iMatix",
    "libpng-2.0",
    "libselinux-1.0",
    "libtiff",
    "mpich2",
    "psfrag",
    "psutils",
    "xinetd",
    "xpp",
    "zlib-acknowledgement"
  ];
});

// node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS((exports2, module2) => {
  module2.exports = [
    "AGPL-1.0",
    "AGPL-3.0",
    "BSD-2-Clause-FreeBSD",
    "BSD-2-Clause-NetBSD",
    "GFDL-1.1",
    "GFDL-1.2",
    "GFDL-1.3",
    "GPL-1.0",
    "GPL-2.0",
    "GPL-2.0-with-GCC-exception",
    "GPL-2.0-with-autoconf-exception",
    "GPL-2.0-with-bison-exception",
    "GPL-2.0-with-classpath-exception",
    "GPL-2.0-with-font-exception",
    "GPL-3.0",
    "GPL-3.0-with-GCC-exception",
    "GPL-3.0-with-autoconf-exception",
    "LGPL-2.0",
    "LGPL-2.1",
    "LGPL-3.0",
    "Nunit",
    "StandardML-NJ",
    "eCos-2.0",
    "wxWindows"
  ];
});

// node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS((exports2, module2) => {
  module2.exports = [
    "389-exception",
    "Autoconf-exception-2.0",
    "Autoconf-exception-3.0",
    "Bison-exception-2.2",
    "Bootloader-exception",
    "Classpath-exception-2.0",
    "CLISP-exception-2.0",
    "DigiRule-FOSS-exception",
    "eCos-exception-2.0",
    "Fawkes-Runtime-exception",
    "FLTK-exception",
    "Font-exception-2.0",
    "freertos-exception-2.0",
    "GCC-exception-2.0",
    "GCC-exception-3.1",
    "gnu-javamail-exception",
    "GPL-3.0-linking-exception",
    "GPL-3.0-linking-source-exception",
    "GPL-CC-1.0",
    "i2p-gpl-java-exception",
    "Libtool-exception",
    "Linux-syscall-note",
    "LLVM-exception",
    "LZMA-exception",
    "mif-exception",
    "Nokia-Qt-exception-1.1",
    "OCaml-LGPL-linking-exception",
    "OCCT-exception-1.0",
    "OpenJDK-assembly-exception-1.0",
    "openvpn-openssl-exception",
    "PS-or-PDF-font-exception-20170817",
    "Qt-GPL-exception-1.0",
    "Qt-LGPL-exception-1.1",
    "Qwt-exception-1.0",
    "Swift-exception",
    "u-boot-exception-2.0",
    "Universal-FOSS-exception-1.0",
    "WxWindows-exception-3.1"
  ];
});

// node_modules/spdx-expression-parse/scan.js
var require_scan2 = __commonJS((exports2, module2) => {
  "use strict";
  var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
  var exceptions = require_spdx_exceptions();
  module2.exports = function(source) {
    var index = 0;
    function hasMore() {
      return index < source.length;
    }
    function read(value) {
      if (value instanceof RegExp) {
        var chars = source.slice(index);
        var match = chars.match(value);
        if (match) {
          index += match[0].length;
          return match[0];
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length;
          return value;
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/);
    }
    function operator() {
      var string;
      var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
      for (var i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i]);
        if (string) {
          break;
        }
      }
      if (string === "+" && index > 1 && source[index - 2] === " ") {
        throw new Error("Space before `+`");
      }
      return string && {
        type: "OPERATOR",
        string
      };
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/);
    }
    function expectIdstring() {
      var string = idstring();
      if (!string) {
        throw new Error("Expected idstring at offset " + index);
      }
      return string;
    }
    function documentRef() {
      if (read("DocumentRef-")) {
        var string = expectIdstring();
        return {type: "DOCUMENTREF", string};
      }
    }
    function licenseRef() {
      if (read("LicenseRef-")) {
        var string = expectIdstring();
        return {type: "LICENSEREF", string};
      }
    }
    function identifier() {
      var begin = index;
      var string = idstring();
      if (licenses.indexOf(string) !== -1) {
        return {
          type: "LICENSE",
          string
        };
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: "EXCEPTION",
          string
        };
      }
      index = begin;
    }
    function parseToken() {
      return operator() || documentRef() || licenseRef() || identifier();
    }
    var tokens = [];
    while (hasMore()) {
      skipWhitespace();
      if (!hasMore()) {
        break;
      }
      var token = parseToken();
      if (!token) {
        throw new Error("Unexpected `" + source[index] + "` at offset " + index);
      }
      tokens.push(token);
    }
    return tokens;
  };
});

// node_modules/spdx-expression-parse/parse.js
var require_parse3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(tokens) {
    var index = 0;
    function hasMore() {
      return index < tokens.length;
    }
    function token() {
      return hasMore() ? tokens[index] : null;
    }
    function next() {
      if (!hasMore()) {
        throw new Error();
      }
      index++;
    }
    function parseOperator(operator) {
      var t = token();
      if (t && t.type === "OPERATOR" && operator === t.string) {
        next();
        return t.string;
      }
    }
    function parseWith() {
      if (parseOperator("WITH")) {
        var t = token();
        if (t && t.type === "EXCEPTION") {
          next();
          return t.string;
        }
        throw new Error("Expected exception after `WITH`");
      }
    }
    function parseLicenseRef() {
      var begin = index;
      var string = "";
      var t = token();
      if (t.type === "DOCUMENTREF") {
        next();
        string += "DocumentRef-" + t.string + ":";
        if (!parseOperator(":")) {
          throw new Error("Expected `:` after `DocumentRef-...`");
        }
      }
      t = token();
      if (t.type === "LICENSEREF") {
        next();
        string += "LicenseRef-" + t.string;
        return {license: string};
      }
      index = begin;
    }
    function parseLicense() {
      var t = token();
      if (t && t.type === "LICENSE") {
        next();
        var node2 = {license: t.string};
        if (parseOperator("+")) {
          node2.plus = true;
        }
        var exception = parseWith();
        if (exception) {
          node2.exception = exception;
        }
        return node2;
      }
    }
    function parseParenthesizedExpression() {
      var left = parseOperator("(");
      if (!left) {
        return;
      }
      var expr = parseExpression();
      if (!parseOperator(")")) {
        throw new Error("Expected `)`");
      }
      return expr;
    }
    function parseAtom() {
      return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        var left = nextParser();
        if (!left) {
          return;
        }
        if (!parseOperator(operator)) {
          return left;
        }
        var right = parseBinaryOp();
        if (!right) {
          throw new Error("Expected expression");
        }
        return {
          left,
          conjunction: operator.toLowerCase(),
          right
        };
      };
    }
    var parseAnd = makeBinaryOpParser("AND", parseAtom);
    var parseExpression = makeBinaryOpParser("OR", parseAnd);
    var node = parseExpression();
    if (!node || hasMore()) {
      throw new Error("Syntax error");
    }
    return node;
  };
});

// node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS((exports2, module2) => {
  "use strict";
  var scan = require_scan2();
  var parse = require_parse3();
  module2.exports = function(source) {
    return parse(scan(source));
  };
});

// node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS((exports2, module2) => {
  var parse = require_spdx_expression_parse();
  var spdxLicenseIds = require_spdx_license_ids();
  function valid(string) {
    try {
      parse(string);
      return true;
    } catch (error) {
      return false;
    }
  }
  var transpositions = [
    ["APGL", "AGPL"],
    ["Gpl", "GPL"],
    ["GLP", "GPL"],
    ["APL", "Apache"],
    ["ISD", "ISC"],
    ["GLP", "GPL"],
    ["IST", "ISC"],
    ["Claude", "Clause"],
    [" or later", "+"],
    [" International", ""],
    ["GNU", "GPL"],
    ["GUN", "GPL"],
    ["+", ""],
    ["GNU GPL", "GPL"],
    ["GNU/GPL", "GPL"],
    ["GNU GLP", "GPL"],
    ["GNU General Public License", "GPL"],
    ["Gnu public license", "GPL"],
    ["GNU Public License", "GPL"],
    ["GNU GENERAL PUBLIC LICENSE", "GPL"],
    ["MTI", "MIT"],
    ["Mozilla Public License", "MPL"],
    ["Universal Permissive License", "UPL"],
    ["WTH", "WTF"],
    ["-License", ""]
  ];
  var TRANSPOSED = 0;
  var CORRECT = 1;
  var transforms = [
    function(argument) {
      return argument.toUpperCase();
    },
    function(argument) {
      return argument.trim();
    },
    function(argument) {
      return argument.replace(/\./g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "-");
    },
    function(argument) {
      return argument.replace("v", "-");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
    },
    function(argument) {
      return argument[0].toUpperCase() + argument.slice(1);
    },
    function(argument) {
      return argument.replace("/", "-");
    },
    function(argument) {
      return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
    },
    function(argument) {
      if (argument.indexOf("3.0") !== -1) {
        return argument + "-or-later";
      } else {
        return argument + "-only";
      }
    },
    function(argument) {
      return argument + "only";
    },
    function(argument) {
      return argument.replace(/(\d)$/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
    },
    function(argument) {
      return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
    },
    function(argument) {
      return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
    },
    function(argument) {
      return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
    },
    function(argument) {
      return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
    },
    function(argument) {
      return "CC-" + argument;
    },
    function(argument) {
      return "CC-" + argument + "-4.0";
    },
    function(argument) {
      return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
    },
    function(argument) {
      return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
    }
  ];
  var licensesWithVersions = spdxLicenseIds.map(function(id) {
    var match = /^(.*)-\d+\.\d+$/.exec(id);
    return match ? [match[0], match[1]] : [id, null];
  }).reduce(function(objectMap, item) {
    var key = item[1];
    objectMap[key] = objectMap[key] || [];
    objectMap[key].push(item[0]);
    return objectMap;
  }, {});
  var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
    return [key, licensesWithVersions[key]];
  }).filter(function identifySoleVersions(item) {
    return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
  }).map(function createLastResorts(item) {
    return [item[0], item[1][0]];
  });
  licensesWithVersions = void 0;
  var lastResorts = [
    ["UNLI", "Unlicense"],
    ["WTF", "WTFPL"],
    ["2 CLAUSE", "BSD-2-Clause"],
    ["2-CLAUSE", "BSD-2-Clause"],
    ["3 CLAUSE", "BSD-3-Clause"],
    ["3-CLAUSE", "BSD-3-Clause"],
    ["AFFERO", "AGPL-3.0-or-later"],
    ["AGPL", "AGPL-3.0-or-later"],
    ["APACHE", "Apache-2.0"],
    ["ARTISTIC", "Artistic-2.0"],
    ["Affero", "AGPL-3.0-or-later"],
    ["BEER", "Beerware"],
    ["BOOST", "BSL-1.0"],
    ["BSD", "BSD-2-Clause"],
    ["CDDL", "CDDL-1.1"],
    ["ECLIPSE", "EPL-1.0"],
    ["FUCK", "WTFPL"],
    ["GNU", "GPL-3.0-or-later"],
    ["LGPL", "LGPL-3.0-or-later"],
    ["GPLV1", "GPL-1.0-only"],
    ["GPL-1", "GPL-1.0-only"],
    ["GPLV2", "GPL-2.0-only"],
    ["GPL-2", "GPL-2.0-only"],
    ["GPL", "GPL-3.0-or-later"],
    ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
    ["MIT", "MIT"],
    ["MPL", "MPL-2.0"],
    ["X11", "X11"],
    ["ZLIB", "Zlib"]
  ].concat(licensesWithOneVersion);
  var SUBSTRING = 0;
  var IDENTIFIER = 1;
  var validTransformation = function(identifier) {
    for (var i = 0; i < transforms.length; i++) {
      var transformed = transforms[i](identifier).trim();
      if (transformed !== identifier && valid(transformed)) {
        return transformed;
      }
    }
    return null;
  };
  var validLastResort = function(identifier) {
    var upperCased = identifier.toUpperCase();
    for (var i = 0; i < lastResorts.length; i++) {
      var lastResort = lastResorts[i];
      if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
        return lastResort[IDENTIFIER];
      }
    }
    return null;
  };
  var anyCorrection = function(identifier, check) {
    for (var i = 0; i < transpositions.length; i++) {
      var transposition = transpositions[i];
      var transposed = transposition[TRANSPOSED];
      if (identifier.indexOf(transposed) > -1) {
        var corrected = identifier.replace(transposed, transposition[CORRECT]);
        var checked = check(corrected);
        if (checked !== null) {
          return checked;
        }
      }
    }
    return null;
  };
  module2.exports = function(identifier, options) {
    options = options || {};
    var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
    function postprocess(value) {
      return upgrade ? upgradeGPLs(value) : value;
    }
    var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
    if (!validArugment) {
      throw Error("Invalid argument. Expected non-empty string.");
    }
    identifier = identifier.trim();
    if (valid(identifier)) {
      return postprocess(identifier);
    }
    var noPlus = identifier.replace(/\+$/, "").trim();
    if (valid(noPlus)) {
      return postprocess(noPlus);
    }
    var transformed = validTransformation(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, function(argument) {
      if (valid(argument)) {
        return argument;
      }
      return validTransformation(argument);
    });
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = validLastResort(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, validLastResort);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    return null;
  };
  function upgradeGPLs(value) {
    if ([
      "GPL-1.0",
      "LGPL-1.0",
      "AGPL-1.0",
      "GPL-2.0",
      "LGPL-2.0",
      "AGPL-2.0",
      "LGPL-2.1"
    ].indexOf(value) !== -1) {
      return value + "-only";
    } else if ([
      "GPL-1.0+",
      "GPL-2.0+",
      "GPL-3.0+",
      "LGPL-2.0+",
      "LGPL-2.1+",
      "LGPL-3.0+",
      "AGPL-1.0+",
      "AGPL-3.0+"
    ].indexOf(value) !== -1) {
      return value.replace(/\+$/, "-or-later");
    } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
      return value + "-or-later";
    } else {
      return value;
    }
  }
});

// node_modules/validate-npm-package-license/index.js
var require_validate_npm_package_license = __commonJS((exports2, module2) => {
  var parse = require_spdx_expression_parse();
  var correct = require_spdx_correct();
  var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
  var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
  function startsWith(prefix, string) {
    return string.slice(0, prefix.length) === prefix;
  }
  function usesLicenseRef(ast) {
    if (ast.hasOwnProperty("license")) {
      var license = ast.license;
      return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
    } else {
      return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
    }
  }
  module2.exports = function(argument) {
    var ast;
    try {
      ast = parse(argument);
    } catch (e) {
      var match;
      if (argument === "UNLICENSED" || argument === "UNLICENCED") {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          unlicensed: true
        };
      } else if (match = fileReferenceRE.exec(argument)) {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          inFile: match[1]
        };
      } else {
        var result = {
          validForOldPackages: false,
          validForNewPackages: false,
          warnings: [genericWarning]
        };
        if (argument.trim().length !== 0) {
          var corrected = correct(argument);
          if (corrected) {
            result.warnings.push('license is similar to the valid expression "' + corrected + '"');
          }
        }
        return result;
      }
    }
    if (usesLicenseRef(ast)) {
      return {
        validForNewPackages: false,
        validForOldPackages: false,
        spdx: true,
        warnings: [genericWarning]
      };
    } else {
      return {
        validForNewPackages: true,
        validForOldPackages: true,
        spdx: true
      };
    }
  };
});

// node_modules/read-pkg/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = module2.exports = {
    github: {
      protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
      domain: "github.com",
      treepath: "tree",
      filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
      tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
    },
    bitbucket: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "bitbucket.org",
      treepath: "src",
      tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
    },
    gitlab: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "gitlab.com",
      treepath: "tree",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
      tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
      pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
    },
    gist: {
      protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
      domain: "gist.github.com",
      pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
      filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
      bugstemplate: "https://{domain}/{project}",
      gittemplate: "git://{domain}/{project}.git{#committish}",
      sshtemplate: "git@{domain}:/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{project}{/committish}",
      browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
      docstemplate: "https://{domain}/{project}{/committish}",
      httpstemplate: "git+https://{domain}/{project}.git{#committish}",
      shortcuttemplate: "{type}:{project}{#committish}",
      pathtemplate: "{project}{#committish}",
      tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
      hashformat: function(fragment) {
        return "file-" + formatHashFragment(fragment);
      }
    }
  };
  var gitHostDefaults = {
    sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
    sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
    browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
    browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
    docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
    httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
    filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
    shortcuttemplate: "{type}:{user}/{project}{#committish}",
    pathtemplate: "{user}/{project}{#committish}",
    pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
    hashformat: formatHashFragment
  };
  Object.keys(gitHosts).forEach(function(name) {
    Object.keys(gitHostDefaults).forEach(function(key) {
      if (gitHosts[name][key])
        return;
      gitHosts[name][key] = gitHostDefaults[key];
    });
    gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
    }).join("|") + "):$");
  });
  function formatHashFragment(fragment) {
    return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
  }
});

// node_modules/read-pkg/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = require_git_host_info();
  var extend = Object.assign || function _extend(target, source) {
    if (source === null || typeof source !== "object")
      return target;
    var keys = Object.keys(source);
    var i = keys.length;
    while (i--) {
      target[keys[i]] = source[keys[i]];
    }
    return target;
  };
  module2.exports = GitHost;
  function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
    var gitHostInfo = this;
    gitHostInfo.type = type;
    Object.keys(gitHosts[type]).forEach(function(key) {
      gitHostInfo[key] = gitHosts[type][key];
    });
    gitHostInfo.user = user;
    gitHostInfo.auth = auth;
    gitHostInfo.project = project;
    gitHostInfo.committish = committish;
    gitHostInfo.default = defaultRepresentation;
    gitHostInfo.opts = opts || {};
  }
  GitHost.prototype.hash = function() {
    return this.committish ? "#" + this.committish : "";
  };
  GitHost.prototype._fill = function(template, opts) {
    if (!template)
      return;
    var vars = extend({}, opts);
    vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "";
    opts = extend(extend({}, this.opts), opts);
    var self2 = this;
    Object.keys(this).forEach(function(key) {
      if (self2[key] != null && vars[key] == null)
        vars[key] = self2[key];
    });
    var rawAuth = vars.auth;
    var rawcommittish = vars.committish;
    var rawFragment = vars.fragment;
    var rawPath = vars.path;
    var rawProject = vars.project;
    Object.keys(vars).forEach(function(key) {
      var value = vars[key];
      if ((key === "path" || key === "project") && typeof value === "string") {
        vars[key] = value.split("/").map(function(pathComponent) {
          return encodeURIComponent(pathComponent);
        }).join("/");
      } else {
        vars[key] = encodeURIComponent(value);
      }
    });
    vars["auth@"] = rawAuth ? rawAuth + "@" : "";
    vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "";
    vars.fragment = vars.fragment ? vars.fragment : "";
    vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "";
    vars["/path"] = vars.path ? "/" + vars.path : "";
    vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/");
    if (opts.noCommittish) {
      vars["#committish"] = "";
      vars["/tree/committish"] = "";
      vars["/committish"] = "";
      vars.committish = "";
    } else {
      vars["#committish"] = rawcommittish ? "#" + rawcommittish : "";
      vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "";
      vars["/committish"] = vars.committish ? "/" + vars.committish : "";
      vars.committish = vars.committish || "master";
    }
    var res = template;
    Object.keys(vars).forEach(function(key) {
      res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
    });
    if (opts.noGitPlus) {
      return res.replace(/^git[+]/, "");
    } else {
      return res;
    }
  };
  GitHost.prototype.ssh = function(opts) {
    return this._fill(this.sshtemplate, opts);
  };
  GitHost.prototype.sshurl = function(opts) {
    return this._fill(this.sshurltemplate, opts);
  };
  GitHost.prototype.browse = function(P, F, opts) {
    if (typeof P === "string") {
      if (typeof F !== "string") {
        opts = F;
        F = null;
      }
      return this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P
      }, opts));
    } else {
      return this._fill(this.browsetemplate, P);
    }
  };
  GitHost.prototype.docs = function(opts) {
    return this._fill(this.docstemplate, opts);
  };
  GitHost.prototype.bugs = function(opts) {
    return this._fill(this.bugstemplate, opts);
  };
  GitHost.prototype.https = function(opts) {
    return this._fill(this.httpstemplate, opts);
  };
  GitHost.prototype.git = function(opts) {
    return this._fill(this.gittemplate, opts);
  };
  GitHost.prototype.shortcut = function(opts) {
    return this._fill(this.shortcuttemplate, opts);
  };
  GitHost.prototype.path = function(opts) {
    return this._fill(this.pathtemplate, opts);
  };
  GitHost.prototype.tarball = function(opts_) {
    var opts = extend({}, opts_, {noCommittish: false});
    return this._fill(this.tarballtemplate, opts);
  };
  GitHost.prototype.file = function(P, opts) {
    return this._fill(this.filetemplate, extend({path: P}, opts));
  };
  GitHost.prototype.getDefaultRepresentation = function() {
    return this.default;
  };
  GitHost.prototype.toString = function(opts) {
    if (this.default && typeof this[this.default] === "function")
      return this[this.default](opts);
    return this.sshurl(opts);
  };
});

// node_modules/read-pkg/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS((exports2, module2) => {
  "use strict";
  var url = require("url");
  var gitHosts = require_git_host_info();
  var GitHost = module2.exports = require_git_host();
  var protocolToRepresentationMap = {
    "git+ssh:": "sshurl",
    "git+https:": "https",
    "ssh:": "sshurl",
    "git:": "git"
  };
  function protocolToRepresentation(protocol) {
    return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
  }
  var authProtocols = {
    "git:": true,
    "https:": true,
    "git+https:": true,
    "http:": true,
    "git+http:": true
  };
  var cache = {};
  module2.exports.fromUrl = function(giturl, opts) {
    if (typeof giturl !== "string")
      return;
    var key = giturl + JSON.stringify(opts || {});
    if (!(key in cache)) {
      cache[key] = fromUrl(giturl, opts);
    }
    return cache[key];
  };
  function fromUrl(giturl, opts) {
    if (giturl == null || giturl === "")
      return;
    var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl);
    var parsed = parseGitUrl(url2);
    var shortcutMatch = url2.match(new RegExp("^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)"));
    var matches = Object.keys(gitHosts).map(function(gitHostName) {
      try {
        var gitHostInfo = gitHosts[gitHostName];
        var auth = null;
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = parsed.auth;
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        if (shortcutMatch && shortcutMatch[1] === gitHostName) {
          user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);
          project = decodeURIComponent(shortcutMatch[3]);
          defaultRepresentation = "shortcut";
        } else {
          if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain)
            return;
          if (!gitHostInfo.protocols_re.test(parsed.protocol))
            return;
          if (!parsed.path)
            return;
          var pathmatch = gitHostInfo.pathmatch;
          var matched = parsed.path.match(pathmatch);
          if (!matched)
            return;
          if (matched[1] !== null && matched[1] !== void 0) {
            user = decodeURIComponent(matched[1].replace(/^:/, ""));
          }
          project = decodeURIComponent(matched[2]);
          defaultRepresentation = protocolToRepresentation(parsed.protocol);
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
      } catch (ex) {
        if (ex instanceof URIError) {
        } else
          throw ex;
      }
    }).filter(function(gitHostInfo) {
      return gitHostInfo;
    });
    if (matches.length !== 1)
      return;
    return matches[0];
  }
  function isGitHubShorthand(arg) {
    return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
  }
  function fixupUnqualifiedGist(giturl) {
    var parsed = url.parse(giturl);
    if (parsed.protocol === "gist:" && parsed.host && !parsed.path) {
      return parsed.protocol + "/" + parsed.host;
    } else {
      return giturl;
    }
  }
  function parseGitUrl(giturl) {
    var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
    if (!matched) {
      var legacy = url.parse(giturl);
      if (legacy.auth && typeof url.URL === "function") {
        var authmatch = giturl.match(/[^@]+@[^:/]+/);
        if (authmatch) {
          var whatwg = new url.URL(authmatch[0]);
          legacy.auth = whatwg.username || "";
          if (whatwg.password)
            legacy.auth += ":" + whatwg.password;
        }
      }
      return legacy;
    }
    return {
      protocol: "git+ssh:",
      slashes: true,
      auth: matched[1],
      host: matched[2],
      port: null,
      hostname: matched[2],
      hash: matched[4],
      search: null,
      query: null,
      pathname: "/" + matched[3],
      path: "/" + matched[3],
      href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports2, module2) => {
  "use strict";
  var isWindows = process.platform === "win32";
  var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
  var win32 = {};
  function win32SplitPath(filename) {
    var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
    var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
    return [device, dir, basename, ext];
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    allParts[1] = allParts[1] || "";
    allParts[2] = allParts[2] || "";
    allParts[3] = allParts[3] || "";
    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };
  if (isWindows)
    module2.exports = win32.parse;
  else
    module2.exports = posix.parse;
  module2.exports.posix = posix.parse;
  module2.exports.win32 = win32.parse;
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports2, module2) => {
  var path = require("path");
  var parse = path.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module2.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports2, module2) => {
  module2.exports = function(x, opts) {
    return opts || {};
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// node_modules/has/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// node_modules/is-core-module/core.json
var require_core2 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    "path/posix": ">= 15.3",
    "path/win32": ">= 15.3",
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "util/types": ">= 15.3",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports2, module2) => {
  "use strict";
  var has = require_src2();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core2();
  module2.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
  var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path.dirname(dir), cb2);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path.dirname(dir), cb2);
          readFile(pkgfile, function(err3, body) {
            if (err3)
              cb2(err3);
            try {
              var pkg = JSON.parse(body);
            } catch (jsonErr) {
            }
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path.join(x2, "index"), fpkg, cb2);
          readFile(pkgfile, function(err3, body) {
            if (err3)
              return cb2(err3);
            try {
              var pkg = JSON.parse(body);
            } catch (jsonErr) {
            }
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                var dir = path.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      isDirectory(path.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// node_modules/resolve/lib/core.json
var require_core3 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// node_modules/resolve/lib/core.js
var require_core4 = __commonJS((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(current[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      } else {
        return false;
      }
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core3();
  var core2 = {};
  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core2[mod] = versionIncluded(data[mod]);
    }
  }
  module2.exports = core2;
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports2, module2) => {
  var isCoreModule = require_is_core_module();
  module2.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports2, module2) => {
  var isCore = require_is_core_module();
  var fs = require("fs");
  var path = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs.statSync(file);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isFile() || stat.isFIFO();
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs.statSync(dir);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path.dirname(dir));
      }
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
      } catch (jsonErr) {
      }
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return {pkg, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var body = readFileSync(pkgfile, "UTF8");
          var pkg = JSON.parse(body);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// node_modules/resolve/index.js
var require_resolve = __commonJS((exports2, module2) => {
  var async = require_async();
  async.core = require_core4();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module2.exports = async;
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/extract_description.js
var require_extract_description = __commonJS((exports2, module2) => {
  module2.exports = extractDescription;
  function extractDescription(d) {
    if (!d)
      return;
    if (d === "ERROR: No README data found!")
      return;
    d = d.trim().split("\n");
    for (var s = 0; d[s] && d[s].trim().match(/^(#|$)/); s++)
      ;
    var l = d.length;
    for (var e = s + 1; e < l && d[e].trim(); e++)
      ;
    return d.slice(s, e).join(" ").trim();
  }
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/typos.json
var require_typos = __commonJS((exports2, module2) => {
  module2.exports = {
    topLevel: {
      dependancies: "dependencies",
      dependecies: "dependencies",
      depdenencies: "dependencies",
      devEependencies: "devDependencies",
      depends: "dependencies",
      "dev-dependencies": "devDependencies",
      devDependences: "devDependencies",
      devDepenencies: "devDependencies",
      devdependencies: "devDependencies",
      repostitory: "repository",
      repo: "repository",
      prefereGlobal: "preferGlobal",
      hompage: "homepage",
      hampage: "homepage",
      autohr: "author",
      autor: "author",
      contributers: "contributors",
      publicationConfig: "publishConfig",
      script: "scripts"
    },
    bugs: {web: "url", name: "url"},
    script: {server: "start", tests: "test"}
  };
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/fixer.js
var require_fixer = __commonJS((exports2, module2) => {
  var semver = require_semver2();
  var validateLicense = require_validate_npm_package_license();
  var hostedGitInfo = require_hosted_git_info();
  var isBuiltinModule = require_resolve().isCore;
  var depTypes = ["dependencies", "devDependencies", "optionalDependencies"];
  var extractDescription = require_extract_description();
  var url = require("url");
  var typos = require_typos();
  var fixer = module2.exports = {
    warn: function() {
    },
    fixRepositoryField: function(data) {
      if (data.repositories) {
        this.warn("repositories");
        data.repository = data.repositories[0];
      }
      if (!data.repository)
        return this.warn("missingRepository");
      if (typeof data.repository === "string") {
        data.repository = {
          type: "git",
          url: data.repository
        };
      }
      var r = data.repository.url || "";
      if (r) {
        var hosted = hostedGitInfo.fromUrl(r);
        if (hosted) {
          r = data.repository.url = hosted.getDefaultRepresentation() == "shortcut" ? hosted.https() : hosted.toString();
        }
      }
      if (r.match(/github.com\/[^\/]+\/[^\/]+\.git\.git$/)) {
        this.warn("brokenGitUrl", r);
      }
    },
    fixTypos: function(data) {
      Object.keys(typos.topLevel).forEach(function(d) {
        if (data.hasOwnProperty(d)) {
          this.warn("typo", d, typos.topLevel[d]);
        }
      }, this);
    },
    fixScriptsField: function(data) {
      if (!data.scripts)
        return;
      if (typeof data.scripts !== "object") {
        this.warn("nonObjectScripts");
        delete data.scripts;
        return;
      }
      Object.keys(data.scripts).forEach(function(k) {
        if (typeof data.scripts[k] !== "string") {
          this.warn("nonStringScript");
          delete data.scripts[k];
        } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
          this.warn("typo", k, typos.script[k], "scripts");
        }
      }, this);
    },
    fixFilesField: function(data) {
      var files = data.files;
      if (files && !Array.isArray(files)) {
        this.warn("nonArrayFiles");
        delete data.files;
      } else if (data.files) {
        data.files = data.files.filter(function(file) {
          if (!file || typeof file !== "string") {
            this.warn("invalidFilename", file);
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixBinField: function(data) {
      if (!data.bin)
        return;
      if (typeof data.bin === "string") {
        var b = {};
        var match;
        if (match = data.name.match(/^@[^/]+[/](.*)$/)) {
          b[match[1]] = data.bin;
        } else {
          b[data.name] = data.bin;
        }
        data.bin = b;
      }
    },
    fixManField: function(data) {
      if (!data.man)
        return;
      if (typeof data.man === "string") {
        data.man = [data.man];
      }
    },
    fixBundleDependenciesField: function(data) {
      var bdd = "bundledDependencies";
      var bd = "bundleDependencies";
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd];
        delete data[bdd];
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        this.warn("nonArrayBundleDependencies");
        delete data[bd];
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function(bd2) {
          if (!bd2 || typeof bd2 !== "string") {
            this.warn("nonStringBundleDependency", bd2);
            return false;
          } else {
            if (!data.dependencies) {
              data.dependencies = {};
            }
            if (!data.dependencies.hasOwnProperty(bd2)) {
              this.warn("nonDependencyBundleDependency", bd2);
              data.dependencies[bd2] = "*";
            }
            return true;
          }
        }, this);
      }
    },
    fixDependencies: function(data, strict) {
      var loose = !strict;
      objectifyDeps(data, this.warn);
      addOptionalDepsToDeps(data, this.warn);
      this.fixBundleDependenciesField(data);
      ["dependencies", "devDependencies"].forEach(function(deps) {
        if (!(deps in data))
          return;
        if (!data[deps] || typeof data[deps] !== "object") {
          this.warn("nonObjectDependencies", deps);
          delete data[deps];
          return;
        }
        Object.keys(data[deps]).forEach(function(d) {
          var r = data[deps][d];
          if (typeof r !== "string") {
            this.warn("nonStringDependency", d, JSON.stringify(r));
            delete data[deps][d];
          }
          var hosted = hostedGitInfo.fromUrl(data[deps][d]);
          if (hosted)
            data[deps][d] = hosted.toString();
        }, this);
      }, this);
    },
    fixModulesField: function(data) {
      if (data.modules) {
        this.warn("deprecatedModules");
        delete data.modules;
      }
    },
    fixKeywordsField: function(data) {
      if (typeof data.keywords === "string") {
        data.keywords = data.keywords.split(/,\s+/);
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
        this.warn("nonArrayKeywords");
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function(kw) {
          if (typeof kw !== "string" || !kw) {
            this.warn("nonStringKeyword");
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixVersionField: function(data, strict) {
      var loose = !strict;
      if (!data.version) {
        data.version = "";
        return true;
      }
      if (!semver.valid(data.version, loose)) {
        throw new Error('Invalid version: "' + data.version + '"');
      }
      data.version = semver.clean(data.version, loose);
      return true;
    },
    fixPeople: function(data) {
      modifyPeople(data, unParsePerson);
      modifyPeople(data, parsePerson);
    },
    fixNameField: function(data, options) {
      if (typeof options === "boolean")
        options = {strict: options};
      else if (typeof options === "undefined")
        options = {};
      var strict = options.strict;
      if (!data.name && !strict) {
        data.name = "";
        return;
      }
      if (typeof data.name !== "string") {
        throw new Error("name field must be a string.");
      }
      if (!strict)
        data.name = data.name.trim();
      ensureValidName(data.name, strict, options.allowLegacyCase);
      if (isBuiltinModule(data.name))
        this.warn("conflictingName", data.name);
    },
    fixDescriptionField: function(data) {
      if (data.description && typeof data.description !== "string") {
        this.warn("nonStringDescription");
        delete data.description;
      }
      if (data.readme && !data.description)
        data.description = extractDescription(data.readme);
      if (data.description === void 0)
        delete data.description;
      if (!data.description)
        this.warn("missingDescription");
    },
    fixReadmeField: function(data) {
      if (!data.readme) {
        this.warn("missingReadme");
        data.readme = "ERROR: No README data found!";
      }
    },
    fixBugsField: function(data) {
      if (!data.bugs && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.bugs()) {
          data.bugs = {url: hosted.bugs()};
        }
      } else if (data.bugs) {
        var emailRe = /^.+@.*\..+$/;
        if (typeof data.bugs == "string") {
          if (emailRe.test(data.bugs))
            data.bugs = {email: data.bugs};
          else if (url.parse(data.bugs).protocol)
            data.bugs = {url: data.bugs};
          else
            this.warn("nonEmailUrlBugsString");
        } else {
          bugsTypos(data.bugs, this.warn);
          var oldBugs = data.bugs;
          data.bugs = {};
          if (oldBugs.url) {
            if (typeof oldBugs.url == "string" && url.parse(oldBugs.url).protocol)
              data.bugs.url = oldBugs.url;
            else
              this.warn("nonUrlBugsUrlField");
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email == "string" && emailRe.test(oldBugs.email))
              data.bugs.email = oldBugs.email;
            else
              this.warn("nonEmailBugsEmailField");
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs;
          this.warn("emptyNormalizedBugs");
        }
      }
    },
    fixHomepageField: function(data) {
      if (!data.homepage && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.docs())
          data.homepage = hosted.docs();
      }
      if (!data.homepage)
        return;
      if (typeof data.homepage !== "string") {
        this.warn("nonUrlHomepage");
        return delete data.homepage;
      }
      if (!url.parse(data.homepage).protocol) {
        data.homepage = "http://" + data.homepage;
      }
    },
    fixLicenseField: function(data) {
      if (!data.license) {
        return this.warn("missingLicense");
      } else {
        if (typeof data.license !== "string" || data.license.length < 1 || data.license.trim() === "") {
          this.warn("invalidLicense");
        } else {
          if (!validateLicense(data.license).validForNewPackages)
            this.warn("invalidLicense");
        }
      }
    }
  };
  function isValidScopedPackageName(spec) {
    if (spec.charAt(0) !== "@")
      return false;
    var rest = spec.slice(1).split("/");
    if (rest.length !== 2)
      return false;
    return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
  }
  function isCorrectlyEncodedName(spec) {
    return !spec.match(/[\/@\s\+%:]/) && spec === encodeURIComponent(spec);
  }
  function ensureValidName(name, strict, allowLegacyCase) {
    if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") {
      throw new Error("Invalid name: " + JSON.stringify(name));
    }
  }
  function modifyPeople(data, fn) {
    if (data.author)
      data.author = fn(data.author);
    ["maintainers", "contributors"].forEach(function(set) {
      if (!Array.isArray(data[set]))
        return;
      data[set] = data[set].map(fn);
    });
    return data;
  }
  function unParsePerson(person) {
    if (typeof person === "string")
      return person;
    var name = person.name || "";
    var u = person.url || person.web;
    var url2 = u ? " (" + u + ")" : "";
    var e = person.email || person.mail;
    var email = e ? " <" + e + ">" : "";
    return name + email + url2;
  }
  function parsePerson(person) {
    if (typeof person !== "string")
      return person;
    var name = person.match(/^([^\(<]+)/);
    var url2 = person.match(/\(([^\)]+)\)/);
    var email = person.match(/<([^>]+)>/);
    var obj = {};
    if (name && name[0].trim())
      obj.name = name[0].trim();
    if (email)
      obj.email = email[1];
    if (url2)
      obj.url = url2[1];
    return obj;
  }
  function addOptionalDepsToDeps(data, warn) {
    var o = data.optionalDependencies;
    if (!o)
      return;
    var d = data.dependencies || {};
    Object.keys(o).forEach(function(k) {
      d[k] = o[k];
    });
    data.dependencies = d;
  }
  function depObjectify(deps, type, warn) {
    if (!deps)
      return {};
    if (typeof deps === "string") {
      deps = deps.trim().split(/[\n\r\s\t ,]+/);
    }
    if (!Array.isArray(deps))
      return deps;
    warn("deprecatedArrayDependencies", type);
    var o = {};
    deps.filter(function(d) {
      return typeof d === "string";
    }).forEach(function(d) {
      d = d.trim().split(/(:?[@\s><=])/);
      var dn = d.shift();
      var dv = d.join("");
      dv = dv.trim();
      dv = dv.replace(/^@/, "");
      o[dn] = dv;
    });
    return o;
  }
  function objectifyDeps(data, warn) {
    depTypes.forEach(function(type) {
      if (!data[type])
        return;
      data[type] = depObjectify(data[type], type, warn);
    });
  }
  function bugsTypos(bugs, warn) {
    if (!bugs)
      return;
    Object.keys(bugs).forEach(function(k) {
      if (typos.bugs[k]) {
        warn("typo", k, typos.bugs[k], "bugs");
        bugs[typos.bugs[k]] = bugs[k];
        delete bugs[k];
      }
    });
  }
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/warning_messages.json
var require_warning_messages = __commonJS((exports2, module2) => {
  module2.exports = {
    repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
    missingRepository: "No repository field.",
    brokenGitUrl: "Probably broken git url: %s",
    nonObjectScripts: "scripts must be an object",
    nonStringScript: "script values must be string commands",
    nonArrayFiles: "Invalid 'files' member",
    invalidFilename: "Invalid filename in 'files' list: %s",
    nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
    nonStringBundleDependency: "Invalid bundleDependencies member: %s",
    nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
    nonObjectDependencies: "%s field must be an object",
    nonStringDependency: "Invalid dependency: %s %s",
    deprecatedArrayDependencies: "specifying %s as array is deprecated",
    deprecatedModules: "modules field is deprecated",
    nonArrayKeywords: "keywords should be an array of strings",
    nonStringKeyword: "keywords should be an array of strings",
    conflictingName: "%s is also the name of a node core module.",
    nonStringDescription: "'description' field should be a string",
    missingDescription: "No description",
    missingReadme: "No README data",
    missingLicense: "No license field.",
    nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
    nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
    nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
    emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
    nonUrlHomepage: "homepage field must be a string url. Deleted.",
    invalidLicense: "license should be a valid SPDX license expression",
    typo: "%s should probably be %s."
  };
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/make_warning.js
var require_make_warning = __commonJS((exports2, module2) => {
  var util = require("util");
  var messages = require_warning_messages();
  module2.exports = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var warningName = args.shift();
    if (warningName == "typo") {
      return makeTypoWarning.apply(null, args);
    } else {
      var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
      args.unshift(msgTemplate);
      return util.format.apply(null, args);
    }
  };
  function makeTypoWarning(providedName, probableName, field) {
    if (field) {
      providedName = field + "['" + providedName + "']";
      probableName = field + "['" + probableName + "']";
    }
    return util.format(messages.typo, providedName, probableName);
  }
});

// node_modules/read-pkg/node_modules/normalize-package-data/lib/normalize.js
var require_normalize = __commonJS((exports2, module2) => {
  module2.exports = normalize;
  var fixer = require_fixer();
  normalize.fixer = fixer;
  var makeWarning = require_make_warning();
  var fieldsToFix = [
    "name",
    "version",
    "description",
    "repository",
    "modules",
    "scripts",
    "files",
    "bin",
    "man",
    "bugs",
    "keywords",
    "readme",
    "homepage",
    "license"
  ];
  var otherThingsToFix = ["dependencies", "people", "typos"];
  var thingsToFix = fieldsToFix.map(function(fieldName) {
    return ucFirst(fieldName) + "Field";
  });
  thingsToFix = thingsToFix.concat(otherThingsToFix);
  function normalize(data, warn, strict) {
    if (warn === true)
      warn = null, strict = true;
    if (!strict)
      strict = false;
    if (!warn || data.private)
      warn = function(msg) {
      };
    if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) {
      data.gypfile = true;
    }
    fixer.warn = function() {
      warn(makeWarning.apply(null, arguments));
    };
    thingsToFix.forEach(function(thingName) {
      fixer["fix" + ucFirst(thingName)](data, strict);
    });
    data._id = data.name + "@" + data.version;
  }
  function ucFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
});

// node_modules/read-pkg/index.js
var require_read_pkg = __commonJS((exports2, module2) => {
  "use strict";
  var {promisify} = require("util");
  var fs = require("fs");
  var path = require("path");
  var parseJson = require_parse_json();
  var readFileAsync = promisify(fs.readFile);
  module2.exports = async (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path.resolve(options.cwd, "package.json");
    const json = parseJson(await readFileAsync(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
  module2.exports.sync = (options) => {
    options = {
      cwd: process.cwd(),
      normalize: true,
      ...options
    };
    const filePath = path.resolve(options.cwd, "package.json");
    const json = parseJson(fs.readFileSync(filePath, "utf8"));
    if (options.normalize) {
      require_normalize()(json);
    }
    return json;
  };
});

// node_modules/read-pkg-up/index.js
var require_read_pkg_up = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var findUp = require_find_up();
  var readPkg = require_read_pkg();
  module2.exports = async (options) => {
    const filePath = await findUp("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: await readPkg({...options, cwd: path.dirname(filePath)}),
      path: filePath
    };
  };
  module2.exports.sync = (options) => {
    const filePath = findUp.sync("package.json", options);
    if (!filePath) {
      return;
    }
    return {
      packageJson: readPkg.sync({...options, cwd: path.dirname(filePath)}),
      path: filePath
    };
  };
});

// node_modules/@semantic-release/release-notes-generator/lib/load-changelog-config.js
var require_load_changelog_config = __commonJS((exports2, module2) => {
  var {promisify} = require("util");
  var {isPlainObject} = require_lodash();
  var importFrom = require_import_from();
  var conventionalChangelogAngular = require_conventional_changelog_angular();
  module2.exports = async ({preset, config, parserOpts, writerOpts, presetConfig}, {cwd}) => {
    let loadedConfig;
    if (preset) {
      const presetPackage = `conventional-changelog-${preset.toLowerCase()}`;
      loadedConfig = importFrom.silent(__dirname, presetPackage) || importFrom(cwd, presetPackage);
    } else if (config) {
      loadedConfig = importFrom.silent(__dirname, config) || importFrom(cwd, config);
    } else {
      loadedConfig = conventionalChangelogAngular;
    }
    loadedConfig = await (typeof loadedConfig === "function" ? isPlainObject(presetConfig) ? loadedConfig(presetConfig) : promisify(loadedConfig)() : loadedConfig);
    return {
      parserOpts: {...loadedConfig.parserOpts, ...parserOpts},
      writerOpts: {...loadedConfig.writerOpts, ...writerOpts}
    };
  };
});

// node_modules/@semantic-release/release-notes-generator/lib/hosts-config.js
var require_hosts_config = __commonJS((exports2, module2) => {
  module2.exports = {
    github: {
      hostname: "github.com",
      issue: "issues",
      commit: "commit",
      referenceActions: ["close", "closes", "closed", "fix", "fixes", "fixed", "resolve", "resolves", "resolved"],
      issuePrefixes: ["#", "gh-"]
    },
    bitbucket: {
      hostname: "bitbucket.org",
      issue: "issue",
      commit: "commits",
      referenceActions: [
        "close",
        "closes",
        "closed",
        "closing",
        "fix",
        "fixes",
        "fixed",
        "fixing",
        "resolve",
        "resolves",
        "resolved",
        "resolving"
      ],
      issuePrefixes: ["#"]
    },
    gitlab: {
      hostname: "gitlab.com",
      issue: "issues",
      commit: "commit",
      referenceActions: ["close", "closes", "closed", "closing", "fix", "fixes", "fixed", "fixing"],
      issuePrefixes: ["#"]
    },
    default: {
      issue: "issues",
      commit: "commit",
      referenceActions: [
        "close",
        "closes",
        "closed",
        "closing",
        "fix",
        "fixes",
        "fixed",
        "fixing",
        "resolve",
        "resolves",
        "resolved",
        "resolving"
      ],
      issuePrefixes: ["#", "gh-"]
    }
  };
});

// node_modules/@semantic-release/release-notes-generator/index.js
var require_release_notes_generator = __commonJS((exports2, module2) => {
  var {format} = require("url");
  var {find, merge} = require_lodash();
  var getStream = require_get_stream();
  var intoStream = require_into_stream();
  var parser = require_conventional_commits_parser().sync;
  var writer = require_conventional_changelog_writer();
  var filter = require_conventional_commits_filter();
  var readPkgUp = require_read_pkg_up();
  var debug = require_src()("semantic-release:release-notes-generator");
  var loadChangelogConfig = require_load_changelog_config();
  var HOSTS_CONFIG = require_hosts_config();
  async function generateNotes2(pluginConfig, context) {
    const {commits, lastRelease, nextRelease, options, cwd} = context;
    const repositoryUrl = options.repositoryUrl.replace(/\.git$/i, "");
    const {parserOpts, writerOpts} = await loadChangelogConfig(pluginConfig, context);
    const [match, auth, host, path] = /^(?!.+:\/\/)(?:(?<auth>.*)@)?(?<host>.*?):(?<path>.*)$/.exec(repositoryUrl) || [];
    let {hostname, port, pathname, protocol} = new URL(match ? `ssh://${auth ? `${auth}@` : ""}${host}/${path}` : repositoryUrl);
    port = protocol.includes("ssh") ? "" : port;
    protocol = protocol && /http[^s]/.test(protocol) ? "http" : "https";
    const [, owner, repository] = /^\/(?<owner>[^/]+)?\/?(?<repository>.+)?$/.exec(pathname);
    const {issue, commit, referenceActions, issuePrefixes} = find(HOSTS_CONFIG, (conf) => conf.hostname === hostname) || HOSTS_CONFIG.default;
    const parsedCommits = filter(commits.filter(({message, hash}) => {
      if (!message.trim()) {
        debug("Skip commit %s with empty message", hash);
        return false;
      }
      return true;
    }).map((rawCommit) => ({
      ...rawCommit,
      ...parser(rawCommit.message, {referenceActions, issuePrefixes, ...parserOpts})
    })));
    const previousTag = lastRelease.gitTag || lastRelease.gitHead;
    const currentTag = nextRelease.gitTag || nextRelease.gitHead;
    const {host: hostConfig, linkCompare, linkReferences, commit: commitConfig, issue: issueConfig} = pluginConfig;
    const changelogContext = merge({
      version: nextRelease.version,
      host: format({protocol, hostname, port}),
      owner,
      repository,
      previousTag,
      currentTag,
      linkCompare: currentTag && previousTag,
      issue,
      commit,
      packageData: (await readPkgUp({normalize: false, cwd}) || {}).packageJson
    }, {host: hostConfig, linkCompare, linkReferences, commit: commitConfig, issue: issueConfig});
    debug("version: %o", changelogContext.version);
    debug("host: %o", changelogContext.hostname);
    debug("owner: %o", changelogContext.owner);
    debug("repository: %o", changelogContext.repository);
    debug("previousTag: %o", changelogContext.previousTag);
    debug("currentTag: %o", changelogContext.currentTag);
    debug("host: %o", changelogContext.host);
    debug("linkReferences: %o", changelogContext.linkReferences);
    debug("issue: %o", changelogContext.issue);
    debug("commit: %o", changelogContext.commit);
    return getStream(intoStream.object(parsedCommits).pipe(writer(changelogContext, writerOpts)));
  }
  module2.exports = {generateNotes: generateNotes2};
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports2, module2) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// node_modules/findup-sync/node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports2, module2) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var isExtglob = require_is_extglob();
  module2.exports = function isGlob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str))
      return true;
    var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
    var match;
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// node_modules/parse-passwd/index.js
var require_parse_passwd = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(content) {
    if (typeof content !== "string") {
      throw new Error("expected a string");
    }
    return content.split("\n").map(user).filter(Boolean);
  };
  function user(line, i) {
    if (!line || !line.length || line.charAt(0) === "#") {
      return null;
    }
    var fields = line.split(":");
    return {
      username: fields[0],
      password: fields[1],
      uid: fields[2],
      gid: fields[3],
      gecos: fields[4],
      homedir: fields[5],
      shell: fields[6]
    };
  }
});

// node_modules/homedir-polyfill/polyfill.js
var require_polyfill = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var parse = require_parse_passwd();
  function homedir() {
    if (process.platform === "win32") {
      if (process.env.USERPROFILE) {
        return process.env.USERPROFILE;
      }
      if (process.env.HOMEDRIVE && process.env.HOMEPATH) {
        return process.env.HOMEDRIVE + process.env.HOMEPATH;
      }
      if (process.env.HOME) {
        return process.env.HOME;
      }
      return null;
    }
    if (process.env.HOME) {
      return process.env.HOME;
    }
    var passwd = tryReadFileSync("/etc/passwd");
    var home = find(parse(passwd), getuid());
    if (home) {
      return home;
    }
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (!user) {
      return null;
    }
    if (process.platform === "darwin") {
      return "/Users/" + user;
    }
    return "/home/" + user;
  }
  function find(arr, uid) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      if (+arr[i].uid === uid) {
        return arr[i].homedir;
      }
    }
  }
  function getuid() {
    if (typeof process.geteuid === "function") {
      return process.geteuid();
    }
    return process.getuid();
  }
  function tryReadFileSync(fp) {
    try {
      return fs.readFileSync(fp, "utf8");
    } catch (err) {
      return "";
    }
  }
  module2.exports = homedir;
});

// node_modules/homedir-polyfill/index.js
var require_homedir_polyfill = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  if (typeof os.homedir !== "undefined") {
    module2.exports = os.homedir;
  } else {
    module2.exports = require_polyfill();
  }
});

// node_modules/expand-tilde/index.js
var require_expand_tilde = __commonJS((exports2, module2) => {
  /*!
   * expand-tilde <https://github.com/jonschlinkert/expand-tilde>
   *
   * Copyright (c) 2015 Jon Schlinkert.
   * Licensed under the MIT license.
   */
  var homedir = require_homedir_polyfill();
  var path = require("path");
  module2.exports = function expandTilde(filepath) {
    var home = homedir();
    if (filepath.charCodeAt(0) === 126) {
      if (filepath.charCodeAt(1) === 43) {
        return path.join(process.cwd(), filepath.slice(2));
      }
      return home ? path.join(home, filepath.slice(1)) : filepath;
    }
    return filepath;
  };
});

// node_modules/ini/ini.js
var require_ini = __commonJS((exports2) => {
  exports2.parse = exports2.decode = decode;
  exports2.stringify = exports2.encode = encode;
  exports2.safe = safe;
  exports2.unsafe = unsafe;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  function encode(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      if (val && Array.isArray(val)) {
        val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + "\n";
        });
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\.");
      var section = (opt.section ? opt.section + "." : "") + nk;
      var child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    });
    return out;
  }
  function dotSplit(str) {
    return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str) {
    var out = {};
    var p = out;
    var section = null;
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
      if (!line || line.match(/^\s*[;#]/))
        return;
      var match = line.match(re);
      if (!match)
        return;
      if (match[1] !== void 0) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = {};
          return;
        }
        p = out[section] = out[section] || {};
        return;
      }
      var key = unsafe(match[2]);
      if (key === "__proto__")
        return;
      var value = match[3] ? unsafe(match[4]) : true;
      switch (value) {
        case "true":
        case "false":
        case "null":
          value = JSON.parse(value);
      }
      if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2);
        if (key === "__proto__")
          return;
        if (!p[key])
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    });
    Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
        return false;
      var parts = dotSplit(k);
      var p2 = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, ".");
      parts.forEach(function(part, _2, __2) {
        if (part === "__proto__")
          return;
        if (!p2[part] || typeof p2[part] !== "object")
          p2[part] = {};
        p2 = p2[part];
      });
      if (p2 === out && nl === l)
        return false;
      p2[nl] = out[k];
      return true;
    }).forEach(function(del, _, __) {
      delete out[del];
    });
    return out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_) {
      }
    } else {
      var esc = false;
      var unesc = "";
      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  }
});

// node_modules/is-windows/index.js
var require_is_windows = __commonJS((exports2, module2) => {
  /*!
   * is-windows <https://github.com/jonschlinkert/is-windows>
   *
   * Copyright © 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  (function(factory) {
    if (exports2 && typeof exports2 === "object" && typeof module2 !== "undefined") {
      module2.exports = factory();
    } else if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof window !== "undefined") {
      window.isWindows = factory();
    } else if (typeof global !== "undefined") {
      global.isWindows = factory();
    } else if (typeof self !== "undefined") {
      self.isWindows = factory();
    } else {
      this.isWindows = factory();
    }
  })(function() {
    "use strict";
    return function isWindows() {
      return process && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env.OSTYPE));
    };
  });
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function checkPathExt(path, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path, options);
  }
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs = require("fs");
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var core2;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core2 = require_windows();
  } else {
    core2 = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core2(path, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path, options) {
    try {
      return core2.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  module2.exports = which;
  which.sync = whichSync;
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  function getNotFoundError(cmd) {
    var er = new Error("not found: " + cmd);
    er.code = "ENOENT";
    return er;
  }
  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || "";
    var pathExt = [""];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = "";
    if (isWindows) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
      pathExt = pathExtExe.split(colon);
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
      pathEnv = [""];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }
  function which(cmd, opt, cb) {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found);
        else
          return cb(getNotFoundError(cmd));
      }
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      ;
      (function E(ii, ll) {
        if (ii === ll)
          return F(i + 1, l);
        var ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, function(er, is) {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return cb(null, p + ext);
          }
          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }
  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is;
        try {
          is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  }
});

// node_modules/global-prefix/index.js
var require_global_prefix = __commonJS((exports2, module2) => {
  /*!
   * global-prefix <https://github.com/jonschlinkert/global-prefix>
   *
   * Copyright (c) 2015-2017 Jon Schlinkert.
   * Licensed under the MIT license.
   */
  "use strict";
  var fs = require("fs");
  var path = require("path");
  var expand = require_expand_tilde();
  var homedir = require_homedir_polyfill();
  var ini = require_ini();
  var prefix;
  function getPrefix() {
    if (process.env.PREFIX) {
      prefix = process.env.PREFIX;
    } else {
      var home = homedir();
      if (home) {
        var userConfig = path.resolve(home, ".npmrc");
        prefix = tryConfigPath(userConfig);
      }
      if (!prefix) {
        var npm = tryNpmPath();
        if (npm) {
          var builtinConfig = path.resolve(npm, "..", "..", "npmrc");
          prefix = tryConfigPath(builtinConfig);
          if (prefix) {
            var globalConfig = path.resolve(prefix, "etc", "npmrc");
            prefix = tryConfigPath(globalConfig) || prefix;
          }
        }
        if (!prefix)
          fallback();
      }
    }
    if (prefix) {
      return expand(prefix);
    }
  }
  function fallback() {
    var isWindows = require_is_windows();
    if (isWindows()) {
      prefix = process.env.APPDATA ? path.join(process.env.APPDATA, "npm") : path.dirname(process.execPath);
    } else {
      prefix = path.dirname(path.dirname(process.execPath));
      if (process.env.DESTDIR) {
        prefix = path.join(process.env.DESTDIR, prefix);
      }
    }
  }
  function tryNpmPath() {
    try {
      return fs.realpathSync(require_which().sync("npm"));
    } catch (err) {
    }
    return null;
  }
  function tryConfigPath(configPath) {
    try {
      var data = fs.readFileSync(configPath, "utf-8");
      var config = ini.parse(data);
      if (config.prefix)
        return config.prefix;
    } catch (err) {
    }
    return null;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: function() {
      return prefix || (prefix = getPrefix());
    }
  });
});

// node_modules/global-modules/index.js
var require_global_modules = __commonJS((exports2, module2) => {
  /*!
   * global-modules <https://github.com/jonschlinkert/global-modules>
   *
   * Copyright (c) 2015-2017 Jon Schlinkert.
   * Licensed under the MIT license.
   */
  "use strict";
  var path = require("path");
  var prefix = require_global_prefix();
  var isWindows = require_is_windows();
  var gm;
  function getPath() {
    if (isWindows()) {
      return path.resolve(prefix, "node_modules");
    }
    return path.resolve(prefix, "lib/node_modules");
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: function() {
      return gm || (gm = getPath());
    }
  });
});

// node_modules/resolve-dir/index.js
var require_resolve_dir = __commonJS((exports2, module2) => {
  /*!
   * resolve-dir <https://github.com/jonschlinkert/resolve-dir>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var path = require("path");
  var expand = require_expand_tilde();
  var gm = require_global_modules();
  module2.exports = function resolveDir(dir) {
    if (dir.charAt(0) === "~") {
      dir = expand(dir);
    }
    if (dir.charAt(0) === "@") {
      dir = path.join(gm, dir.slice(1));
    }
    return dir;
  };
});

// node_modules/detect-file/index.js
var require_detect_file = __commonJS((exports2, module2) => {
  /*!
   * detect-file <https://github.com/doowb/detect-file>
   *
   * Copyright (c) 2016-2017, Brian Woodward.
   * Released under the MIT License.
   */
  "use strict";
  var fs = require("fs");
  var path = require("path");
  module2.exports = function detect(filepath, options) {
    if (!filepath || typeof filepath !== "string") {
      return null;
    }
    if (fs.existsSync(filepath)) {
      return path.resolve(filepath);
    }
    options = options || {};
    if (options.nocase === true) {
      return nocase(filepath);
    }
    return null;
  };
  function nocase(filepath) {
    filepath = path.resolve(filepath);
    var res = tryReaddir(filepath);
    if (res === null) {
      return null;
    }
    if (res.path === filepath) {
      return res.path;
    }
    var upper = filepath.toUpperCase();
    var len = res.files.length;
    var idx = -1;
    while (++idx < len) {
      var fp = path.resolve(res.path, res.files[idx]);
      if (filepath === fp || upper === fp) {
        return fp;
      }
      var fpUpper = fp.toUpperCase();
      if (filepath === fpUpper || upper === fpUpper) {
        return fp;
      }
    }
    return null;
  }
  function tryReaddir(filepath) {
    var ctx = {path: filepath, files: []};
    try {
      ctx.files = fs.readdirSync(filepath);
      return ctx;
    } catch (err) {
    }
    try {
      ctx.path = path.dirname(filepath);
      ctx.files = fs.readdirSync(ctx.path);
      return ctx;
    } catch (err) {
    }
    return null;
  }
});

// node_modules/ret/lib/types.js
var require_types = __commonJS((exports2, module2) => {
  module2.exports = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7
  };
});

// node_modules/ret/lib/sets.js
var require_sets = __commonJS((exports2) => {
  var types = require_types();
  var INTS = function() {
    return [{type: types.RANGE, from: 48, to: 57}];
  };
  var WORDS = function() {
    return [
      {type: types.CHAR, value: 95},
      {type: types.RANGE, from: 97, to: 122},
      {type: types.RANGE, from: 65, to: 90}
    ].concat(INTS());
  };
  var WHITESPACE = function() {
    return [
      {type: types.CHAR, value: 9},
      {type: types.CHAR, value: 10},
      {type: types.CHAR, value: 11},
      {type: types.CHAR, value: 12},
      {type: types.CHAR, value: 13},
      {type: types.CHAR, value: 32},
      {type: types.CHAR, value: 160},
      {type: types.CHAR, value: 5760},
      {type: types.CHAR, value: 6158},
      {type: types.CHAR, value: 8192},
      {type: types.CHAR, value: 8193},
      {type: types.CHAR, value: 8194},
      {type: types.CHAR, value: 8195},
      {type: types.CHAR, value: 8196},
      {type: types.CHAR, value: 8197},
      {type: types.CHAR, value: 8198},
      {type: types.CHAR, value: 8199},
      {type: types.CHAR, value: 8200},
      {type: types.CHAR, value: 8201},
      {type: types.CHAR, value: 8202},
      {type: types.CHAR, value: 8232},
      {type: types.CHAR, value: 8233},
      {type: types.CHAR, value: 8239},
      {type: types.CHAR, value: 8287},
      {type: types.CHAR, value: 12288},
      {type: types.CHAR, value: 65279}
    ];
  };
  var NOTANYCHAR = function() {
    return [
      {type: types.CHAR, value: 10},
      {type: types.CHAR, value: 13},
      {type: types.CHAR, value: 8232},
      {type: types.CHAR, value: 8233}
    ];
  };
  exports2.words = function() {
    return {type: types.SET, set: WORDS(), not: false};
  };
  exports2.notWords = function() {
    return {type: types.SET, set: WORDS(), not: true};
  };
  exports2.ints = function() {
    return {type: types.SET, set: INTS(), not: false};
  };
  exports2.notInts = function() {
    return {type: types.SET, set: INTS(), not: true};
  };
  exports2.whitespace = function() {
    return {type: types.SET, set: WHITESPACE(), not: false};
  };
  exports2.notWhitespace = function() {
    return {type: types.SET, set: WHITESPACE(), not: true};
  };
  exports2.anyChar = function() {
    return {type: types.SET, set: NOTANYCHAR(), not: true};
  };
});

// node_modules/ret/lib/util.js
var require_util4 = __commonJS((exports2) => {
  var types = require_types();
  var sets = require_sets();
  var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  var SLSH = {"0": 0, t: 9, n: 10, v: 11, f: 12, r: 13};
  exports2.strToChars = function(str) {
    var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
    str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
      if (lbs) {
        return s;
      }
      var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
      var c = String.fromCharCode(code);
      if (/[\[\]{}\^$.|?*+()]/.test(c)) {
        c = "\\" + c;
      }
      return c;
    });
    return str;
  };
  exports2.tokenizeClass = function(str, regexpStr) {
    var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
    var rs, c;
    while ((rs = regexp.exec(str)) != null) {
      if (rs[1]) {
        tokens.push(sets.words());
      } else if (rs[2]) {
        tokens.push(sets.ints());
      } else if (rs[3]) {
        tokens.push(sets.whitespace());
      } else if (rs[4]) {
        tokens.push(sets.notWords());
      } else if (rs[5]) {
        tokens.push(sets.notInts());
      } else if (rs[6]) {
        tokens.push(sets.notWhitespace());
      } else if (rs[7]) {
        tokens.push({
          type: types.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
          to: rs[10].charCodeAt(0)
        });
      } else if (c = rs[12]) {
        tokens.push({
          type: types.CHAR,
          value: c.charCodeAt(0)
        });
      } else {
        return [tokens, regexp.lastIndex];
      }
    }
    exports2.error(regexpStr, "Unterminated character class");
  };
  exports2.error = function(regexp, msg) {
    throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
  };
});

// node_modules/ret/lib/positions.js
var require_positions = __commonJS((exports2) => {
  var types = require_types();
  exports2.wordBoundary = function() {
    return {type: types.POSITION, value: "b"};
  };
  exports2.nonWordBoundary = function() {
    return {type: types.POSITION, value: "B"};
  };
  exports2.begin = function() {
    return {type: types.POSITION, value: "^"};
  };
  exports2.end = function() {
    return {type: types.POSITION, value: "$"};
  };
});

// node_modules/ret/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  var util = require_util4();
  var types = require_types();
  var sets = require_sets();
  var positions = require_positions();
  module2.exports = function(regexpStr) {
    var i = 0, l, c, start = {type: types.ROOT, stack: []}, lastGroup = start, last = start.stack, groupStack = [];
    var repeatErr = function(i2) {
      util.error(regexpStr, "Nothing to repeat at column " + (i2 - 1));
    };
    var str = util.strToChars(regexpStr);
    l = str.length;
    while (i < l) {
      c = str[i++];
      switch (c) {
        case "\\":
          c = str[i++];
          switch (c) {
            case "b":
              last.push(positions.wordBoundary());
              break;
            case "B":
              last.push(positions.nonWordBoundary());
              break;
            case "w":
              last.push(sets.words());
              break;
            case "W":
              last.push(sets.notWords());
              break;
            case "d":
              last.push(sets.ints());
              break;
            case "D":
              last.push(sets.notInts());
              break;
            case "s":
              last.push(sets.whitespace());
              break;
            case "S":
              last.push(sets.notWhitespace());
              break;
            default:
              if (/\d/.test(c)) {
                last.push({type: types.REFERENCE, value: parseInt(c, 10)});
              } else {
                last.push({type: types.CHAR, value: c.charCodeAt(0)});
              }
          }
          break;
        case "^":
          last.push(positions.begin());
          break;
        case "$":
          last.push(positions.end());
          break;
        case "[":
          var not;
          if (str[i] === "^") {
            not = true;
            i++;
          } else {
            not = false;
          }
          var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
          i += classTokens[1];
          last.push({
            type: types.SET,
            set: classTokens[0],
            not
          });
          break;
        case ".":
          last.push(sets.anyChar());
          break;
        case "(":
          var group = {
            type: types.GROUP,
            stack: [],
            remember: true
          };
          c = str[i];
          if (c === "?") {
            c = str[i + 1];
            i += 2;
            if (c === "=") {
              group.followedBy = true;
            } else if (c === "!") {
              group.notFollowedBy = true;
            } else if (c !== ":") {
              util.error(regexpStr, "Invalid group, character '" + c + "' after '?' at column " + (i - 1));
            }
            group.remember = false;
          }
          last.push(group);
          groupStack.push(lastGroup);
          lastGroup = group;
          last = group.stack;
          break;
        case ")":
          if (groupStack.length === 0) {
            util.error(regexpStr, "Unmatched ) at column " + (i - 1));
          }
          lastGroup = groupStack.pop();
          last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
          break;
        case "|":
          if (!lastGroup.options) {
            lastGroup.options = [lastGroup.stack];
            delete lastGroup.stack;
          }
          var stack = [];
          lastGroup.options.push(stack);
          last = stack;
          break;
        case "{":
          var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
          if (rs !== null) {
            if (last.length === 0) {
              repeatErr(i);
            }
            min = parseInt(rs[1], 10);
            max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
            i += rs[0].length;
            last.push({
              type: types.REPETITION,
              min,
              max,
              value: last.pop()
            });
          } else {
            last.push({
              type: types.CHAR,
              value: 123
            });
          }
          break;
        case "?":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 0,
            max: 1,
            value: last.pop()
          });
          break;
        case "+":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 1,
            max: Infinity,
            value: last.pop()
          });
          break;
        case "*":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types.REPETITION,
            min: 0,
            max: Infinity,
            value: last.pop()
          });
          break;
        default:
          last.push({
            type: types.CHAR,
            value: c.charCodeAt(0)
          });
      }
    }
    if (groupStack.length !== 0) {
      util.error(regexpStr, "Unterminated group");
    }
    return start;
  };
  module2.exports.types = types;
});

// node_modules/safe-regex/index.js
var require_safe_regex = __commonJS((exports2, module2) => {
  var parse = require_lib5();
  var types = parse.types;
  module2.exports = function(re, opts) {
    if (!opts)
      opts = {};
    var replimit = opts.limit === void 0 ? 25 : opts.limit;
    if (isRegExp(re))
      re = re.source;
    else if (typeof re !== "string")
      re = String(re);
    try {
      re = parse(re);
    } catch (err) {
      return false;
    }
    var reps = 0;
    return function walk(node, starHeight) {
      if (node.type === types.REPETITION) {
        starHeight++;
        reps++;
        if (starHeight > 1)
          return false;
        if (reps > replimit)
          return false;
      }
      if (node.options) {
        for (var i = 0, len = node.options.length; i < len; i++) {
          var ok = walk({stack: node.options[i]}, starHeight);
          if (!ok)
            return false;
        }
      }
      var stack = node.stack || node.value && node.value.stack;
      if (!stack)
        return true;
      for (var i = 0; i < stack.length; i++) {
        var ok = walk(stack[i], starHeight);
        if (!ok)
          return false;
      }
      return true;
    }(re, 0);
  };
  function isRegExp(x) {
    return {}.toString.call(x) === "[object RegExp]";
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS((exports2, module2) => {
  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function isObject(val) {
    return val != null && typeof val === "object" && Array.isArray(val) === false;
  };
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS((exports2, module2) => {
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    if (type === "boolean")
      return "boolean";
    if (type === "string")
      return "string";
    if (type === "number")
      return "number";
    if (type === "symbol")
      return "symbol";
    if (type === "function") {
      return isGeneratorFn(val) ? "generatorfunction" : "function";
    }
    if (isArray(val))
      return "array";
    if (isBuffer(val))
      return "buffer";
    if (isArguments(val))
      return "arguments";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    if (isRegexp(val))
      return "regexp";
    switch (ctorName(val)) {
      case "Symbol":
        return "symbol";
      case "Promise":
        return "promise";
      case "WeakMap":
        return "weakmap";
      case "WeakSet":
        return "weakset";
      case "Map":
        return "map";
      case "Set":
        return "set";
      case "Int8Array":
        return "int8array";
      case "Uint8Array":
        return "uint8array";
      case "Uint8ClampedArray":
        return "uint8clampedarray";
      case "Int16Array":
        return "int16array";
      case "Uint16Array":
        return "uint16array";
      case "Int32Array":
        return "int32array";
      case "Uint32Array":
        return "uint32array";
      case "Float32Array":
        return "float32array";
      case "Float64Array":
        return "float64array";
    }
    if (isGeneratorObj(val)) {
      return "generator";
    }
    type = toString.call(val);
    switch (type) {
      case "[object Object]":
        return "object";
      case "[object Map Iterator]":
        return "mapiterator";
      case "[object Set Iterator]":
        return "setiterator";
      case "[object String Iterator]":
        return "stringiterator";
      case "[object Array Iterator]":
        return "arrayiterator";
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  };
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isArray(val) {
    if (Array.isArray)
      return Array.isArray(val);
    return val instanceof Array;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function isRegexp(val) {
    if (val instanceof RegExp)
      return true;
    return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
  }
  function isGeneratorFn(name, val) {
    return ctorName(name) === "GeneratorFunction";
  }
  function isGeneratorObj(val) {
    return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
  }
  function isArguments(val) {
    try {
      if (typeof val.length === "number" && typeof val.callee === "function") {
        return true;
      }
    } catch (err) {
      if (err.message.indexOf("callee") !== -1) {
        return true;
      }
    }
    return false;
  }
  function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === "function") {
      return val.constructor.isBuffer(val);
    }
    return false;
  }
});

// node_modules/define-property/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor = __commonJS((exports2, module2) => {
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var accessor = {
    get: "function",
    set: "function",
    configurable: "boolean",
    enumerable: "boolean"
  };
  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (has(obj, "value") || has(obj, "writable")) {
      return false;
    }
    if (!has(obj, "get") || typeof obj.get !== "function") {
      return false;
    }
    if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
      return false;
    }
    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  module2.exports = isAccessorDescriptor;
});

// node_modules/define-property/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor = __commonJS((exports2, module2) => {
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  module2.exports = function isDataDescriptor(obj, prop) {
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (!("value" in obj) && !("writable" in obj)) {
      return false;
    }
    for (var key in obj) {
      if (key === "value")
        continue;
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === data[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  };
});

// node_modules/define-property/node_modules/is-descriptor/index.js
var require_is_descriptor = __commonJS((exports2, module2) => {
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var isAccessor = require_is_accessor_descriptor();
  var isData = require_is_data_descriptor();
  module2.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if ("get" in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };
});

// node_modules/define-property/index.js
var require_define_property = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isobject = require_isobject();
  var isDescriptor = require_is_descriptor();
  var define2 = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
  module2.exports = function defineProperty(obj, key, val) {
    if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
      throw new TypeError("expected an object, function, or array");
    }
    if (typeof key !== "string") {
      throw new TypeError('expected "key" to be a string');
    }
    if (isDescriptor(val)) {
      define2(obj, key, val);
      return obj;
    }
    define2(obj, key, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
    return obj;
  };
});

// node_modules/extend-shallow/node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS((exports2, module2) => {
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  function isObjectObject(o) {
    return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
  }
  module2.exports = function isPlainObject(o) {
    var ctor, prot;
    if (isObjectObject(o) === false)
      return false;
    ctor = o.constructor;
    if (typeof ctor !== "function")
      return false;
    prot = ctor.prototype;
    if (isObjectObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  };
});

// node_modules/extend-shallow/node_modules/is-extendable/index.js
var require_is_extendable = __commonJS((exports2, module2) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isPlainObject = require_is_plain_object();
  module2.exports = function isExtendable(val) {
    return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
  };
});

// node_modules/assign-symbols/index.js
var require_assign_symbols = __commonJS((exports2, module2) => {
  /*!
   * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  module2.exports = function(receiver, objects) {
    if (receiver === null || typeof receiver === "undefined") {
      throw new TypeError("expected first argument to be an object.");
    }
    if (typeof objects === "undefined" || typeof Symbol === "undefined") {
      return receiver;
    }
    if (typeof Object.getOwnPropertySymbols !== "function") {
      return receiver;
    }
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var target = Object(receiver);
    var len = arguments.length, i = 0;
    while (++i < len) {
      var provider = Object(arguments[i]);
      var names = Object.getOwnPropertySymbols(provider);
      for (var j = 0; j < names.length; j++) {
        var key = names[j];
        if (isEnumerable.call(provider, key)) {
          target[key] = provider[key];
        }
      }
    }
    return target;
  };
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS((exports2, module2) => {
  "use strict";
  var isExtendable = require_is_extendable();
  var assignSymbols = require_assign_symbols();
  module2.exports = Object.assign || function(obj) {
    if (obj === null || typeof obj === "undefined") {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    if (!isObject(obj)) {
      obj = {};
    }
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isString(val)) {
        val = toObject(val);
      }
      if (isObject(val)) {
        assign(obj, val);
        assignSymbols(obj, val);
      }
    }
    return obj;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function isString(val) {
    return val && typeof val === "string";
  }
  function toObject(str) {
    var obj = {};
    for (var i in str) {
      obj[i] = str[i];
    }
    return obj;
  }
  function isObject(val) {
    return val && typeof val === "object" || isExtendable(val);
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/regex-not/index.js
var require_regex_not = __commonJS((exports2, module2) => {
  "use strict";
  var extend = require_extend_shallow();
  var safe = require_safe_regex();
  function toRegex(pattern, options) {
    return new RegExp(toRegex.create(pattern, options));
  }
  toRegex.create = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    var opts = extend({}, options);
    if (opts.contains === true) {
      opts.strictNegate = false;
    }
    var open = opts.strictOpen !== false ? "^" : "";
    var close = opts.strictClose !== false ? "$" : "";
    var endChar = opts.endChar ? opts.endChar : "+";
    var str = pattern;
    if (opts.strictNegate === false) {
      str = "(?:(?!(?:" + pattern + ")).)" + endChar;
    } else {
      str = "(?:(?!^(?:" + pattern + ")$).)" + endChar;
    }
    var res = open + str + close;
    if (opts.safe === true && safe(res) === false) {
      throw new Error("potentially unsafe regular expression: " + res);
    }
    return res;
  };
  module2.exports = toRegex;
});

// node_modules/to-regex/index.js
var require_to_regex = __commonJS((exports2, module2) => {
  "use strict";
  var safe = require_safe_regex();
  var define2 = require_define_property();
  var extend = require_extend_shallow();
  var not = require_regex_not();
  var MAX_LENGTH = 1024 * 64;
  var cache = {};
  module2.exports = function(patterns, options) {
    if (!Array.isArray(patterns)) {
      return makeRe(patterns, options);
    }
    return makeRe(patterns.join("|"), options);
  };
  function makeRe(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    if (pattern.length > MAX_LENGTH) {
      throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
    }
    var key = pattern;
    if (!options || options && options.cache !== false) {
      key = createKey(pattern, options);
      if (cache.hasOwnProperty(key)) {
        return cache[key];
      }
    }
    var opts = extend({}, options);
    if (opts.contains === true) {
      if (opts.negate === true) {
        opts.strictNegate = false;
      } else {
        opts.strict = false;
      }
    }
    if (opts.strict === false) {
      opts.strictOpen = false;
      opts.strictClose = false;
    }
    var open = opts.strictOpen !== false ? "^" : "";
    var close = opts.strictClose !== false ? "$" : "";
    var flags = opts.flags || "";
    var regex;
    if (opts.nocase === true && !/i/.test(flags)) {
      flags += "i";
    }
    try {
      if (opts.negate || typeof opts.strictNegate === "boolean") {
        pattern = not.create(pattern, opts);
      }
      var str = open + "(?:" + pattern + ")" + close;
      regex = new RegExp(str, flags);
      if (opts.safe === true && safe(regex) === false) {
        throw new Error("potentially unsafe regular expression: " + regex.source);
      }
    } catch (err) {
      if (opts.strictErrors === true || opts.safe === true) {
        err.key = key;
        err.pattern = pattern;
        err.originalOptions = options;
        err.createdOptions = opts;
        throw err;
      }
      try {
        regex = new RegExp("^" + pattern.replace(/(\W)/g, "\\$1") + "$");
      } catch (err2) {
        regex = /.^/;
      }
    }
    if (opts.cache !== false) {
      memoize(regex, key, pattern, opts);
    }
    return regex;
  }
  function memoize(regex, key, pattern, options) {
    define2(regex, "cached", true);
    define2(regex, "pattern", pattern);
    define2(regex, "options", options);
    define2(regex, "key", key);
    cache[key] = regex;
  }
  function createKey(pattern, options) {
    if (!options)
      return pattern;
    var key = pattern;
    for (var prop in options) {
      if (options.hasOwnProperty(prop)) {
        key += ";" + prop + "=" + String(options[prop]);
      }
    }
    return key;
  }
  module2.exports.makeRe = makeRe;
});

// node_modules/array-unique/index.js
var require_array_unique = __commonJS((exports2, module2) => {
  /*!
   * array-unique <https://github.com/jonschlinkert/array-unique>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  module2.exports = function unique(arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError("array-unique expects an array.");
    }
    var len = arr.length;
    var i = -1;
    while (i++ < len) {
      var j = i + 1;
      for (; j < arr.length; ++j) {
        if (arr[i] === arr[j]) {
          arr.splice(j--, 1);
        }
      }
    }
    return arr;
  };
  module2.exports.immutable = function uniqueImmutable(arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError("array-unique expects an array.");
    }
    var arrLen = arr.length;
    var newArr = new Array(arrLen);
    for (var i = 0; i < arrLen; i++) {
      newArr[i] = arr[i];
    }
    return module2.exports(newArr);
  };
});

// node_modules/is-extendable/index.js
var require_is_extendable2 = __commonJS((exports2, module2) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  module2.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  };
});

// node_modules/findup-sync/node_modules/braces/node_modules/extend-shallow/index.js
var require_extend_shallow2 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/split-string/index.js
var require_split_string = __commonJS((exports2, module2) => {
  /*!
   * split-string <https://github.com/jonschlinkert/split-string>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var extend = require_extend_shallow();
  module2.exports = function(str, options, fn) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (typeof options === "function") {
      fn = options;
      options = null;
    }
    if (typeof options === "string") {
      options = {sep: options};
    }
    var opts = extend({sep: "."}, options);
    var quotes = opts.quotes || ['"', "'", "`"];
    var brackets;
    if (opts.brackets === true) {
      brackets = {
        "<": ">",
        "(": ")",
        "[": "]",
        "{": "}"
      };
    } else if (opts.brackets) {
      brackets = opts.brackets;
    }
    var tokens = [];
    var stack = [];
    var arr = [""];
    var sep = opts.sep;
    var len = str.length;
    var idx = -1;
    var closeIdx;
    function expected() {
      if (brackets && stack.length) {
        return brackets[stack[stack.length - 1]];
      }
    }
    while (++idx < len) {
      var ch = str[idx];
      var next = str[idx + 1];
      var tok = {val: ch, idx, arr, str};
      tokens.push(tok);
      if (ch === "\\") {
        tok.val = keepEscaping(opts, str, idx) === true ? ch + next : next;
        tok.escaped = true;
        if (typeof fn === "function") {
          fn(tok);
        }
        arr[arr.length - 1] += tok.val;
        idx++;
        continue;
      }
      if (brackets && brackets[ch]) {
        stack.push(ch);
        var e = expected();
        var i = idx + 1;
        if (str.indexOf(e, i + 1) !== -1) {
          while (stack.length && i < len) {
            var s = str[++i];
            if (s === "\\") {
              s++;
              continue;
            }
            if (quotes.indexOf(s) !== -1) {
              i = getClosingQuote(str, s, i + 1);
              continue;
            }
            e = expected();
            if (stack.length && str.indexOf(e, i + 1) === -1) {
              break;
            }
            if (brackets[s]) {
              stack.push(s);
              continue;
            }
            if (e === s) {
              stack.pop();
            }
          }
        }
        closeIdx = i;
        if (closeIdx === -1) {
          arr[arr.length - 1] += ch;
          continue;
        }
        ch = str.slice(idx, closeIdx + 1);
        tok.val = ch;
        tok.idx = idx = closeIdx;
      }
      if (quotes.indexOf(ch) !== -1) {
        closeIdx = getClosingQuote(str, ch, idx + 1);
        if (closeIdx === -1) {
          arr[arr.length - 1] += ch;
          continue;
        }
        if (keepQuotes(ch, opts) === true) {
          ch = str.slice(idx, closeIdx + 1);
        } else {
          ch = str.slice(idx + 1, closeIdx);
        }
        tok.val = ch;
        tok.idx = idx = closeIdx;
      }
      if (typeof fn === "function") {
        fn(tok, tokens);
        ch = tok.val;
        idx = tok.idx;
      }
      if (tok.val === sep && tok.split !== false) {
        arr.push("");
        continue;
      }
      arr[arr.length - 1] += tok.val;
    }
    return arr;
  };
  function getClosingQuote(str, ch, i, brackets) {
    var idx = str.indexOf(ch, i);
    if (str.charAt(idx - 1) === "\\") {
      return getClosingQuote(str, ch, idx + 1);
    }
    return idx;
  }
  function keepQuotes(ch, opts) {
    if (opts.keepDoubleQuotes === true && ch === '"')
      return true;
    if (opts.keepSingleQuotes === true && ch === "'")
      return true;
    return opts.keepQuotes;
  }
  function keepEscaping(opts, str, idx) {
    if (typeof opts.keepEscaping === "function") {
      return opts.keepEscaping(str, idx);
    }
    return opts.keepEscaping === true || str[idx + 1] === "\\";
  }
});

// node_modules/arr-flatten/index.js
var require_arr_flatten = __commonJS((exports2, module2) => {
  /*!
   * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function(arr) {
    return flat(arr, []);
  };
  function flat(arr, res) {
    var i = 0, cur;
    var len = arr.length;
    for (; i < len; i++) {
      cur = arr[i];
      Array.isArray(cur) ? flat(cur, res) : res.push(cur);
    }
    return res;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS((exports2, module2) => {
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module2.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
  };
  function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
  }
});

// node_modules/findup-sync/node_modules/is-number/node_modules/kind-of/index.js
var require_kind_of2 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/findup-sync/node_modules/is-number/index.js
var require_is_number2 = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of2();
  module2.exports = function isNumber(num) {
    var type = typeOf(num);
    if (type === "string") {
      if (!num.trim())
        return false;
    } else if (type !== "number") {
      return false;
    }
    return num - num + 1 >= 0;
  };
});

// node_modules/findup-sync/node_modules/fill-range/node_modules/extend-shallow/index.js
var require_extend_shallow3 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS((exports2, module2) => {
  /*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var res = "";
  var cache;
  module2.exports = repeat;
  function repeat(str, num) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (num === 1)
      return str;
    if (num === 2)
      return str + str;
    var max = str.length * num;
    if (cache !== str || typeof cache === "undefined") {
      cache = str;
      res = "";
    } else if (res.length >= max) {
      return res.substr(0, max);
    }
    while (max > res.length && num > 1) {
      if (num & 1) {
        res += str;
      }
      num >>= 1;
      str += str;
    }
    res += str;
    res = res.substr(0, max);
    return res;
  }
});

// node_modules/findup-sync/node_modules/to-regex-range/index.js
var require_to_regex_range2 = __commonJS((exports2, module2) => {
  /*!
   * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var repeat = require_repeat_string();
  var isNumber = require_is_number2();
  var cache = {};
  function toRegexRange(min, max, options) {
    if (isNumber(min) === false) {
      throw new RangeError("toRegexRange: first argument is invalid.");
    }
    if (typeof max === "undefined" || min === max) {
      return String(min);
    }
    if (isNumber(max) === false) {
      throw new RangeError("toRegexRange: second argument is invalid.");
    }
    options = options || {};
    var relax = String(options.relaxZeros);
    var shorthand = String(options.shorthand);
    var capture = String(options.capture);
    var key = min + ":" + max + "=" + relax + shorthand + capture;
    if (cache.hasOwnProperty(key)) {
      return cache[key].result;
    }
    var a = Math.min(min, max);
    var b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
      var result = min + "|" + max;
      if (options.capture) {
        return "(" + result + ")";
      }
      return result;
    }
    var isPadded = padding(min) || padding(max);
    var positives = [];
    var negatives = [];
    var tok = {min, max, a, b};
    if (isPadded) {
      tok.isPadded = isPadded;
      tok.maxLen = String(tok.max).length;
    }
    if (a < 0) {
      var newMin = b < 0 ? Math.abs(b) : 1;
      var newMax = Math.abs(a);
      negatives = splitToPatterns(newMin, newMax, tok, options);
      a = tok.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, tok, options);
    }
    tok.negatives = negatives;
    tok.positives = positives;
    tok.result = siftPatterns(negatives, positives, options);
    if (options.capture && positives.length + negatives.length > 1) {
      tok.result = "(" + tok.result + ")";
    }
    cache[key] = tok;
    return tok.result;
  }
  function siftPatterns(neg, pos, options) {
    var onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    var onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    var intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min, max) {
    min = Number(min);
    max = Number(max);
    var nines = 1;
    var stops = [max];
    var stop = +countNines(min, nines);
    while (min <= stop && stop <= max) {
      stops = push(stops, stop);
      nines += 1;
      stop = +countNines(min, nines);
    }
    var zeros = 1;
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
      stops = push(stops, stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: String(start), digits: []};
    }
    var zipped = zip(String(start), String(stop));
    var len = zipped.length, i = -1;
    var pattern = "";
    var digits = 0;
    while (++i < len) {
      var numbers = zipped[i];
      var startDigit = numbers[0];
      var stopDigit = numbers[1];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit);
      } else {
        digits += 1;
      }
    }
    if (digits) {
      pattern += options.shorthand ? "\\d" : "[0-9]";
    }
    return {pattern, digits: [digits]};
  }
  function splitToPatterns(min, max, tok, options) {
    var ranges = splitToRanges(min, max);
    var len = ranges.length;
    var idx = -1;
    var tokens = [];
    var start = min;
    var prev;
    while (++idx < len) {
      var range = ranges[idx];
      var obj = rangeToPattern(start, range, options);
      var zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.digits.length > 1) {
          prev.digits.pop();
        }
        prev.digits.push(obj.digits[0]);
        prev.string = prev.pattern + toQuantifier(prev.digits);
        start = range + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(range, tok);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
      tokens.push(obj);
      start = range + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    var res = [];
    for (var i = 0; i < arr.length; i++) {
      var tok = arr[i];
      var ele = tok.string;
      if (options.relaxZeros !== false) {
        if (prefix === "-" && ele.charAt(0) === "0") {
          if (ele.charAt(1) === "{") {
            ele = "0*" + ele.replace(/^0\{\d+\}/, "");
          } else {
            ele = "0*" + ele.slice(1);
          }
        }
      }
      if (!intersection && !contains(comparison, "string", ele)) {
        res.push(prefix + ele);
      }
      if (intersection && contains(comparison, "string", ele)) {
        res.push(prefix + ele);
      }
    }
    return res;
  }
  function zip(a, b) {
    var arr = [];
    for (var ch in a)
      arr.push([a[ch], b[ch]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function push(arr, ele) {
    if (arr.indexOf(ele) === -1)
      arr.push(ele);
    return arr;
  }
  function contains(arr, key, val) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i][key] === val) {
        return true;
      }
    }
    return false;
  }
  function countNines(min, len) {
    return String(min).slice(0, -len) + repeat("9", len);
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    var start = digits[0];
    var stop = digits[1] ? "," + digits[1] : "";
    if (!stop && (!start || start === 1)) {
      return "";
    }
    return "{" + start + stop + "}";
  }
  function toCharacterClass(a, b) {
    return "[" + a + (b - a === 1 ? "" : "-") + b + "]";
  }
  function padding(str) {
    return /^-?(0+)\d/.exec(str);
  }
  function padZeros(val, tok) {
    if (tok.isPadded) {
      var diff = Math.abs(tok.maxLen - String(val).length);
      switch (diff) {
        case 0:
          return "";
        case 1:
          return "0";
        default: {
          return "0{" + diff + "}";
        }
      }
    }
    return val;
  }
  module2.exports = toRegexRange;
});

// node_modules/findup-sync/node_modules/fill-range/index.js
var require_fill_range2 = __commonJS((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var util = require("util");
  var isNumber = require_is_number2();
  var extend = require_extend_shallow3();
  var repeat = require_repeat_string();
  var toRegex = require_to_regex_range2();
  function fillRange(start, stop, step, options) {
    if (typeof start === "undefined") {
      return [];
    }
    if (typeof stop === "undefined" || start === stop) {
      var isString = typeof start === "string";
      if (isNumber(start) && !toNumber(start)) {
        return [isString ? "0" : 0];
      }
      return [start];
    }
    if (typeof step !== "number" && typeof step !== "string") {
      options = step;
      step = void 0;
    }
    if (typeof options === "function") {
      options = {transform: options};
    }
    var opts = extend({step}, options);
    if (opts.step && !isValidNumber(opts.step)) {
      if (opts.strictRanges === true) {
        throw new TypeError("expected options.step to be a number");
      }
      return [];
    }
    opts.isNumber = isValidNumber(start) && isValidNumber(stop);
    if (!opts.isNumber && !isValid(start, stop)) {
      if (opts.strictRanges === true) {
        throw new RangeError("invalid range arguments: " + util.inspect([start, stop]));
      }
      return [];
    }
    opts.isPadded = isPadded(start) || isPadded(stop);
    opts.toString = opts.stringify || typeof opts.step === "string" || typeof start === "string" || typeof stop === "string" || !opts.isNumber;
    if (opts.isPadded) {
      opts.maxLength = Math.max(String(start).length, String(stop).length);
    }
    if (typeof opts.optimize === "boolean")
      opts.toRegex = opts.optimize;
    if (typeof opts.makeRe === "boolean")
      opts.toRegex = opts.makeRe;
    return expand(start, stop, opts);
  }
  function expand(start, stop, options) {
    var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
    var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);
    var step = Math.abs(toNumber(options.step)) || 1;
    if (options.toRegex && step === 1) {
      return toRange(a, b, start, stop, options);
    }
    var zero = {greater: [], lesser: []};
    var asc = a < b;
    var arr = new Array(Math.round((asc ? b - a : a - b) / step));
    var idx = 0;
    while (asc ? a <= b : a >= b) {
      var val = options.isNumber ? a : String.fromCharCode(a);
      if (options.toRegex && (val >= 0 || !options.isNumber)) {
        zero.greater.push(val);
      } else {
        zero.lesser.push(Math.abs(val));
      }
      if (options.isPadded) {
        val = zeros(val, options);
      }
      if (options.toString) {
        val = String(val);
      }
      if (typeof options.transform === "function") {
        arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
      } else {
        arr[idx++] = val;
      }
      if (asc) {
        a += step;
      } else {
        a -= step;
      }
    }
    if (options.toRegex === true) {
      return toSequence(arr, zero, options);
    }
    return arr;
  }
  function toRange(a, b, start, stop, options) {
    if (options.isPadded) {
      return toRegex(start, stop, options);
    }
    if (options.isNumber) {
      return toRegex(Math.min(a, b), Math.max(a, b), options);
    }
    var start = String.fromCharCode(Math.min(a, b));
    var stop = String.fromCharCode(Math.max(a, b));
    return "[" + start + "-" + stop + "]";
  }
  function toSequence(arr, zeros2, options) {
    var greater = "", lesser = "";
    if (zeros2.greater.length) {
      greater = zeros2.greater.join("|");
    }
    if (zeros2.lesser.length) {
      lesser = "-(" + zeros2.lesser.join("|") + ")";
    }
    var res = greater && lesser ? greater + "|" + lesser : greater || lesser;
    if (options.capture) {
      return "(" + res + ")";
    }
    return res;
  }
  function zeros(val, options) {
    if (options.isPadded) {
      var str = String(val);
      var len = str.length;
      var dash = "";
      if (str.charAt(0) === "-") {
        dash = "-";
        str = str.slice(1);
      }
      var diff = options.maxLength - len;
      var pad = repeat("0", diff);
      val = dash + pad + str;
    }
    if (options.stringify) {
      return String(val);
    }
    return val;
  }
  function toNumber(val) {
    return Number(val) || 0;
  }
  function isPadded(str) {
    return /^-?0\d/.test(str);
  }
  function isValid(min, max) {
    return (isValidNumber(min) || isValidLetter(min)) && (isValidNumber(max) || isValidLetter(max));
  }
  function isValidLetter(ch) {
    return typeof ch === "string" && ch.length === 1 && /^\w+$/.test(ch);
  }
  function isValidNumber(n) {
    return isNumber(n) && !/\./.test(n);
  }
  module2.exports = fillRange;
});

// node_modules/repeat-element/index.js
var require_repeat_element = __commonJS((exports2, module2) => {
  /*!
   * repeat-element <https://github.com/jonschlinkert/repeat-element>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Licensed under the MIT license.
   */
  "use strict";
  module2.exports = function repeat(ele, num) {
    var arr = new Array(num);
    for (var i = 0; i < num; i++) {
      arr[i] = ele;
    }
    return arr;
  };
});

// node_modules/findup-sync/node_modules/braces/lib/utils.js
var require_utils5 = __commonJS((exports2, module2) => {
  "use strict";
  var splitString = require_split_string();
  var utils2 = module2.exports;
  utils2.extend = require_extend_shallow2();
  utils2.flatten = require_arr_flatten();
  utils2.isObject = require_isobject();
  utils2.fillRange = require_fill_range2();
  utils2.repeat = require_repeat_element();
  utils2.unique = require_array_unique();
  utils2.define = function(obj, key, val) {
    Object.defineProperty(obj, key, {
      writable: true,
      configurable: true,
      enumerable: false,
      value: val
    });
  };
  utils2.isEmptySets = function(str) {
    return /^(?:\{,\})+$/.test(str);
  };
  utils2.isQuotedString = function(str) {
    var open = str.charAt(0);
    if (open === "'" || open === '"' || open === "`") {
      return str.slice(-1) === open;
    }
    return false;
  };
  utils2.createKey = function(pattern, options) {
    var id = pattern;
    if (typeof options === "undefined") {
      return id;
    }
    var keys = Object.keys(options);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      id += ";" + key + "=" + String(options[key]);
    }
    return id;
  };
  utils2.createOptions = function(options) {
    var opts = utils2.extend.apply(null, arguments);
    if (typeof opts.expand === "boolean") {
      opts.optimize = !opts.expand;
    }
    if (typeof opts.optimize === "boolean") {
      opts.expand = !opts.optimize;
    }
    if (opts.optimize === true) {
      opts.makeRe = true;
    }
    return opts;
  };
  utils2.join = function(a, b, options) {
    options = options || {};
    a = utils2.arrayify(a);
    b = utils2.arrayify(b);
    if (!a.length)
      return b;
    if (!b.length)
      return a;
    var len = a.length;
    var idx = -1;
    var arr = [];
    while (++idx < len) {
      var val = a[idx];
      if (Array.isArray(val)) {
        for (var i = 0; i < val.length; i++) {
          val[i] = utils2.join(val[i], b, options);
        }
        arr.push(val);
        continue;
      }
      for (var j = 0; j < b.length; j++) {
        var bval = b[j];
        if (Array.isArray(bval)) {
          arr.push(utils2.join(val, bval, options));
        } else {
          arr.push(val + bval);
        }
      }
    }
    return arr;
  };
  utils2.split = function(str, options) {
    var opts = utils2.extend({sep: ","}, options);
    if (typeof opts.keepQuotes !== "boolean") {
      opts.keepQuotes = true;
    }
    if (opts.unescape === false) {
      opts.keepEscaping = true;
    }
    return splitString(str, opts, utils2.escapeBrackets(opts));
  };
  utils2.expand = function(str, options) {
    var opts = utils2.extend({rangeLimit: 1e4}, options);
    var segs = utils2.split(str, opts);
    var tok = {segs};
    if (utils2.isQuotedString(str)) {
      return tok;
    }
    if (opts.rangeLimit === true) {
      opts.rangeLimit = 1e4;
    }
    if (segs.length > 1) {
      if (opts.optimize === false) {
        tok.val = segs[0];
        return tok;
      }
      tok.segs = utils2.stringifyArray(tok.segs);
    } else if (segs.length === 1) {
      var arr = str.split("..");
      if (arr.length === 1) {
        tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
        tok.segs = [];
        return tok;
      }
      if (arr.length === 2 && arr[0] === arr[1]) {
        tok.escaped = true;
        tok.val = arr[0];
        tok.segs = [];
        return tok;
      }
      if (arr.length > 1) {
        if (opts.optimize !== false) {
          opts.optimize = true;
          delete opts.expand;
        }
        if (opts.optimize !== true) {
          var min = Math.min(arr[0], arr[1]);
          var max = Math.max(arr[0], arr[1]);
          var step = arr[2] || 1;
          if (opts.rangeLimit !== false && (max - min) / step >= opts.rangeLimit) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
        }
        arr.push(opts);
        tok.segs = utils2.fillRange.apply(null, arr);
        if (!tok.segs.length) {
          tok.escaped = true;
          tok.val = str;
          return tok;
        }
        if (opts.optimize === true) {
          tok.segs = utils2.stringifyArray(tok.segs);
        }
        if (tok.segs === "") {
          tok.val = str;
        } else {
          tok.val = tok.segs[0];
        }
        return tok;
      }
    } else {
      tok.val = str;
    }
    return tok;
  };
  utils2.escapeBrackets = function(options) {
    return function(tok) {
      if (tok.escaped && tok.val === "b") {
        tok.val = "\\b";
        return;
      }
      if (tok.val !== "(" && tok.val !== "[")
        return;
      var opts = utils2.extend({}, options);
      var brackets = [];
      var parens = [];
      var stack = [];
      var val = tok.val;
      var str = tok.str;
      var i = tok.idx - 1;
      while (++i < str.length) {
        var ch = str[i];
        if (ch === "\\") {
          val += (opts.keepEscaping === false ? "" : ch) + str[++i];
          continue;
        }
        if (ch === "(") {
          parens.push(ch);
          stack.push(ch);
        }
        if (ch === "[") {
          brackets.push(ch);
          stack.push(ch);
        }
        if (ch === ")") {
          parens.pop();
          stack.pop();
          if (!stack.length) {
            val += ch;
            break;
          }
        }
        if (ch === "]") {
          brackets.pop();
          stack.pop();
          if (!stack.length) {
            val += ch;
            break;
          }
        }
        val += ch;
      }
      tok.split = false;
      tok.val = val.slice(1);
      tok.idx = i;
    };
  };
  utils2.isQuantifier = function(str) {
    return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
  };
  utils2.stringifyArray = function(arr) {
    return [utils2.arrayify(arr).join("|")];
  };
  utils2.arrayify = function(arr) {
    if (typeof arr === "undefined") {
      return [];
    }
    if (typeof arr === "string") {
      return [arr];
    }
    return arr;
  };
  utils2.isString = function(str) {
    return str != null && typeof str === "string";
  };
  utils2.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };
  utils2.escapeRegex = function(str) {
    return str.replace(/\\?([!^*?()[\]{}+?/])/g, "\\$1");
  };
});

// node_modules/findup-sync/node_modules/braces/lib/compilers.js
var require_compilers = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = require_utils5();
  module2.exports = function(braces, options) {
    braces.compiler.set("bos", function() {
      if (this.output)
        return;
      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
      this.ast.count = 1;
    }).set("bracket", function(node) {
      var close = node.close;
      var open = !node.escaped ? "[" : "\\[";
      var negated = node.negated;
      var inner = node.inner;
      inner = inner.replace(/\\(?=[\\\w]|$)/g, "\\\\");
      if (inner === "]-") {
        inner = "\\]\\-";
      }
      if (negated && inner.indexOf(".") === -1) {
        inner += ".";
      }
      if (negated && inner.indexOf("/") === -1) {
        inner += "/";
      }
      var val = open + negated + inner + close;
      var queue = node.parent.queue;
      var last = utils2.arrayify(queue.pop());
      queue.push(utils2.join(last, val));
      queue.push.apply(queue, []);
    }).set("brace", function(node) {
      node.queue = isEscaped(node) ? [node.val] : [];
      node.count = 1;
      return this.mapVisit(node.nodes);
    }).set("brace.open", function(node) {
      node.parent.open = node.val;
    }).set("text", function(node) {
      var queue = node.parent.queue;
      var escaped = node.escaped;
      var segs = [node.val];
      if (node.optimize === false) {
        options = utils2.extend({}, options, {optimize: false});
      }
      if (node.multiplier > 1) {
        node.parent.count *= node.multiplier;
      }
      if (options.quantifiers === true && utils2.isQuantifier(node.val)) {
        escaped = true;
      } else if (node.val.length > 1) {
        if (isType(node.parent, "brace") && !isEscaped(node)) {
          var expanded = utils2.expand(node.val, options);
          segs = expanded.segs;
          if (expanded.isOptimized) {
            node.parent.isOptimized = true;
          }
          if (!segs.length) {
            var val = expanded.val || node.val;
            if (options.unescape !== false) {
              val = val.replace(/\\([,.])/g, "$1");
              val = val.replace(/["'`]/g, "");
            }
            segs = [val];
            escaped = true;
          }
        }
      } else if (node.val === ",") {
        if (options.expand) {
          node.parent.queue.push([""]);
          segs = [""];
        } else {
          segs = ["|"];
        }
      } else {
        escaped = true;
      }
      if (escaped && isType(node.parent, "brace")) {
        if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
          node.parent.escaped = true;
        } else if (node.parent.length <= 3) {
          node.parent.escaped = true;
        }
      }
      if (!hasQueue(node.parent)) {
        node.parent.queue = segs;
        return;
      }
      var last = utils2.arrayify(queue.pop());
      if (node.parent.count > 1 && options.expand) {
        last = multiply(last, node.parent.count);
        node.parent.count = 1;
      }
      queue.push(utils2.join(utils2.flatten(last), segs.shift()));
      queue.push.apply(queue, segs);
    }).set("brace.close", function(node) {
      var queue = node.parent.queue;
      var prev = node.parent.parent;
      var last = prev.queue.pop();
      var open = node.parent.open;
      var close = node.val;
      if (open && close && isOptimized(node, options)) {
        open = "(";
        close = ")";
      }
      var ele = utils2.last(queue);
      if (node.parent.count > 1 && options.expand) {
        ele = multiply(queue.pop(), node.parent.count);
        node.parent.count = 1;
        queue.push(ele);
      }
      if (close && typeof ele === "string" && ele.length === 1) {
        open = "";
        close = "";
      }
      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
        queue.push(utils2.join(open, queue.pop() || ""));
        queue = utils2.flatten(utils2.join(queue, close));
      }
      if (typeof last === "undefined") {
        prev.queue = [queue];
      } else {
        prev.queue.push(utils2.flatten(utils2.join(last, queue)));
      }
    }).set("eos", function(node) {
      if (this.input)
        return;
      if (options.optimize !== false) {
        this.output = utils2.last(utils2.flatten(this.ast.queue));
      } else if (Array.isArray(utils2.last(this.ast.queue))) {
        this.output = utils2.flatten(this.ast.queue.pop());
      } else {
        this.output = utils2.flatten(this.ast.queue);
      }
      if (node.parent.count > 1 && options.expand) {
        this.output = multiply(this.output, node.parent.count);
      }
      this.output = utils2.arrayify(this.output);
      this.ast.queue = [];
    });
  };
  function multiply(queue, n, options) {
    return utils2.flatten(utils2.repeat(utils2.arrayify(queue), n));
  }
  function isEscaped(node) {
    return node.escaped === true;
  }
  function isOptimized(node, options) {
    if (node.parent.isOptimized)
      return true;
    return isType(node.parent, "brace") && !isEscaped(node.parent) && options.expand !== true;
  }
  function isLiteralBrace(node, options) {
    return isEscaped(node.parent) || options.optimize !== false;
  }
  function noInner(node, type) {
    if (node.parent.queue.length === 1) {
      return true;
    }
    var nodes = node.parent.nodes;
    return nodes.length === 3 && isType(nodes[0], "brace.open") && !isType(nodes[1], "text") && isType(nodes[2], "brace.close");
  }
  function isType(node, type) {
    return typeof node !== "undefined" && node.type === type;
  }
  function hasQueue(node) {
    return Array.isArray(node.queue) && node.queue.length;
  }
});

// node_modules/snapdragon-node/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor2 = __commonJS((exports2, module2) => {
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var accessor = {
    get: "function",
    set: "function",
    configurable: "boolean",
    enumerable: "boolean"
  };
  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (has(obj, "value") || has(obj, "writable")) {
      return false;
    }
    if (!has(obj, "get") || typeof obj.get !== "function") {
      return false;
    }
    if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
      return false;
    }
    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  module2.exports = isAccessorDescriptor;
});

// node_modules/snapdragon-node/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor2 = __commonJS((exports2, module2) => {
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  module2.exports = function isDataDescriptor(obj, prop) {
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (!("value" in obj) && !("writable" in obj)) {
      return false;
    }
    for (var key in obj) {
      if (key === "value")
        continue;
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === data[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  };
});

// node_modules/snapdragon-node/node_modules/is-descriptor/index.js
var require_is_descriptor2 = __commonJS((exports2, module2) => {
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var isAccessor = require_is_accessor_descriptor2();
  var isData = require_is_data_descriptor2();
  module2.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if ("get" in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };
});

// node_modules/snapdragon-node/node_modules/define-property/index.js
var require_define_property2 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor2();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/snapdragon-util/node_modules/kind-of/index.js
var require_kind_of3 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/snapdragon-util/index.js
var require_snapdragon_util = __commonJS((exports2, module2) => {
  "use strict";
  var typeOf = require_kind_of3();
  var utils2 = module2.exports;
  utils2.isNode = function(node) {
    return typeOf(node) === "object" && node.isNode === true;
  };
  utils2.noop = function(node) {
    append(this, "", node);
  };
  utils2.identity = function(node) {
    append(this, node.val, node);
  };
  utils2.append = function(val) {
    return function(node) {
      append(this, val, node);
    };
  };
  utils2.toNoop = function(node, nodes) {
    if (nodes) {
      node.nodes = nodes;
    } else {
      delete node.nodes;
      node.type = "text";
      node.val = "";
    }
  };
  utils2.visit = function(node, fn) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isFunction(fn), "expected a visitor function");
    fn(node);
    return node.nodes ? utils2.mapVisit(node, fn) : node;
  };
  utils2.mapVisit = function(node, fn) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isArray(node.nodes), "expected node.nodes to be an array");
    assert(isFunction(fn), "expected a visitor function");
    for (var i = 0; i < node.nodes.length; i++) {
      utils2.visit(node.nodes[i], fn);
    }
    return node;
  };
  utils2.addOpen = function(node, Node, val, filter) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isFunction(Node), "expected Node to be a constructor function");
    if (typeof val === "function") {
      filter = val;
      val = "";
    }
    if (typeof filter === "function" && !filter(node))
      return;
    var open = new Node({type: node.type + ".open", val});
    var unshift = node.unshift || node.unshiftNode;
    if (typeof unshift === "function") {
      unshift.call(node, open);
    } else {
      utils2.unshiftNode(node, open);
    }
    return open;
  };
  utils2.addClose = function(node, Node, val, filter) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isFunction(Node), "expected Node to be a constructor function");
    if (typeof val === "function") {
      filter = val;
      val = "";
    }
    if (typeof filter === "function" && !filter(node))
      return;
    var close = new Node({type: node.type + ".close", val});
    var push = node.push || node.pushNode;
    if (typeof push === "function") {
      push.call(node, close);
    } else {
      utils2.pushNode(node, close);
    }
    return close;
  };
  utils2.wrapNodes = function(node, Node, filter) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isFunction(Node), "expected Node to be a constructor function");
    utils2.addOpen(node, Node, filter);
    utils2.addClose(node, Node, filter);
    return node;
  };
  utils2.pushNode = function(parent, node) {
    assert(utils2.isNode(parent), "expected parent node to be an instance of Node");
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    node.define("parent", parent);
    parent.nodes = parent.nodes || [];
    parent.nodes.push(node);
    return node;
  };
  utils2.unshiftNode = function(parent, node) {
    assert(utils2.isNode(parent), "expected parent node to be an instance of Node");
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    node.define("parent", parent);
    parent.nodes = parent.nodes || [];
    parent.nodes.unshift(node);
  };
  utils2.popNode = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    if (typeof node.pop === "function") {
      return node.pop();
    }
    return node.nodes && node.nodes.pop();
  };
  utils2.shiftNode = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    if (typeof node.shift === "function") {
      return node.shift();
    }
    return node.nodes && node.nodes.shift();
  };
  utils2.removeNode = function(parent, node) {
    assert(utils2.isNode(parent), "expected parent.node to be an instance of Node");
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    if (!parent.nodes) {
      return null;
    }
    if (typeof parent.remove === "function") {
      return parent.remove(node);
    }
    var idx = parent.nodes.indexOf(node);
    if (idx !== -1) {
      return parent.nodes.splice(idx, 1);
    }
  };
  utils2.isType = function(node, type) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    switch (typeOf(type)) {
      case "array":
        var types = type.slice();
        for (var i = 0; i < types.length; i++) {
          if (utils2.isType(node, types[i])) {
            return true;
          }
        }
        return false;
      case "string":
        return node.type === type;
      case "regexp":
        return type.test(node.type);
      default: {
        throw new TypeError('expected "type" to be an array, string or regexp');
      }
    }
  };
  utils2.hasType = function(node, type) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    if (!Array.isArray(node.nodes))
      return false;
    for (var i = 0; i < node.nodes.length; i++) {
      if (utils2.isType(node.nodes[i], type)) {
        return true;
      }
    }
    return false;
  };
  utils2.firstOfType = function(nodes, type) {
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (utils2.isType(node, type)) {
        return node;
      }
    }
  };
  utils2.findNode = function(nodes, type) {
    if (!Array.isArray(nodes)) {
      return null;
    }
    if (typeof type === "number") {
      return nodes[type];
    }
    return utils2.firstOfType(nodes, type);
  };
  utils2.isOpen = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    return node.type.slice(-5) === ".open";
  };
  utils2.isClose = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    return node.type.slice(-6) === ".close";
  };
  utils2.hasOpen = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    var first = node.first || node.nodes ? node.nodes[0] : null;
    if (utils2.isNode(first)) {
      return first.type === node.type + ".open";
    }
    return false;
  };
  utils2.hasClose = function(node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
    if (utils2.isNode(last)) {
      return last.type === node.type + ".close";
    }
    return false;
  };
  utils2.hasOpenAndClose = function(node) {
    return utils2.hasOpen(node) && utils2.hasClose(node);
  };
  utils2.addType = function(state, node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isObject(state), "expected state to be an object");
    var type = node.parent ? node.parent.type : node.type.replace(/\.open$/, "");
    if (!state.hasOwnProperty("inside")) {
      state.inside = {};
    }
    if (!state.inside.hasOwnProperty(type)) {
      state.inside[type] = [];
    }
    var arr = state.inside[type];
    arr.push(node);
    return arr;
  };
  utils2.removeType = function(state, node) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isObject(state), "expected state to be an object");
    var type = node.parent ? node.parent.type : node.type.replace(/\.close$/, "");
    if (state.inside.hasOwnProperty(type)) {
      return state.inside[type].pop();
    }
  };
  utils2.isEmpty = function(node, fn) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    if (!Array.isArray(node.nodes)) {
      if (node.type !== "text") {
        return true;
      }
      if (typeof fn === "function") {
        return fn(node, node.parent);
      }
      return !utils2.trim(node.val);
    }
    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];
      if (utils2.isOpen(child) || utils2.isClose(child)) {
        continue;
      }
      if (!utils2.isEmpty(child, fn)) {
        return false;
      }
    }
    return true;
  };
  utils2.isInsideType = function(state, type) {
    assert(isObject(state), "expected state to be an object");
    assert(isString(type), "expected type to be a string");
    if (!state.hasOwnProperty("inside")) {
      return false;
    }
    if (!state.inside.hasOwnProperty(type)) {
      return false;
    }
    return state.inside[type].length > 0;
  };
  utils2.isInside = function(state, node, type) {
    assert(utils2.isNode(node), "expected node to be an instance of Node");
    assert(isObject(state), "expected state to be an object");
    if (Array.isArray(type)) {
      for (var i = 0; i < type.length; i++) {
        if (utils2.isInside(state, node, type[i])) {
          return true;
        }
      }
      return false;
    }
    var parent = node.parent;
    if (typeof type === "string") {
      return parent && parent.type === type || utils2.isInsideType(state, type);
    }
    if (typeOf(type) === "regexp") {
      if (parent && parent.type && type.test(parent.type)) {
        return true;
      }
      var keys = Object.keys(state.inside);
      var len = keys.length;
      var idx = -1;
      while (++idx < len) {
        var key = keys[idx];
        var val = state.inside[key];
        if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
          return true;
        }
      }
    }
    return false;
  };
  utils2.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };
  utils2.arrayify = function(val) {
    if (typeof val === "string" && val !== "") {
      return [val];
    }
    if (!Array.isArray(val)) {
      return [];
    }
    return val;
  };
  utils2.stringify = function(val) {
    return utils2.arrayify(val).join(",");
  };
  utils2.trim = function(str) {
    return typeof str === "string" ? str.trim() : "";
  };
  function isObject(val) {
    return typeOf(val) === "object";
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isFunction(val) {
    return typeof val === "function";
  }
  function isArray(val) {
    return Array.isArray(val);
  }
  function append(compiler, val, node) {
    if (typeof compiler.append !== "function") {
      return compiler.emit(val, node);
    }
    return compiler.append(val, node);
  }
  function assert(val, message) {
    if (!val)
      throw new Error(message);
  }
});

// node_modules/snapdragon-node/index.js
var require_snapdragon_node = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_isobject();
  var define2 = require_define_property2();
  var utils2 = require_snapdragon_util();
  var ownNames;
  function Node(val, type, parent) {
    if (typeof type !== "string") {
      parent = type;
      type = null;
    }
    define2(this, "parent", parent);
    define2(this, "isNode", true);
    define2(this, "expect", null);
    if (typeof type !== "string" && isObject(val)) {
      lazyKeys();
      var keys = Object.keys(val);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (ownNames.indexOf(key) === -1) {
          this[key] = val[key];
        }
      }
    } else {
      this.type = type;
      this.val = val;
    }
  }
  Node.isNode = function(node) {
    return utils2.isNode(node);
  };
  Node.prototype.define = function(name, val) {
    define2(this, name, val);
    return this;
  };
  Node.prototype.isEmpty = function(fn) {
    return utils2.isEmpty(this, fn);
  };
  Node.prototype.push = function(node) {
    assert(Node.isNode(node), "expected node to be an instance of Node");
    define2(node, "parent", this);
    this.nodes = this.nodes || [];
    return this.nodes.push(node);
  };
  Node.prototype.unshift = function(node) {
    assert(Node.isNode(node), "expected node to be an instance of Node");
    define2(node, "parent", this);
    this.nodes = this.nodes || [];
    return this.nodes.unshift(node);
  };
  Node.prototype.pop = function() {
    return this.nodes && this.nodes.pop();
  };
  Node.prototype.shift = function() {
    return this.nodes && this.nodes.shift();
  };
  Node.prototype.remove = function(node) {
    assert(Node.isNode(node), "expected node to be an instance of Node");
    this.nodes = this.nodes || [];
    var idx = node.index;
    if (idx !== -1) {
      node.index = -1;
      return this.nodes.splice(idx, 1);
    }
    return null;
  };
  Node.prototype.find = function(type) {
    return utils2.findNode(this.nodes, type);
  };
  Node.prototype.isType = function(type) {
    return utils2.isType(this, type);
  };
  Node.prototype.hasType = function(type) {
    return utils2.hasType(this, type);
  };
  Object.defineProperty(Node.prototype, "siblings", {
    set: function() {
      throw new Error("node.siblings is a getter and cannot be defined");
    },
    get: function() {
      return this.parent ? this.parent.nodes : null;
    }
  });
  Object.defineProperty(Node.prototype, "index", {
    set: function(index) {
      define2(this, "idx", index);
    },
    get: function() {
      if (!Array.isArray(this.siblings)) {
        return -1;
      }
      var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
      if (tok !== this) {
        this.idx = this.siblings.indexOf(this);
      }
      return this.idx;
    }
  });
  Object.defineProperty(Node.prototype, "prev", {
    set: function() {
      throw new Error("node.prev is a getter and cannot be defined");
    },
    get: function() {
      if (Array.isArray(this.siblings)) {
        return this.siblings[this.index - 1] || this.parent.prev;
      }
      return null;
    }
  });
  Object.defineProperty(Node.prototype, "next", {
    set: function() {
      throw new Error("node.next is a getter and cannot be defined");
    },
    get: function() {
      if (Array.isArray(this.siblings)) {
        return this.siblings[this.index + 1] || this.parent.next;
      }
      return null;
    }
  });
  Object.defineProperty(Node.prototype, "first", {
    get: function() {
      return this.nodes ? this.nodes[0] : null;
    }
  });
  Object.defineProperty(Node.prototype, "last", {
    get: function() {
      return this.nodes ? utils2.last(this.nodes) : null;
    }
  });
  Object.defineProperty(Node.prototype, "scope", {
    get: function() {
      if (this.isScope !== true) {
        return this.parent ? this.parent.scope : this;
      }
      return this;
    }
  });
  function lazyKeys() {
    if (!ownNames) {
      ownNames = Object.getOwnPropertyNames(Node.prototype);
    }
  }
  function assert(val, message) {
    if (!val)
      throw new Error(message);
  }
  exports2 = module2.exports = Node;
});

// node_modules/findup-sync/node_modules/braces/lib/parsers.js
var require_parsers = __commonJS((exports2, module2) => {
  "use strict";
  var Node = require_snapdragon_node();
  var utils2 = require_utils5();
  module2.exports = function(braces, options) {
    braces.parser.set("bos", function() {
      if (!this.parsed) {
        this.ast = this.nodes[0] = new Node(this.ast);
      }
    }).set("escape", function() {
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|\$\{)/);
      if (!m)
        return;
      var prev = this.prev();
      var last = utils2.last(prev.nodes);
      var node = pos(new Node({
        type: "text",
        multiplier: 1,
        val: m[0]
      }));
      if (node.val === "\\\\") {
        return node;
      }
      if (node.val === "${") {
        var str = this.input;
        var idx = -1;
        var ch;
        while (ch = str[++idx]) {
          this.consume(1);
          node.val += ch;
          if (ch === "\\") {
            node.val += str[++idx];
            continue;
          }
          if (ch === "}") {
            break;
          }
        }
      }
      if (this.options.unescape !== false) {
        node.val = node.val.replace(/\\([{}])/g, "$1");
      }
      if (last.val === '"' && this.input.charAt(0) === '"') {
        last.val = node.val;
        this.consume(1);
        return;
      }
      return concatNodes.call(this, pos, node, prev, options);
    }).set("bracket", function() {
      var isInside = this.isInside("brace");
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
      if (!m)
        return;
      var prev = this.prev();
      var val = m[0];
      var negated = m[1] ? "^" : "";
      var inner = m[2] || "";
      var close = m[3] || "";
      if (isInside && prev.type === "brace") {
        prev.text = prev.text || "";
        prev.text += val;
      }
      var esc = this.input.slice(0, 2);
      if (inner === "" && esc === "\\]") {
        inner += esc;
        this.consume(2);
        var str = this.input;
        var idx = -1;
        var ch;
        while (ch = str[++idx]) {
          this.consume(1);
          if (ch === "]") {
            close = ch;
            break;
          }
          inner += ch;
        }
      }
      return pos(new Node({
        type: "bracket",
        val,
        escaped: close !== "]",
        negated,
        inner,
        close
      }));
    }).set("multiplier", function() {
      var isInside = this.isInside("brace");
      var pos = this.position();
      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
      if (!m)
        return;
      this.multiplier = true;
      var prev = this.prev();
      var val = m[0];
      if (isInside && prev.type === "brace") {
        prev.text = prev.text || "";
        prev.text += val;
      }
      var node = pos(new Node({
        type: "text",
        multiplier: 1,
        match: m,
        val
      }));
      return concatNodes.call(this, pos, node, prev, options);
    }).set("brace.open", function() {
      var pos = this.position();
      var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
      if (!m)
        return;
      var prev = this.prev();
      var last = utils2.last(prev.nodes);
      if (last && last.val && isExtglobChar(last.val.slice(-1))) {
        last.optimize = false;
      }
      var open = pos(new Node({
        type: "brace.open",
        val: m[0]
      }));
      var node = pos(new Node({
        type: "brace",
        nodes: []
      }));
      node.push(open);
      prev.push(node);
      this.push("brace", node);
    }).set("brace.close", function() {
      var pos = this.position();
      var m = this.match(/^\}/);
      if (!m || !m[0])
        return;
      var brace = this.pop("brace");
      var node = pos(new Node({
        type: "brace.close",
        val: m[0]
      }));
      if (!this.isType(brace, "brace")) {
        if (this.options.strict) {
          throw new Error('missing opening "{"');
        }
        node.type = "text";
        node.multiplier = 0;
        node.escaped = true;
        return node;
      }
      var prev = this.prev();
      var last = utils2.last(prev.nodes);
      if (last.text) {
        var lastNode = utils2.last(last.nodes);
        if (lastNode.val === ")" && /[!@*?+]\(/.test(last.text)) {
          var open = last.nodes[0];
          var text = last.nodes[1];
          if (open.type === "brace.open" && text && text.type === "text") {
            text.optimize = false;
          }
        }
      }
      if (brace.nodes.length > 2) {
        var first = brace.nodes[1];
        if (first.type === "text" && first.val === ",") {
          brace.nodes.splice(1, 1);
          brace.nodes.push(first);
        }
      }
      brace.push(node);
    }).set("boundary", function() {
      var pos = this.position();
      var m = this.match(/^[$^](?!\{)/);
      if (!m)
        return;
      return pos(new Node({
        type: "text",
        val: m[0]
      }));
    }).set("nobrace", function() {
      var isInside = this.isInside("brace");
      var pos = this.position();
      var m = this.match(/^\{[^,]?\}/);
      if (!m)
        return;
      var prev = this.prev();
      var val = m[0];
      if (isInside && prev.type === "brace") {
        prev.text = prev.text || "";
        prev.text += val;
      }
      return pos(new Node({
        type: "text",
        multiplier: 0,
        val
      }));
    }).set("text", function() {
      var isInside = this.isInside("brace");
      var pos = this.position();
      var m = this.match(/^((?!\\)[^${}[\]])+/);
      if (!m)
        return;
      var prev = this.prev();
      var val = m[0];
      if (isInside && prev.type === "brace") {
        prev.text = prev.text || "";
        prev.text += val;
      }
      var node = pos(new Node({
        type: "text",
        multiplier: 1,
        val
      }));
      return concatNodes.call(this, pos, node, prev, options);
    });
  };
  function isExtglobChar(ch) {
    return ch === "!" || ch === "@" || ch === "*" || ch === "?" || ch === "+";
  }
  function concatNodes(pos, node, parent, options) {
    node.orig = node.val;
    var prev = this.prev();
    var last = utils2.last(prev.nodes);
    var isEscaped = false;
    if (node.val.length > 1) {
      var a = node.val.charAt(0);
      var b = node.val.slice(-1);
      isEscaped = a === '"' && b === '"' || a === "'" && b === "'" || a === "`" && b === "`";
    }
    if (isEscaped && options.unescape !== false) {
      node.val = node.val.slice(1, node.val.length - 1);
      node.escaped = true;
    }
    if (node.match) {
      var match = node.match[1];
      if (!match || match.indexOf("}") === -1) {
        match = node.match[0];
      }
      var val = match.replace(/\{/g, ",").replace(/\}/g, "");
      node.multiplier *= val.length;
      node.val = "";
    }
    var simpleText = last.type === "text" && last.multiplier === 1 && node.multiplier === 1 && node.val;
    if (simpleText) {
      last.val += node.val;
      return;
    }
    prev.push(node);
  }
});

// node_modules/base/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor3 = __commonJS((exports2, module2) => {
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var accessor = {
    get: "function",
    set: "function",
    configurable: "boolean",
    enumerable: "boolean"
  };
  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (has(obj, "value") || has(obj, "writable")) {
      return false;
    }
    if (!has(obj, "get") || typeof obj.get !== "function") {
      return false;
    }
    if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
      return false;
    }
    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  module2.exports = isAccessorDescriptor;
});

// node_modules/base/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor3 = __commonJS((exports2, module2) => {
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  module2.exports = function isDataDescriptor(obj, prop) {
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (!("value" in obj) && !("writable" in obj)) {
      return false;
    }
    for (var key in obj) {
      if (key === "value")
        continue;
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === data[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  };
});

// node_modules/base/node_modules/is-descriptor/index.js
var require_is_descriptor3 = __commonJS((exports2, module2) => {
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var isAccessor = require_is_accessor_descriptor3();
  var isData = require_is_data_descriptor3();
  module2.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if ("get" in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };
});

// node_modules/base/node_modules/define-property/index.js
var require_define_property3 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor3();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS((exports2, module2) => {
  if (typeof module2 !== "undefined") {
    module2.exports = Emitter;
  }
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (arguments.length == 0) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (arguments.length == 1) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
});

// node_modules/object-visit/index.js
var require_object_visit = __commonJS((exports2, module2) => {
  /*!
   * object-visit <https://github.com/jonschlinkert/object-visit>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  module2.exports = function visit(thisArg, method, target, val) {
    if (!isObject(thisArg) && typeof thisArg !== "function") {
      throw new Error("object-visit expects `thisArg` to be an object.");
    }
    if (typeof method !== "string") {
      throw new Error("object-visit expects `method` name to be a string");
    }
    if (typeof thisArg[method] !== "function") {
      return thisArg;
    }
    var args = [].slice.call(arguments, 3);
    target = target || {};
    for (var key in target) {
      var arr = [key, target[key]].concat(args);
      thisArg[method].apply(thisArg, arr);
    }
    return thisArg;
  };
});

// node_modules/map-visit/index.js
var require_map_visit = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var visit = require_object_visit();
  module2.exports = function mapVisit(collection, method, val) {
    if (isObject(val)) {
      return visit.apply(null, arguments);
    }
    if (!Array.isArray(val)) {
      throw new TypeError("expected an array: " + util.inspect(val));
    }
    var args = [].slice.call(arguments, 3);
    for (var i = 0; i < val.length; i++) {
      var ele = val[i];
      if (isObject(ele)) {
        visit.apply(null, [collection, method, ele].concat(args));
      } else {
        collection[method].apply(collection, [ele].concat(args));
      }
    }
  };
  function isObject(val) {
    return val && (typeof val === "function" || !Array.isArray(val) && typeof val === "object");
  }
});

// node_modules/collection-visit/index.js
var require_collection_visit = __commonJS((exports2, module2) => {
  /*!
   * collection-visit <https://github.com/jonschlinkert/collection-visit>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var visit = require_object_visit();
  var mapVisit = require_map_visit();
  module2.exports = function(collection, method, val) {
    var result;
    if (typeof val === "string" && method in collection) {
      var args = [].slice.call(arguments, 2);
      result = collection[method].apply(collection, args);
    } else if (Array.isArray(val)) {
      result = mapVisit.apply(null, arguments);
    } else {
      result = visit.apply(null, arguments);
    }
    if (typeof result !== "undefined") {
      return result;
    }
    return collection;
  };
});

// node_modules/to-object-path/node_modules/kind-of/index.js
var require_kind_of4 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/to-object-path/index.js
var require_to_object_path = __commonJS((exports2, module2) => {
  /*!
   * to-object-path <https://github.com/jonschlinkert/to-object-path>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of4();
  module2.exports = function toPath(args) {
    if (typeOf(args) !== "arguments") {
      args = arguments;
    }
    return filter(args).join(".");
  };
  function filter(arr) {
    var len = arr.length;
    var idx = -1;
    var res = [];
    while (++idx < len) {
      var ele = arr[idx];
      if (typeOf(ele) === "arguments" || Array.isArray(ele)) {
        res.push.apply(res, filter(ele));
      } else if (typeof ele === "string") {
        res.push(ele);
      }
    }
    return res;
  }
});

// node_modules/arr-union/index.js
var require_arr_union = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function union(init) {
    if (!Array.isArray(init)) {
      throw new TypeError("arr-union expects the first argument to be an array.");
    }
    var len = arguments.length;
    var i = 0;
    while (++i < len) {
      var arg = arguments[i];
      if (!arg)
        continue;
      if (!Array.isArray(arg)) {
        arg = [arg];
      }
      for (var j = 0; j < arg.length; j++) {
        var ele = arg[j];
        if (init.indexOf(ele) >= 0) {
          continue;
        }
        init.push(ele);
      }
    }
    return init;
  };
});

// node_modules/get-value/index.js
var require_get_value = __commonJS((exports2, module2) => {
  /*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function(obj, prop, a, b, c) {
    if (!isObject(obj) || !prop) {
      return obj;
    }
    prop = toString(prop);
    if (a)
      prop += "." + toString(a);
    if (b)
      prop += "." + toString(b);
    if (c)
      prop += "." + toString(c);
    if (prop in obj) {
      return obj[prop];
    }
    var segs = prop.split(".");
    var len = segs.length;
    var i = -1;
    while (obj && ++i < len) {
      var key = segs[i];
      while (key[key.length - 1] === "\\") {
        key = key.slice(0, -1) + "." + segs[++i];
      }
      obj = obj[key];
    }
    return obj;
  };
  function isObject(val) {
    return val !== null && (typeof val === "object" || typeof val === "function");
  }
  function toString(val) {
    if (!val)
      return "";
    if (Array.isArray(val)) {
      return val.join(".");
    }
    return val;
  }
});

// node_modules/set-value/node_modules/extend-shallow/index.js
var require_extend_shallow4 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/set-value/node_modules/is-plain-object/index.js
var require_is_plain_object2 = __commonJS((exports2, module2) => {
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  function isObjectObject(o) {
    return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
  }
  module2.exports = function isPlainObject(o) {
    var ctor, prot;
    if (isObjectObject(o) === false)
      return false;
    ctor = o.constructor;
    if (typeof ctor !== "function")
      return false;
    prot = ctor.prototype;
    if (isObjectObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  };
});

// node_modules/set-value/index.js
var require_set_value = __commonJS((exports2, module2) => {
  /*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var split = require_split_string();
  var extend = require_extend_shallow4();
  var isPlainObject = require_is_plain_object2();
  var isObject = require_is_extendable2();
  module2.exports = function(obj, prop, val) {
    if (!isObject(obj)) {
      return obj;
    }
    if (Array.isArray(prop)) {
      prop = [].concat.apply([], prop).join(".");
    }
    if (typeof prop !== "string") {
      return obj;
    }
    var keys = split(prop, {sep: ".", brackets: true}).filter(isValidKey);
    var len = keys.length;
    var idx = -1;
    var current = obj;
    while (++idx < len) {
      var key = keys[idx];
      if (idx !== len - 1) {
        if (!isObject(current[key])) {
          current[key] = {};
        }
        current = current[key];
        continue;
      }
      if (isPlainObject(current[key]) && isPlainObject(val)) {
        current[key] = extend({}, current[key], val);
      } else {
        current[key] = val;
      }
    }
    return obj;
  };
  function isValidKey(key) {
    return key !== "__proto__" && key !== "constructor" && key !== "prototype";
  }
});

// node_modules/union-value/index.js
var require_union_value = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  var union = require_arr_union();
  var get = require_get_value();
  var set = require_set_value();
  module2.exports = function unionValue(obj, prop, value) {
    if (!isObject(obj)) {
      throw new TypeError("union-value expects the first argument to be an object.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("union-value expects `prop` to be a string.");
    }
    var arr = arrayify(get(obj, prop));
    set(obj, prop, union(arr, arrayify(value)));
    return obj;
  };
  function arrayify(val) {
    if (val === null || typeof val === "undefined") {
      return [];
    }
    if (Array.isArray(val)) {
      return val;
    }
    return [val];
  }
});

// node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js
var require_isobject2 = __commonJS((exports2, module2) => {
  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isArray = require_isarray();
  module2.exports = function isObject(val) {
    return val != null && typeof val === "object" && isArray(val) === false;
  };
});

// node_modules/unset-value/node_modules/has-values/index.js
var require_has_values = __commonJS((exports2, module2) => {
  /*!
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  module2.exports = function hasValue(o, noZero) {
    if (o === null || o === void 0) {
      return false;
    }
    if (typeof o === "boolean") {
      return true;
    }
    if (typeof o === "number") {
      if (o === 0 && noZero === true) {
        return false;
      }
      return true;
    }
    if (o.length !== void 0) {
      return o.length !== 0;
    }
    for (var key in o) {
      if (o.hasOwnProperty(key)) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/unset-value/node_modules/has-value/index.js
var require_has_value = __commonJS((exports2, module2) => {
  /*!
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isObject = require_isobject2();
  var hasValues = require_has_values();
  var get = require_get_value();
  module2.exports = function(obj, prop, noZero) {
    if (isObject(obj)) {
      return hasValues(get(obj, prop), noZero);
    }
    return hasValues(obj, prop);
  };
});

// node_modules/unset-value/index.js
var require_unset_value = __commonJS((exports2, module2) => {
  /*!
   * unset-value <https://github.com/jonschlinkert/unset-value>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  var has = require_has_value();
  module2.exports = function unset(obj, prop) {
    if (!isObject(obj)) {
      throw new TypeError("expected an object.");
    }
    if (obj.hasOwnProperty(prop)) {
      delete obj[prop];
      return true;
    }
    if (has(obj, prop)) {
      var segs = prop.split(".");
      var last = segs.pop();
      while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
        last = segs.pop().slice(0, -1) + "." + last;
      }
      while (segs.length)
        obj = obj[prop = segs.shift()];
      return delete obj[last];
    }
    return true;
  };
});

// node_modules/has-values/node_modules/kind-of/index.js
var require_kind_of5 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (type === "[object Promise]") {
      return "promise";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/has-values/node_modules/is-number/node_modules/kind-of/index.js
var require_kind_of6 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/has-values/node_modules/is-number/index.js
var require_is_number3 = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of6();
  module2.exports = function isNumber(num) {
    var type = typeOf(num);
    if (type === "string") {
      if (!num.trim())
        return false;
    } else if (type !== "number") {
      return false;
    }
    return num - num + 1 >= 0;
  };
});

// node_modules/has-values/index.js
var require_has_values2 = __commonJS((exports2, module2) => {
  /*!
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of5();
  var isNumber = require_is_number3();
  module2.exports = function hasValue(val) {
    if (isNumber(val)) {
      return true;
    }
    switch (typeOf(val)) {
      case "null":
      case "boolean":
      case "function":
        return true;
      case "string":
      case "arguments":
        return val.length !== 0;
      case "error":
        return val.message !== "";
      case "array":
        var len = val.length;
        if (len === 0) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          if (hasValue(val[i])) {
            return true;
          }
        }
        return false;
      case "file":
      case "map":
      case "set":
        return val.size !== 0;
      case "object":
        var keys = Object.keys(val);
        if (keys.length === 0) {
          return false;
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (hasValue(val[key])) {
            return true;
          }
        }
        return false;
      default: {
        return false;
      }
    }
  };
});

// node_modules/has-value/index.js
var require_has_value2 = __commonJS((exports2, module2) => {
  /*!
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  var hasValues = require_has_values2();
  var get = require_get_value();
  module2.exports = function(val, prop) {
    return hasValues(isObject(val) && prop ? get(val, prop) : val);
  };
});

// node_modules/cache-base/index.js
var require_cache_base = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_isobject();
  var Emitter = require_component_emitter();
  var visit = require_collection_visit();
  var toPath = require_to_object_path();
  var union = require_union_value();
  var del = require_unset_value();
  var get = require_get_value();
  var has = require_has_value2();
  var set = require_set_value();
  function namespace(prop) {
    function Cache(cache) {
      if (prop) {
        this[prop] = {};
      }
      if (cache) {
        this.set(cache);
      }
    }
    Emitter(Cache.prototype);
    Cache.prototype.set = function(key, val) {
      if (Array.isArray(key) && arguments.length === 2) {
        key = toPath(key);
      }
      if (isObject(key) || Array.isArray(key)) {
        this.visit("set", key);
      } else {
        set(prop ? this[prop] : this, key, val);
        this.emit("set", key, val);
      }
      return this;
    };
    Cache.prototype.union = function(key, val) {
      if (Array.isArray(key) && arguments.length === 2) {
        key = toPath(key);
      }
      var ctx = prop ? this[prop] : this;
      union(ctx, key, arrayify(val));
      this.emit("union", val);
      return this;
    };
    Cache.prototype.get = function(key) {
      key = toPath(arguments);
      var ctx = prop ? this[prop] : this;
      var val = get(ctx, key);
      this.emit("get", key, val);
      return val;
    };
    Cache.prototype.has = function(key) {
      key = toPath(arguments);
      var ctx = prop ? this[prop] : this;
      var val = get(ctx, key);
      var has2 = typeof val !== "undefined";
      this.emit("has", key, has2);
      return has2;
    };
    Cache.prototype.del = function(key) {
      if (Array.isArray(key)) {
        this.visit("del", key);
      } else {
        del(prop ? this[prop] : this, key);
        this.emit("del", key);
      }
      return this;
    };
    Cache.prototype.clear = function() {
      if (prop) {
        this[prop] = {};
      }
    };
    Cache.prototype.visit = function(method, val) {
      visit(this, method, val);
      return this;
    };
    return Cache;
  }
  function arrayify(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  module2.exports = namespace();
  module2.exports.namespace = namespace;
});

// node_modules/mixin-deep/node_modules/is-plain-object/index.js
var require_is_plain_object3 = __commonJS((exports2, module2) => {
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isObject = require_isobject();
  function isObjectObject(o) {
    return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
  }
  module2.exports = function isPlainObject(o) {
    var ctor, prot;
    if (isObjectObject(o) === false)
      return false;
    ctor = o.constructor;
    if (typeof ctor !== "function")
      return false;
    prot = ctor.prototype;
    if (isObjectObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  };
});

// node_modules/mixin-deep/node_modules/is-extendable/index.js
var require_is_extendable3 = __commonJS((exports2, module2) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isPlainObject = require_is_plain_object3();
  module2.exports = function isExtendable(val) {
    return isPlainObject(val) || typeof val === "function" || Array.isArray(val);
  };
});

// node_modules/for-in/index.js
var require_for_in = __commonJS((exports2, module2) => {
  /*!
   * for-in <https://github.com/jonschlinkert/for-in>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function forIn(obj, fn, thisArg) {
    for (var key in obj) {
      if (fn.call(thisArg, obj[key], key, obj) === false) {
        break;
      }
    }
  };
});

// node_modules/mixin-deep/index.js
var require_mixin_deep = __commonJS((exports2, module2) => {
  "use strict";
  var isExtendable = require_is_extendable3();
  var forIn = require_for_in();
  function mixinDeep(target, objects) {
    var len = arguments.length, i = 0;
    while (++i < len) {
      var obj = arguments[i];
      if (isObject(obj)) {
        forIn(obj, copy, target);
      }
    }
    return target;
  }
  function copy(val, key) {
    if (!isValidKey(key)) {
      return;
    }
    var obj = this[key];
    if (isObject(val) && isObject(obj)) {
      mixinDeep(obj, val);
    } else {
      this[key] = val;
    }
  }
  function isObject(val) {
    return isExtendable(val) && !Array.isArray(val);
  }
  function isValidKey(key) {
    return key !== "__proto__" && key !== "constructor" && key !== "prototype";
  }
  module2.exports = mixinDeep;
});

// node_modules/pascalcase/index.js
var require_pascalcase = __commonJS((exports2, module2) => {
  /*!
   * pascalcase <https://github.com/jonschlinkert/pascalcase>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  function pascalcase(str) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string.");
    }
    str = str.replace(/([A-Z])/g, " $1");
    if (str.length === 1) {
      return str.toUpperCase();
    }
    str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
    str = str.charAt(0).toUpperCase() + str.slice(1);
    return str.replace(/[\W_]+(\w|$)/g, function(_, ch) {
      return ch.toUpperCase();
    });
  }
  module2.exports = pascalcase;
});

// node_modules/is-descriptor/node_modules/kind-of/index.js
var require_kind_of7 = __commonJS((exports2, module2) => {
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    var type = typeof val;
    if (type === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (type === "string" || val instanceof String) {
      return "string";
    }
    if (type === "number" || val instanceof Number) {
      return "number";
    }
    if (type === "function" || val instanceof Function) {
      if (typeof val.constructor.name !== "undefined" && val.constructor.name.slice(0, 9) === "Generator") {
        return "generatorfunction";
      }
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (type === "[object Promise]") {
      return "promise";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Map Iterator]") {
      return "mapiterator";
    }
    if (type === "[object Set Iterator]") {
      return "setiterator";
    }
    if (type === "[object String Iterator]") {
      return "stringiterator";
    }
    if (type === "[object Array Iterator]") {
      return "arrayiterator";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
  function isBuffer(val) {
    return val.constructor && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
});

// node_modules/is-accessor-descriptor/node_modules/kind-of/index.js
var require_kind_of8 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor4 = __commonJS((exports2, module2) => {
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of8();
  var accessor = {
    get: "function",
    set: "function",
    configurable: "boolean",
    enumerable: "boolean"
  };
  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (has(obj, "value") || has(obj, "writable")) {
      return false;
    }
    if (!has(obj, "get") || typeof obj.get !== "function") {
      return false;
    }
    if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
      return false;
    }
    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  module2.exports = isAccessorDescriptor;
});

// node_modules/is-data-descriptor/node_modules/kind-of/index.js
var require_kind_of9 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/is-data-descriptor/index.js
var require_is_data_descriptor4 = __commonJS((exports2, module2) => {
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of9();
  var data = {
    configurable: "boolean",
    enumerable: "boolean",
    writable: "boolean"
  };
  function isDataDescriptor(obj, prop) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (!("value" in obj) && !("writable" in obj)) {
      return false;
    }
    for (var key in obj) {
      if (key === "value")
        continue;
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === data[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  module2.exports = isDataDescriptor;
});

// node_modules/is-descriptor/index.js
var require_is_descriptor4 = __commonJS((exports2, module2) => {
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of7();
  var isAccessor = require_is_accessor_descriptor4();
  var isData = require_is_data_descriptor4();
  module2.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if ("get" in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };
});

// node_modules/class-utils/node_modules/define-property/index.js
var require_define_property4 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor4();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/object-copy/node_modules/kind-of/index.js
var require_kind_of10 = __commonJS((exports2, module2) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module2.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/copy-descriptor/index.js
var require_copy_descriptor = __commonJS((exports2, module2) => {
  /*!
   * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  module2.exports = function copyDescriptor(receiver, provider, from, to) {
    if (!isObject(provider) && typeof provider !== "function") {
      to = from;
      from = provider;
      provider = receiver;
    }
    if (!isObject(receiver) && typeof receiver !== "function") {
      throw new TypeError("expected the first argument to be an object");
    }
    if (!isObject(provider) && typeof provider !== "function") {
      throw new TypeError("expected provider to be an object");
    }
    if (typeof to !== "string") {
      to = from;
    }
    if (typeof from !== "string") {
      throw new TypeError("expected key to be a string");
    }
    if (!(from in provider)) {
      throw new Error('property "' + from + '" does not exist');
    }
    var val = Object.getOwnPropertyDescriptor(provider, from);
    if (val)
      Object.defineProperty(receiver, to, val);
  };
  function isObject(val) {
    return {}.toString.call(val) === "[object Object]";
  }
});

// node_modules/object-copy/node_modules/define-property/index.js
var require_define_property5 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor4();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/object-copy/index.js
var require_object_copy = __commonJS((exports2, module2) => {
  "use strict";
  var typeOf = require_kind_of10();
  var copyDescriptor = require_copy_descriptor();
  var define2 = require_define_property5();
  function copy(receiver, provider, omit) {
    if (!isObject(receiver)) {
      throw new TypeError("expected receiving object to be an object.");
    }
    if (!isObject(provider)) {
      throw new TypeError("expected providing object to be an object.");
    }
    var props = nativeKeys(provider);
    var keys = Object.keys(provider);
    var len = props.length;
    omit = arrayify(omit);
    while (len--) {
      var key = props[len];
      if (has(keys, key)) {
        define2(receiver, key, provider[key]);
      } else if (!(key in receiver) && !has(omit, key)) {
        copyDescriptor(receiver, provider, key);
      }
    }
  }
  function isObject(val) {
    return typeOf(val) === "object" || typeof val === "function";
  }
  function has(obj, val) {
    val = arrayify(val);
    var len = val.length;
    if (isObject(obj)) {
      for (var key in obj) {
        if (val.indexOf(key) > -1) {
          return true;
        }
      }
      var keys = nativeKeys(obj);
      return has(keys, val);
    }
    if (Array.isArray(obj)) {
      var arr = obj;
      while (len--) {
        if (arr.indexOf(val[len]) > -1) {
          return true;
        }
      }
      return false;
    }
    throw new TypeError("expected an array or object.");
  }
  function arrayify(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  function hasConstructor(val) {
    return isObject(val) && typeof val.constructor !== "undefined";
  }
  function nativeKeys(val) {
    if (!hasConstructor(val))
      return [];
    return Object.getOwnPropertyNames(val);
  }
  module2.exports = copy;
  module2.exports.has = has;
});

// node_modules/static-extend/node_modules/define-property/index.js
var require_define_property6 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor4();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/static-extend/index.js
var require_static_extend = __commonJS((exports2, module2) => {
  /*!
   * static-extend <https://github.com/jonschlinkert/static-extend>
   *
   * Copyright (c) 2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var copy = require_object_copy();
  var define2 = require_define_property6();
  var util = require("util");
  function extend(Parent, extendFn) {
    if (typeof Parent !== "function") {
      throw new TypeError("expected Parent to be a function.");
    }
    return function(Ctor, proto) {
      if (typeof Ctor !== "function") {
        throw new TypeError("expected Ctor to be a function.");
      }
      util.inherits(Ctor, Parent);
      copy(Ctor, Parent);
      if (typeof proto === "object") {
        var obj = Object.create(proto);
        for (var k in obj) {
          Ctor.prototype[k] = obj[k];
        }
      }
      define2(Ctor.prototype, "_parent_", {
        configurable: true,
        set: function() {
        },
        get: function() {
          return Parent.prototype;
        }
      });
      if (typeof extendFn === "function") {
        extendFn(Ctor, Parent);
      }
      Ctor.extend = extend(Ctor, extendFn);
    };
  }
  module2.exports = extend;
});

// node_modules/class-utils/index.js
var require_class_utils = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var union = require_arr_union();
  var define2 = require_define_property4();
  var staticExtend = require_static_extend();
  var isObj = require_isobject();
  var cu = module2.exports;
  cu.isObject = function isObject(val) {
    return isObj(val) || typeof val === "function";
  };
  cu.has = function has(obj, val) {
    val = cu.arrayify(val);
    var len = val.length;
    if (cu.isObject(obj)) {
      for (var key in obj) {
        if (val.indexOf(key) > -1) {
          return true;
        }
      }
      var keys = cu.nativeKeys(obj);
      return cu.has(keys, val);
    }
    if (Array.isArray(obj)) {
      var arr = obj;
      while (len--) {
        if (arr.indexOf(val[len]) > -1) {
          return true;
        }
      }
      return false;
    }
    throw new TypeError("expected an array or object.");
  };
  cu.hasAll = function hasAll(val, values) {
    values = cu.arrayify(values);
    var len = values.length;
    while (len--) {
      if (!cu.has(val, values[len])) {
        return false;
      }
    }
    return true;
  };
  cu.arrayify = function arrayify(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  cu.noop = function noop() {
    return;
  };
  cu.identity = function identity(val) {
    return val;
  };
  cu.hasConstructor = function hasConstructor(val) {
    return cu.isObject(val) && typeof val.constructor !== "undefined";
  };
  cu.nativeKeys = function nativeKeys(val) {
    if (!cu.hasConstructor(val))
      return [];
    var keys = Object.getOwnPropertyNames(val);
    if ("caller" in val)
      keys.push("caller");
    return keys;
  };
  cu.getDescriptor = function getDescriptor(obj, key) {
    if (!cu.isObject(obj)) {
      throw new TypeError("expected an object.");
    }
    if (typeof key !== "string") {
      throw new TypeError("expected key to be a string.");
    }
    return Object.getOwnPropertyDescriptor(obj, key);
  };
  cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
    if (!cu.isObject(receiver)) {
      throw new TypeError("expected receiving object to be an object.");
    }
    if (!cu.isObject(provider)) {
      throw new TypeError("expected providing object to be an object.");
    }
    if (typeof name !== "string") {
      throw new TypeError("expected name to be a string.");
    }
    var val = cu.getDescriptor(provider, name);
    if (val)
      Object.defineProperty(receiver, name, val);
  };
  cu.copy = function copy(receiver, provider, omit) {
    if (!cu.isObject(receiver)) {
      throw new TypeError("expected receiving object to be an object.");
    }
    if (!cu.isObject(provider)) {
      throw new TypeError("expected providing object to be an object.");
    }
    var props = Object.getOwnPropertyNames(provider);
    var keys = Object.keys(provider);
    var len = props.length, key;
    omit = cu.arrayify(omit);
    while (len--) {
      key = props[len];
      if (cu.has(keys, key)) {
        define2(receiver, key, provider[key]);
      } else if (!(key in receiver) && !cu.has(omit, key)) {
        cu.copyDescriptor(receiver, provider, key);
      }
    }
  };
  cu.inherit = function inherit(receiver, provider, omit) {
    if (!cu.isObject(receiver)) {
      throw new TypeError("expected receiving object to be an object.");
    }
    if (!cu.isObject(provider)) {
      throw new TypeError("expected providing object to be an object.");
    }
    var keys = [];
    for (var key in provider) {
      keys.push(key);
      receiver[key] = provider[key];
    }
    keys = keys.concat(cu.arrayify(omit));
    var a = provider.prototype || provider;
    var b = receiver.prototype || receiver;
    cu.copy(b, a, keys);
  };
  cu.extend = function() {
    return staticExtend.apply(null, arguments);
  };
  cu.bubble = function(Parent, events) {
    events = events || [];
    Parent.bubble = function(Child, arr) {
      if (Array.isArray(arr)) {
        events = union([], events, arr);
      }
      var len = events.length;
      var idx = -1;
      while (++idx < len) {
        var name = events[idx];
        Parent.on(name, Child.emit.bind(Child, name));
      }
      cu.bubble(Child, events);
    };
  };
});

// node_modules/base/index.js
var require_base3 = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var define2 = require_define_property3();
  var CacheBase = require_cache_base();
  var Emitter = require_component_emitter();
  var isObject = require_isobject();
  var merge = require_mixin_deep();
  var pascal = require_pascalcase();
  var cu = require_class_utils();
  function namespace(name) {
    var Cache = name ? CacheBase.namespace(name) : CacheBase;
    var fns = [];
    function Base(config, options) {
      if (!(this instanceof Base)) {
        return new Base(config, options);
      }
      Cache.call(this, config);
      this.is("base");
      this.initBase(config, options);
    }
    util.inherits(Base, Cache);
    Emitter(Base);
    Base.prototype.initBase = function(config, options) {
      this.options = merge({}, this.options, options);
      this.cache = this.cache || {};
      this.define("registered", {});
      if (name)
        this[name] = {};
      this.define("_callbacks", this._callbacks);
      if (isObject(config)) {
        this.visit("set", config);
      }
      Base.run(this, "use", fns);
    };
    Base.prototype.is = function(name2) {
      if (typeof name2 !== "string") {
        throw new TypeError("expected name to be a string");
      }
      this.define("is" + pascal(name2), true);
      this.define("_name", name2);
      this.define("_appname", name2);
      return this;
    };
    Base.prototype.isRegistered = function(name2, register) {
      if (this.registered.hasOwnProperty(name2)) {
        return true;
      }
      if (register !== false) {
        this.registered[name2] = true;
        this.emit("plugin", name2);
      }
      return false;
    };
    Base.prototype.use = function(fn) {
      fn.call(this, this);
      return this;
    };
    Base.prototype.define = function(key, val) {
      if (isObject(key)) {
        return this.visit("define", key);
      }
      define2(this, key, val);
      return this;
    };
    Base.prototype.mixin = function(key, val) {
      Base.prototype[key] = val;
      return this;
    };
    Base.prototype.mixins = Base.prototype.mixins || [];
    Object.defineProperty(Base.prototype, "base", {
      configurable: true,
      get: function() {
        return this.parent ? this.parent.base : this;
      }
    });
    define2(Base, "use", function(fn) {
      fns.push(fn);
      return Base;
    });
    define2(Base, "run", function(obj, prop, arr) {
      var len = arr.length, i = 0;
      while (len--) {
        obj[prop](arr[i++]);
      }
      return Base;
    });
    define2(Base, "extend", cu.extend(Base, function(Ctor, Parent) {
      Ctor.prototype.mixins = Ctor.prototype.mixins || [];
      define2(Ctor, "mixin", function(fn) {
        var mixin = fn(Ctor.prototype, Ctor);
        if (typeof mixin === "function") {
          Ctor.prototype.mixins.push(mixin);
        }
        return Ctor;
      });
      define2(Ctor, "mixins", function(Child) {
        Base.run(Child, "mixin", Ctor.prototype.mixins);
        return Ctor;
      });
      Ctor.prototype.mixin = function(key, value) {
        Ctor.prototype[key] = value;
        return this;
      };
      return Base;
    }));
    define2(Base, "mixin", function(fn) {
      var mixin = fn(Base.prototype, Base);
      if (typeof mixin === "function") {
        Base.prototype.mixins.push(mixin);
      }
      return Base;
    });
    define2(Base, "mixins", function(Child) {
      Base.run(Child, "mixin", Base.prototype.mixins);
      return Base;
    });
    define2(Base, "inherit", cu.inherit);
    define2(Base, "bubble", cu.bubble);
    return Base;
  }
  module2.exports = namespace();
  module2.exports.namespace = namespace;
});

// node_modules/snapdragon/node_modules/define-property/index.js
var require_define_property7 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor4();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/use/index.js
var require_use = __commonJS((exports2, module2) => {
  /*!
   * use <https://github.com/jonschlinkert/use>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function base(app, options) {
    if (!isObject(app) && typeof app !== "function") {
      throw new TypeError("expected an object or function");
    }
    var opts = isObject(options) ? options : {};
    var prop = typeof opts.prop === "string" ? opts.prop : "fns";
    if (!Array.isArray(app[prop])) {
      define2(app, prop, []);
    }
    define2(app, "use", use);
    define2(app, "run", function(val) {
      if (!isObject(val))
        return;
      if (!val.use || !val.run) {
        define2(val, prop, val[prop] || []);
        define2(val, "use", use);
      }
      if (!val[prop] || val[prop].indexOf(base) === -1) {
        val.use(base);
      }
      var self2 = this || app;
      var fns = self2[prop];
      var len = fns.length;
      var idx = -1;
      while (++idx < len) {
        val.use(fns[idx]);
      }
      return val;
    });
    function use(type, fn, options2) {
      var offset = 1;
      if (typeof type === "string" || Array.isArray(type)) {
        fn = wrap(type, fn);
        offset++;
      } else {
        options2 = fn;
        fn = type;
      }
      if (typeof fn !== "function") {
        throw new TypeError("expected a function");
      }
      var self2 = this || app;
      var fns = self2[prop];
      var args = [].slice.call(arguments, offset);
      args.unshift(self2);
      if (typeof opts.hook === "function") {
        opts.hook.apply(self2, args);
      }
      var val = fn.apply(self2, args);
      if (typeof val === "function" && fns.indexOf(val) === -1) {
        fns.push(val);
      }
      return self2;
    }
    function wrap(type, fn) {
      return function plugin() {
        return this.type === type ? fn.apply(this, arguments) : plugin;
      };
    }
    return app;
  };
  function isObject(val) {
    return val && typeof val === "object" && !Array.isArray(val);
  }
  function define2(obj, key, val) {
    Object.defineProperty(obj, key, {
      configurable: true,
      writable: true,
      value: val
    });
  }
});

// node_modules/snapdragon/node_modules/ms/index.js
var require_ms2 = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/snapdragon/node_modules/debug/src/debug.js
var require_debug = __commonJS((exports2, module2) => {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = require_ms2();
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports2.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports2.enabled(namespace);
    debug.useColors = exports2.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports2.init === "function") {
      exports2.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports2.skips.length; i < len; i++) {
      if (exports2.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports2.names.length; i < len; i++) {
      if (exports2.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/snapdragon/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = require_debug();
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
});

// node_modules/snapdragon/node_modules/debug/src/node.js
var require_node3 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2 = module2.exports = require_debug();
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
  }
  exports2.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports2.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  [3" + c + ";1m" + name + " [0m";
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + "\n");
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = require("fs");
        stream2 = new fs.SyncWriteStream(fd2, {autoClose: false});
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports2.inspectOpts);
    for (var i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  exports2.enable(load());
});

// node_modules/snapdragon/node_modules/debug/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = require_browser2();
  } else {
    module2.exports = require_node3();
  }
});

// node_modules/snapdragon/node_modules/extend-shallow/index.js
var require_extend_shallow5 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/snapdragon/node_modules/source-map/lib/base64.js
var require_base642 = __commonJS((exports2) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports2.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports2.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq2 = __commonJS((exports2) => {
  var base64 = require_base642();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports2.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/snapdragon/node_modules/source-map/lib/util.js
var require_util5 = __commonJS((exports2) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports2.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports2.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports2.urlGenerate = urlGenerate;
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports2.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports2.normalize = normalize;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports2.join = join;
  exports2.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports2.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports2.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports2.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return mappingA.name - mappingB.name;
  }
  exports2.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return mappingA.name - mappingB.name;
  }
  exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
});

// node_modules/snapdragon/node_modules/source-map/lib/array-set.js
var require_array_set2 = __commonJS((exports2) => {
  var util = require_util5();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports2.ArraySet = ArraySet;
});

// node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js
var require_mapping_list2 = __commonJS((exports2) => {
  var util = require_util5();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {generatedLine: -1, generatedColumn: 0};
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports2.MappingList = MappingList;
});

// node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator2 = __commonJS((exports2) => {
  var base64VLQ = require_base64_vlq2();
  var util = require_util5();
  var ArraySet = require_array_set2().ArraySet;
  var MappingList = require_mapping_list2().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports2.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/snapdragon/node_modules/source-map/lib/binary-search.js
var require_binary_search2 = __commonJS((exports2) => {
  exports2.GREATEST_LOWER_BOUND = 1;
  exports2.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js
var require_quick_sort2 = __commonJS((exports2) => {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  exports2.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer2 = __commonJS((exports2) => {
  var util = require_util5();
  var binarySearch = require_binary_search2();
  var ArraySet = require_array_set2().ArraySet;
  var base64VLQ = require_base64_vlq2();
  var quickSort = require_quick_sort2().quickSort;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports2.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._sources.toArray().map(function(s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }
    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"))
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/snapdragon/node_modules/source-map/lib/source-node.js
var require_source_node2 = __commonJS((exports2) => {
  var SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  var util = require_util5();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {code: generated.code, map};
  };
  exports2.SourceNode = SourceNode;
});

// node_modules/snapdragon/node_modules/source-map/source-map.js
var require_source_map2 = __commonJS((exports2) => {
  exports2.SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  exports2.SourceMapConsumer = require_source_map_consumer2().SourceMapConsumer;
  exports2.SourceNode = require_source_node2().SourceNode;
});

// node_modules/source-map-url/source-map-url.js
var require_source_map_url = __commonJS((exports2, module2) => {
  void function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define(factory);
    } else if (typeof exports2 === "object") {
      module2.exports = factory();
    } else {
      root.sourceMappingURL = factory();
    }
  }(exports2, function() {
    var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
    var regex = RegExp("(?:/\\*(?:\\s*\r?\n(?://)?)?(?:" + innerRegex.source + ")\\s*\\*/|//(?:" + innerRegex.source + "))\\s*");
    return {
      regex,
      _innerRegex: innerRegex,
      getFrom: function(code) {
        var match = code.match(regex);
        return match ? match[1] || match[2] || "" : null;
      },
      existsIn: function(code) {
        return regex.test(code);
      },
      removeFrom: function(code) {
        return code.replace(regex, "");
      },
      insertBefore: function(code, string) {
        var match = code.match(regex);
        if (match) {
          return code.slice(0, match.index) + string + code.slice(match.index);
        } else {
          return code + string;
        }
      }
    };
  });
});

// node_modules/source-map-resolve/lib/resolve-url.js
var require_resolve_url = __commonJS((exports2, module2) => {
  var url = require("url");
  function resolveUrl() {
    return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
      return url.resolve(resolved, nextUrl);
    });
  }
  module2.exports = resolveUrl;
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS((exports2, module2) => {
  "use strict";
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp(token, "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  function decodeComponents(components, split) {
    try {
      return decodeURIComponent(components.join(""));
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);
      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join("");
        tokens = input.match(singleMatcher);
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    var replaceMap = {
      "%FE%FF": "\uFFFD\uFFFD",
      "%FF%FE": "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
      var key = entries[i];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  module2.exports = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
});

// node_modules/source-map-resolve/lib/decode-uri-component.js
var require_decode_uri_component2 = __commonJS((exports2, module2) => {
  var decodeUriComponent = require_decode_uri_component();
  function customDecodeUriComponent(string) {
    return decodeUriComponent(string.replace(/\+/g, "%2B"));
  }
  module2.exports = customDecodeUriComponent;
});

// node_modules/urix/index.js
var require_urix = __commonJS((exports2, module2) => {
  var path = require("path");
  "use strict";
  function urix(aPath) {
    if (path.sep === "\\") {
      return aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/");
    }
    return aPath;
  }
  module2.exports = urix;
});

// node_modules/atob/node-atob.js
var require_node_atob = __commonJS((exports2, module2) => {
  "use strict";
  function atob(str) {
    return Buffer.from(str, "base64").toString("binary");
  }
  module2.exports = atob.atob = atob;
});

// node_modules/source-map-resolve/lib/source-map-resolve-node.js
var require_source_map_resolve_node = __commonJS((exports2, module2) => {
  var sourceMappingURL = require_source_map_url();
  var resolveUrl = require_resolve_url();
  var decodeUriComponent = require_decode_uri_component2();
  var urix = require_urix();
  var atob = require_node_atob();
  function callbackAsync(callback, error, result) {
    setImmediate(function() {
      callback(error, result);
    });
  }
  function parseMapToJSON(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""));
    } catch (error) {
      error.sourceMapData = data;
      throw error;
    }
  }
  function readSync(read, url, data) {
    var readUrl = decodeUriComponent(url);
    try {
      return String(read(readUrl));
    } catch (error) {
      error.sourceMapData = data;
      throw error;
    }
  }
  function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData;
    try {
      mapData = resolveSourceMapHelper(code, codeUrl);
    } catch (error) {
      return callbackAsync(callback, error);
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData);
    }
    var readUrl = decodeUriComponent(mapData.url);
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData;
        return callback(error);
      }
      mapData.map = String(result);
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData);
      } catch (error2) {
        return callback(error2);
      }
      callback(null, mapData);
    });
  }
  function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl);
    if (!mapData || mapData.map) {
      return mapData;
    }
    mapData.map = readSync(read, mapData.url, mapData);
    mapData.map = parseMapToJSON(mapData.map, mapData);
    return mapData;
  }
  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
  var jsonCharacterEncoding = "utf-8";
  function base64ToBuf(b64) {
    var binStr = atob(b64);
    var len = binStr.length;
    var arr = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i);
    }
    return arr;
  }
  function decodeBase64String(b64) {
    if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
      return atob(b64);
    }
    var buf = base64ToBuf(b64);
    var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true});
    return decoder.decode(buf);
  }
  function resolveSourceMapHelper(code, codeUrl) {
    codeUrl = urix(codeUrl);
    var url = sourceMappingURL.getFrom(code);
    if (!url) {
      return null;
    }
    var dataUri = url.match(dataUriRegex);
    if (dataUri) {
      var mimeType = dataUri[1] || "text/plain";
      var lastParameter = dataUri[2] || "";
      var encoded = dataUri[3] || "";
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      };
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + mimeType);
        error.sourceMapData = data;
        throw error;
      }
      try {
        data.map = parseMapToJSON(lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);
      } catch (error2) {
        error2.sourceMapData = data;
        throw error2;
      }
      return data;
    }
    var mapUrl = resolveUrl(codeUrl, url);
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    };
  }
  function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var pending = map.sources ? map.sources.length : 0;
    var result = {
      sourcesResolved: [],
      sourcesContent: []
    };
    if (pending === 0) {
      callbackAsync(callback, null, result);
      return;
    }
    var done = function() {
      pending--;
      if (pending === 0) {
        callback(null, result);
      }
    };
    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl;
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent;
        callbackAsync(done, null);
      } else {
        var readUrl = decodeUriComponent(fullUrl);
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source);
          done();
        });
      }
    });
  }
  function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent: []
    };
    if (!map.sources || map.sources.length === 0) {
      return result;
    }
    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl;
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent;
        } else {
          var readUrl = decodeUriComponent(fullUrl);
          try {
            result.sourcesContent[index] = String(read(readUrl));
          } catch (error) {
            result.sourcesContent[index] = error;
          }
        }
      }
    });
    return result;
  }
  var endingSlash = /\/?$/;
  function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {};
    mapUrl = urix(mapUrl);
    var fullUrl;
    var sourceContent;
    var sourceRoot;
    for (var index = 0, len = map.sources.length; index < len; index++) {
      sourceRoot = null;
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot;
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot;
      }
      if (sourceRoot === null || sourceRoot === "") {
        fullUrl = resolveUrl(mapUrl, map.sources[index]);
      } else {
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
      }
      sourceContent = (map.sourcesContent || [])[index];
      fn(fullUrl, sourceContent, index);
    }
  }
  function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (code === null) {
      var mapUrl = codeUrl;
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
      var readUrl = decodeUriComponent(mapUrl);
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data;
          return callback(error);
        }
        data.map = String(result);
        try {
          data.map = parseMapToJSON(data.map, data);
        } catch (error2) {
          return callback(error2);
        }
        _resolveSources(data);
      });
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error);
        }
        if (!mapData) {
          return callback(null, null);
        }
        _resolveSources(mapData);
      });
    }
    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error);
        }
        mapData.sourcesResolved = result.sourcesResolved;
        mapData.sourcesContent = result.sourcesContent;
        callback(null, mapData);
      });
    }
  }
  function resolveSync(code, codeUrl, read, options) {
    var mapData;
    if (code === null) {
      var mapUrl = codeUrl;
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
      mapData.map = readSync(read, mapUrl, mapData);
      mapData.map = parseMapToJSON(mapData.map, mapData);
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read);
      if (!mapData) {
        return null;
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
    mapData.sourcesResolved = result.sourcesResolved;
    mapData.sourcesContent = result.sourcesContent;
    return mapData;
  }
  module2.exports = {
    resolveSourceMap,
    resolveSourceMapSync,
    resolveSources,
    resolveSourcesSync,
    resolve,
    resolveSync,
    parseMapToJSON
  };
});

// node_modules/snapdragon/lib/utils.js
var require_utils6 = __commonJS((exports2) => {
  "use strict";
  exports2.extend = require_extend_shallow5();
  exports2.SourceMap = require_source_map2();
  exports2.sourceMapResolve = require_source_map_resolve_node();
  exports2.unixify = function(fp) {
    return fp.split(/\\+/).join("/");
  };
  exports2.isString = function(str) {
    return str && typeof str === "string";
  };
  exports2.arrayify = function(val) {
    if (typeof val === "string")
      return [val];
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  exports2.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };
});

// node_modules/snapdragon/lib/source-maps.js
var require_source_maps = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var path = require("path");
  var define2 = require_define_property7();
  var utils2 = require_utils6();
  module2.exports = mixin;
  function mixin(compiler) {
    define2(compiler, "_comment", compiler.comment);
    compiler.map = new utils2.SourceMap.SourceMapGenerator();
    compiler.position = {line: 1, column: 1};
    compiler.content = {};
    compiler.files = {};
    for (var key in exports2) {
      define2(compiler, key, exports2[key]);
    }
  }
  exports2.updatePosition = function(str) {
    var lines = str.match(/\n/g);
    if (lines)
      this.position.line += lines.length;
    var i = str.lastIndexOf("\n");
    this.position.column = ~i ? str.length - i : this.position.column + str.length;
  };
  exports2.emit = function(str, node) {
    var position = node.position || {};
    var source = position.source;
    if (source) {
      if (position.filepath) {
        source = utils2.unixify(position.filepath);
      }
      this.map.addMapping({
        source,
        generated: {
          line: this.position.line,
          column: Math.max(this.position.column - 1, 0)
        },
        original: {
          line: position.start.line,
          column: position.start.column - 1
        }
      });
      if (position.content) {
        this.addContent(source, position);
      }
      if (position.filepath) {
        this.addFile(source, position);
      }
      this.updatePosition(str);
      this.output += str;
    }
    return str;
  };
  exports2.addFile = function(file, position) {
    if (typeof position.content !== "string")
      return;
    if (Object.prototype.hasOwnProperty.call(this.files, file))
      return;
    this.files[file] = position.content;
  };
  exports2.addContent = function(source, position) {
    if (typeof position.content !== "string")
      return;
    if (Object.prototype.hasOwnProperty.call(this.content, source))
      return;
    this.map.setSourceContent(source, position.content);
  };
  exports2.applySourceMaps = function() {
    Object.keys(this.files).forEach(function(file) {
      var content = this.files[file];
      this.map.setSourceContent(file, content);
      if (this.options.inputSourcemaps === true) {
        var originalMap = utils2.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
        if (originalMap) {
          var map = new utils2.SourceMap.SourceMapConsumer(originalMap.map);
          var relativeTo = originalMap.sourcesRelativeTo;
          this.map.applySourceMap(map, file, utils2.unixify(path.dirname(relativeTo)));
        }
      }
    }, this);
  };
  exports2.comment = function(node) {
    if (/^# sourceMappingURL=/.test(node.comment)) {
      return this.emit("", node.position);
    }
    return this._comment(node);
  };
});

// node_modules/snapdragon/lib/compiler.js
var require_compiler2 = __commonJS((exports2, module2) => {
  "use strict";
  var use = require_use();
  var define2 = require_define_property7();
  var debug = require_src3()("snapdragon:compiler");
  var utils2 = require_utils6();
  function Compiler(options, state) {
    debug("initializing", __filename);
    this.options = utils2.extend({source: "string"}, options);
    this.state = state || {};
    this.compilers = {};
    this.output = "";
    this.set("eos", function(node) {
      return this.emit(node.val, node);
    });
    this.set("noop", function(node) {
      return this.emit(node.val, node);
    });
    this.set("bos", function(node) {
      return this.emit(node.val, node);
    });
    use(this);
  }
  Compiler.prototype = {
    error: function(msg, node) {
      var pos = node.position || {start: {column: 0}};
      var message = this.options.source + " column:" + pos.start.column + ": " + msg;
      var err = new Error(message);
      err.reason = msg;
      err.column = pos.start.column;
      err.source = this.pattern;
      if (this.options.silent) {
        this.errors.push(err);
      } else {
        throw err;
      }
    },
    define: function(key, val) {
      define2(this, key, val);
      return this;
    },
    emit: function(str, node) {
      this.output += str;
      return str;
    },
    set: function(name, fn) {
      this.compilers[name] = fn;
      return this;
    },
    get: function(name) {
      return this.compilers[name];
    },
    prev: function(n) {
      return this.ast.nodes[this.idx - (n || 1)] || {type: "bos", val: ""};
    },
    next: function(n) {
      return this.ast.nodes[this.idx + (n || 1)] || {type: "eos", val: ""};
    },
    visit: function(node, nodes, i) {
      var fn = this.compilers[node.type];
      this.idx = i;
      if (typeof fn !== "function") {
        throw this.error('compiler "' + node.type + '" is not registered', node);
      }
      return fn.call(this, node, nodes, i);
    },
    mapVisit: function(nodes) {
      if (!Array.isArray(nodes)) {
        throw new TypeError("expected an array");
      }
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        this.visit(nodes[idx], nodes, idx);
      }
      return this;
    },
    compile: function(ast, options) {
      var opts = utils2.extend({}, this.options, options);
      this.ast = ast;
      this.parsingErrors = this.ast.errors;
      this.output = "";
      if (opts.sourcemap) {
        var sourcemaps = require_source_maps();
        sourcemaps(this);
        this.mapVisit(this.ast.nodes);
        this.applySourceMaps();
        this.map = opts.sourcemap === "generator" ? this.map : this.map.toJSON();
        return this;
      }
      this.mapVisit(this.ast.nodes);
      return this;
    }
  };
  module2.exports = Compiler;
});

// node_modules/map-cache/index.js
var require_map_cache = __commonJS((exports2, module2) => {
  /*!
   * map-cache <https://github.com/jonschlinkert/map-cache>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var hasOwn = Object.prototype.hasOwnProperty;
  module2.exports = MapCache;
  function MapCache(data) {
    this.__data__ = data || {};
  }
  MapCache.prototype.set = function mapSet(key, value) {
    if (key !== "__proto__") {
      this.__data__[key] = value;
    }
    return this;
  };
  MapCache.prototype.get = function mapGet(key) {
    return key === "__proto__" ? void 0 : this.__data__[key];
  };
  MapCache.prototype.has = function mapHas(key) {
    return key !== "__proto__" && hasOwn.call(this.__data__, key);
  };
  MapCache.prototype.del = function mapDelete(key) {
    return this.has(key) && delete this.__data__[key];
  };
});

// node_modules/snapdragon/lib/position.js
var require_position = __commonJS((exports2, module2) => {
  "use strict";
  var define2 = require_define_property7();
  module2.exports = function Position(start, parser) {
    this.start = start;
    this.end = {line: parser.line, column: parser.column};
    define2(this, "content", parser.orig);
    define2(this, "source", parser.options.source);
  };
});

// node_modules/snapdragon/lib/parser.js
var require_parser3 = __commonJS((exports2, module2) => {
  "use strict";
  var use = require_use();
  var util = require("util");
  var Cache = require_map_cache();
  var define2 = require_define_property7();
  var debug = require_src3()("snapdragon:parser");
  var Position = require_position();
  var utils2 = require_utils6();
  function Parser(options) {
    debug("initializing", __filename);
    this.options = utils2.extend({source: "string"}, options);
    this.init(this.options);
    use(this);
  }
  Parser.prototype = {
    constructor: Parser,
    init: function(options) {
      this.orig = "";
      this.input = "";
      this.parsed = "";
      this.column = 1;
      this.line = 1;
      this.regex = new Cache();
      this.errors = this.errors || [];
      this.parsers = this.parsers || {};
      this.types = this.types || [];
      this.sets = this.sets || {};
      this.fns = this.fns || [];
      this.currentType = "root";
      var pos = this.position();
      this.bos = pos({type: "bos", val: ""});
      this.ast = {
        type: "root",
        errors: this.errors,
        nodes: [this.bos]
      };
      define2(this.bos, "parent", this.ast);
      this.nodes = [this.ast];
      this.count = 0;
      this.setCount = 0;
      this.stack = [];
    },
    error: function(msg, node) {
      var pos = node.position || {start: {column: 0, line: 0}};
      var line = pos.start.line;
      var column = pos.start.column;
      var source = this.options.source;
      var message = source + " <line:" + line + " column:" + column + ">: " + msg;
      var err = new Error(message);
      err.source = source;
      err.reason = msg;
      err.pos = pos;
      if (this.options.silent) {
        this.errors.push(err);
      } else {
        throw err;
      }
    },
    define: function(key, val) {
      define2(this, key, val);
      return this;
    },
    position: function() {
      var start = {line: this.line, column: this.column};
      var self2 = this;
      return function(node) {
        define2(node, "position", new Position(start, self2));
        return node;
      };
    },
    set: function(type, fn) {
      if (this.types.indexOf(type) === -1) {
        this.types.push(type);
      }
      this.parsers[type] = fn.bind(this);
      return this;
    },
    get: function(name) {
      return this.parsers[name];
    },
    push: function(type, token) {
      this.sets[type] = this.sets[type] || [];
      this.count++;
      this.stack.push(token);
      return this.sets[type].push(token);
    },
    pop: function(type) {
      this.sets[type] = this.sets[type] || [];
      this.count--;
      this.stack.pop();
      return this.sets[type].pop();
    },
    isInside: function(type) {
      this.sets[type] = this.sets[type] || [];
      return this.sets[type].length > 0;
    },
    isType: function(node, type) {
      return node && node.type === type;
    },
    prev: function(n) {
      return this.stack.length > 0 ? utils2.last(this.stack, n) : utils2.last(this.nodes, n);
    },
    consume: function(len) {
      this.input = this.input.substr(len);
    },
    updatePosition: function(str, len) {
      var lines = str.match(/\n/g);
      if (lines)
        this.line += lines.length;
      var i = str.lastIndexOf("\n");
      this.column = ~i ? len - i : this.column + len;
      this.parsed += str;
      this.consume(len);
    },
    match: function(regex) {
      var m = regex.exec(this.input);
      if (m) {
        this.updatePosition(m[0], m[0].length);
        return m;
      }
    },
    capture: function(type, regex) {
      if (typeof regex === "function") {
        return this.set.apply(this, arguments);
      }
      this.regex.set(type, regex);
      this.set(type, function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(regex);
        if (!m || !m[0])
          return;
        var prev = this.prev();
        var node = pos({
          type,
          val: m[0],
          parsed,
          rest: this.input
        });
        if (m[1]) {
          node.inner = m[1];
        }
        define2(node, "inside", this.stack.length > 0);
        define2(node, "parent", prev);
        prev.nodes.push(node);
      }.bind(this));
      return this;
    },
    capturePair: function(type, openRegex, closeRegex, fn) {
      this.sets[type] = this.sets[type] || [];
      this.set(type + ".open", function() {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(openRegex);
        if (!m || !m[0])
          return;
        var val = m[0];
        this.setCount++;
        this.specialChars = true;
        var open = pos({
          type: type + ".open",
          val,
          rest: this.input
        });
        if (typeof m[1] !== "undefined") {
          open.inner = m[1];
        }
        var prev = this.prev();
        var node = pos({
          type,
          nodes: [open]
        });
        define2(node, "rest", this.input);
        define2(node, "parsed", parsed);
        define2(node, "prefix", m[1]);
        define2(node, "parent", prev);
        define2(open, "parent", node);
        if (typeof fn === "function") {
          fn.call(this, open, node);
        }
        this.push(type, node);
        prev.nodes.push(node);
      });
      this.set(type + ".close", function() {
        var pos = this.position();
        var m = this.match(closeRegex);
        if (!m || !m[0])
          return;
        var parent = this.pop(type);
        var node = pos({
          type: type + ".close",
          rest: this.input,
          suffix: m[1],
          val: m[0]
        });
        if (!this.isType(parent, type)) {
          if (this.options.strict) {
            throw new Error('missing opening "' + type + '"');
          }
          this.setCount--;
          node.escaped = true;
          return node;
        }
        if (node.suffix === "\\") {
          parent.escaped = true;
          node.escaped = true;
        }
        parent.nodes.push(node);
        define2(node, "parent", parent);
      });
      return this;
    },
    eos: function() {
      var pos = this.position();
      if (this.input)
        return;
      var prev = this.prev();
      while (prev.type !== "root" && !prev.visited) {
        if (this.options.strict === true) {
          throw new SyntaxError("invalid syntax:" + util.inspect(prev, null, 2));
        }
        if (!hasDelims(prev)) {
          prev.parent.escaped = true;
          prev.escaped = true;
        }
        visit(prev, function(node) {
          if (!hasDelims(node.parent)) {
            node.parent.escaped = true;
            node.escaped = true;
          }
        });
        prev = prev.parent;
      }
      var tok = pos({
        type: "eos",
        val: this.append || ""
      });
      define2(tok, "parent", this.ast);
      return tok;
    },
    next: function() {
      var parsed = this.parsed;
      var len = this.types.length;
      var idx = -1;
      var tok;
      while (++idx < len) {
        if (tok = this.parsers[this.types[idx]].call(this)) {
          define2(tok, "rest", this.input);
          define2(tok, "parsed", parsed);
          this.last = tok;
          return tok;
        }
      }
    },
    parse: function(input) {
      if (typeof input !== "string") {
        throw new TypeError("expected a string");
      }
      this.init(this.options);
      this.orig = input;
      this.input = input;
      var self2 = this;
      function parse() {
        input = self2.input;
        var node2 = self2.next();
        if (node2) {
          var prev = self2.prev();
          if (prev) {
            define2(node2, "parent", prev);
            if (prev.nodes) {
              prev.nodes.push(node2);
            }
          }
          if (self2.sets.hasOwnProperty(prev.type)) {
            self2.currentType = prev.type;
          }
        }
        if (self2.input && input === self2.input) {
          throw new Error('no parsers registered for: "' + self2.input.slice(0, 5) + '"');
        }
      }
      while (this.input)
        parse();
      if (this.stack.length && this.options.strict) {
        var node = this.stack.pop();
        throw this.error("missing opening " + node.type + ': "' + this.orig + '"');
      }
      var eos = this.eos();
      var tok = this.prev();
      if (tok.type !== "eos") {
        this.ast.nodes.push(eos);
      }
      return this.ast;
    }
  };
  function visit(node, fn) {
    if (!node.visited) {
      define2(node, "visited", true);
      return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
    }
    return node;
  }
  function mapVisit(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      visit(nodes[idx], fn);
    }
  }
  function hasOpen(node) {
    return node.nodes && node.nodes[0].type === node.type + ".open";
  }
  function hasClose(node) {
    return node.nodes && utils2.last(node.nodes).type === node.type + ".close";
  }
  function hasDelims(node) {
    return hasOpen(node) && hasClose(node);
  }
  module2.exports = Parser;
});

// node_modules/snapdragon/index.js
var require_snapdragon = __commonJS((exports2, module2) => {
  "use strict";
  var Base = require_base3();
  var define2 = require_define_property7();
  var Compiler = require_compiler2();
  var Parser = require_parser3();
  var utils2 = require_utils6();
  function Snapdragon(options) {
    Base.call(this, null, options);
    this.options = utils2.extend({source: "string"}, this.options);
    this.compiler = new Compiler(this.options);
    this.parser = new Parser(this.options);
    Object.defineProperty(this, "compilers", {
      get: function() {
        return this.compiler.compilers;
      }
    });
    Object.defineProperty(this, "parsers", {
      get: function() {
        return this.parser.parsers;
      }
    });
    Object.defineProperty(this, "regex", {
      get: function() {
        return this.parser.regex;
      }
    });
  }
  Base.extend(Snapdragon);
  Snapdragon.prototype.capture = function() {
    return this.parser.capture.apply(this.parser, arguments);
  };
  Snapdragon.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };
  Snapdragon.prototype.parse = function(str, options) {
    this.options = utils2.extend({}, this.options, options);
    var parsed = this.parser.parse(str, this.options);
    define2(parsed, "parser", this.parser);
    return parsed;
  };
  Snapdragon.prototype.compile = function(ast, options) {
    this.options = utils2.extend({}, this.options, options);
    var compiled = this.compiler.compile(ast, this.options);
    define2(compiled, "compiler", this.compiler);
    return compiled;
  };
  module2.exports = Snapdragon;
  module2.exports.Compiler = Compiler;
  module2.exports.Parser = Parser;
});

// node_modules/findup-sync/node_modules/braces/lib/braces.js
var require_braces2 = __commonJS((exports2, module2) => {
  "use strict";
  var extend = require_extend_shallow2();
  var Snapdragon = require_snapdragon();
  var compilers = require_compilers();
  var parsers = require_parsers();
  var utils2 = require_utils5();
  function Braces(options) {
    this.options = extend({}, options);
  }
  Braces.prototype.init = function(options) {
    if (this.isInitialized)
      return;
    this.isInitialized = true;
    var opts = utils2.createOptions({}, this.options, options);
    this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;
    compilers(this.snapdragon, opts);
    parsers(this.snapdragon, opts);
    utils2.define(this.snapdragon, "parse", function(pattern, options2) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      this.parser.ast.input = pattern;
      var stack = this.parser.stack;
      while (stack.length) {
        addParent({type: "brace.close", val: ""}, stack.pop());
      }
      function addParent(node, parent) {
        utils2.define(node, "parent", parent);
        parent.nodes.push(node);
      }
      utils2.define(parsed, "parser", this.parser);
      return parsed;
    });
  };
  Braces.prototype.parse = function(ast, options) {
    if (ast && typeof ast === "object" && ast.nodes)
      return ast;
    this.init(options);
    return this.snapdragon.parse(ast, options);
  };
  Braces.prototype.compile = function(ast, options) {
    if (typeof ast === "string") {
      ast = this.parse(ast, options);
    } else {
      this.init(options);
    }
    return this.snapdragon.compile(ast, options);
  };
  Braces.prototype.expand = function(pattern) {
    var ast = this.parse(pattern, {expand: true});
    return this.compile(ast, {expand: true});
  };
  Braces.prototype.optimize = function(pattern) {
    var ast = this.parse(pattern, {optimize: true});
    return this.compile(ast, {optimize: true});
  };
  module2.exports = Braces;
});

// node_modules/findup-sync/node_modules/braces/index.js
var require_braces3 = __commonJS((exports2, module2) => {
  "use strict";
  var toRegex = require_to_regex();
  var unique = require_array_unique();
  var extend = require_extend_shallow2();
  var compilers = require_compilers();
  var parsers = require_parsers();
  var Braces = require_braces2();
  var utils2 = require_utils5();
  var MAX_LENGTH = 1024 * 64;
  var cache = {};
  function braces(pattern, options) {
    var key = utils2.createKey(String(pattern), options);
    var arr = [];
    var disabled = options && options.cache === false;
    if (!disabled && cache.hasOwnProperty(key)) {
      return cache[key];
    }
    if (Array.isArray(pattern)) {
      for (var i = 0; i < pattern.length; i++) {
        arr.push.apply(arr, braces.create(pattern[i], options));
      }
    } else {
      arr = braces.create(pattern, options);
    }
    if (options && options.nodupes === true) {
      arr = unique(arr);
    }
    if (!disabled) {
      cache[key] = arr;
    }
    return arr;
  }
  braces.expand = function(pattern, options) {
    return braces.create(pattern, extend({}, options, {expand: true}));
  };
  braces.optimize = function(pattern, options) {
    return braces.create(pattern, options);
  };
  braces.create = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    var maxLength = options && options.maxLength || MAX_LENGTH;
    if (pattern.length >= maxLength) {
      throw new Error("expected pattern to be less than " + maxLength + " characters");
    }
    function create() {
      if (pattern === "" || pattern.length < 3) {
        return [pattern];
      }
      if (utils2.isEmptySets(pattern)) {
        return [];
      }
      if (utils2.isQuotedString(pattern)) {
        return [pattern.slice(1, -1)];
      }
      var proto = new Braces(options);
      var result = !options || options.expand !== true ? proto.optimize(pattern, options) : proto.expand(pattern, options);
      var arr = result.output;
      if (options && options.noempty === true) {
        arr = arr.filter(Boolean);
      }
      if (options && options.nodupes === true) {
        arr = unique(arr);
      }
      Object.defineProperty(arr, "result", {
        enumerable: false,
        value: result
      });
      return arr;
    }
    return memoize("create", pattern, options, create);
  };
  braces.makeRe = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    var maxLength = options && options.maxLength || MAX_LENGTH;
    if (pattern.length >= maxLength) {
      throw new Error("expected pattern to be less than " + maxLength + " characters");
    }
    function makeRe() {
      var arr = braces(pattern, options);
      var opts = extend({strictErrors: false}, options);
      return toRegex(arr, opts);
    }
    return memoize("makeRe", pattern, options, makeRe);
  };
  braces.parse = function(pattern, options) {
    var proto = new Braces(options);
    return proto.parse(pattern, options);
  };
  braces.compile = function(ast, options) {
    var proto = new Braces(options);
    return proto.compile(ast, options);
  };
  braces.clearCache = function() {
    cache = braces.cache = {};
  };
  function memoize(type, pattern, options, fn) {
    var key = utils2.createKey(type + ":" + pattern, options);
    var disabled = options && options.cache === false;
    if (disabled) {
      braces.clearCache();
      return fn(pattern, options);
    }
    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
    var res = fn(pattern, options);
    cache[key] = res;
    return res;
  }
  braces.Braces = Braces;
  braces.compilers = compilers;
  braces.parsers = parsers;
  braces.cache = cache;
  module2.exports = braces;
});

// node_modules/nanomatch/lib/compilers.js
var require_compilers2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(nanomatch, options) {
    function slash() {
      if (options && typeof options.slash === "string") {
        return options.slash;
      }
      if (options && typeof options.slash === "function") {
        return options.slash.call(nanomatch);
      }
      return "\\\\/";
    }
    function star() {
      if (options && typeof options.star === "string") {
        return options.star;
      }
      if (options && typeof options.star === "function") {
        return options.star.call(nanomatch);
      }
      return "[^" + slash() + "]*?";
    }
    var ast = nanomatch.ast = nanomatch.parser.ast;
    ast.state = nanomatch.parser.state;
    nanomatch.compiler.state = ast.state;
    nanomatch.compiler.set("not", function(node) {
      var prev = this.prev();
      if (this.options.nonegate === true || prev.type !== "bos") {
        return this.emit("\\" + node.val, node);
      }
      return this.emit(node.val, node);
    }).set("escape", function(node) {
      if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
        return this.emit(node.val, node);
      }
      return this.emit("\\" + node.val, node);
    }).set("quoted", function(node) {
      return this.emit(node.val, node);
    }).set("dollar", function(node) {
      if (node.parent.type === "bracket") {
        return this.emit(node.val, node);
      }
      return this.emit("\\" + node.val, node);
    }).set("dot", function(node) {
      if (node.dotfiles === true)
        this.dotfiles = true;
      return this.emit("\\" + node.val, node);
    }).set("backslash", function(node) {
      return this.emit(node.val, node);
    }).set("slash", function(node, nodes, i) {
      var val = "[" + slash() + "]";
      var parent = node.parent;
      var prev = this.prev();
      while (parent.type === "paren" && !parent.hasSlash) {
        parent.hasSlash = true;
        parent = parent.parent;
      }
      if (prev.addQmark) {
        val += "?";
      }
      if (node.rest.slice(0, 2) === "\\b") {
        return this.emit(val, node);
      }
      if (node.parsed === "**" || node.parsed === "./**") {
        this.output = "(?:" + this.output;
        return this.emit(val + ")?", node);
      }
      if (node.parsed === "!**" && this.options.nonegate !== true) {
        return this.emit(val + "?\\b", node);
      }
      return this.emit(val, node);
    }).set("bracket", function(node) {
      var close = node.close;
      var open = !node.escaped ? "[" : "\\[";
      var negated = node.negated;
      var inner = node.inner;
      var val = node.val;
      if (node.escaped === true) {
        inner = inner.replace(/\\?(\W)/g, "\\$1");
        negated = "";
      }
      if (inner === "]-") {
        inner = "\\]\\-";
      }
      if (negated && inner.indexOf(".") === -1) {
        inner += ".";
      }
      if (negated && inner.indexOf("/") === -1) {
        inner += "/";
      }
      val = open + negated + inner + close;
      return this.emit(val, node);
    }).set("square", function(node) {
      var val = (/^\W/.test(node.val) ? "\\" : "") + node.val;
      return this.emit(val, node);
    }).set("qmark", function(node) {
      var prev = this.prev();
      var val = "[^.\\\\/]";
      if (this.options.dot || prev.type !== "bos" && prev.type !== "slash") {
        val = "[^\\\\/]";
      }
      if (node.parsed.slice(-1) === "(") {
        var ch = node.rest.charAt(0);
        if (ch === "!" || ch === "=" || ch === ":") {
          return this.emit(node.val, node);
        }
      }
      if (node.val.length > 1) {
        val += "{" + node.val.length + "}";
      }
      return this.emit(val, node);
    }).set("plus", function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === "]" || prev === ")") {
        return this.emit(node.val, node);
      }
      if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
        return this.emit("\\+", node);
      }
      var ch = this.output.slice(-1);
      if (/\w/.test(ch) && !node.inside) {
        return this.emit("+\\+?", node);
      }
      return this.emit("+", node);
    }).set("globstar", function(node, nodes, i) {
      if (!this.output) {
        this.state.leadingGlobstar = true;
      }
      var prev = this.prev();
      var before = this.prev(2);
      var next = this.next();
      var after = this.next(2);
      var type = prev.type;
      var val = node.val;
      if (prev.type === "slash" && next.type === "slash") {
        if (before.type === "text") {
          this.output += "?";
          if (after.type !== "text") {
            this.output += "\\b";
          }
        }
      }
      var parsed = node.parsed;
      if (parsed.charAt(0) === "!") {
        parsed = parsed.slice(1);
      }
      var isInside = node.isInside.paren || node.isInside.brace;
      if (parsed && type !== "slash" && type !== "bos" && !isInside) {
        val = star();
      } else {
        val = this.options.dot !== true ? "(?:(?!(?:[" + slash() + "]|^)\\.).)*?" : "(?:(?!(?:[" + slash() + "]|^)(?:\\.{1,2})($|[" + slash() + "]))(?!\\.{2}).)*?";
      }
      if ((type === "slash" || type === "bos") && this.options.dot !== true) {
        val = "(?!\\.)" + val;
      }
      if (prev.type === "slash" && next.type === "slash" && before.type !== "text") {
        if (after.type === "text" || after.type === "star") {
          node.addQmark = true;
        }
      }
      if (this.options.capture) {
        val = "(" + val + ")";
      }
      return this.emit(val, node);
    }).set("star", function(node, nodes, i) {
      var prior = nodes[i - 2] || {};
      var prev = this.prev();
      var next = this.next();
      var type = prev.type;
      function isStart(n) {
        return n.type === "bos" || n.type === "slash";
      }
      if (this.output === "" && this.options.contains !== true) {
        this.output = "(?![" + slash() + "])";
      }
      if (type === "bracket" && this.options.bash === false) {
        var str = next && next.type === "bracket" ? star() : "*?";
        if (!prev.nodes || prev.nodes[1].type !== "posix") {
          return this.emit(str, node);
        }
      }
      var prefix = !this.dotfiles && type !== "text" && type !== "escape" ? this.options.dot ? "(?!(?:^|[" + slash() + "])\\.{1,2}(?:$|[" + slash() + "]))" : "(?!\\.)" : "";
      if (isStart(prev) || isStart(prior) && type === "not") {
        if (prefix !== "(?!\\.)") {
          prefix += "(?!(\\.{2}|\\.[" + slash() + "]))(?=.)";
        } else {
          prefix += "(?=.)";
        }
      } else if (prefix === "(?!\\.)") {
        prefix = "";
      }
      if (prev.type === "not" && prior.type === "bos" && this.options.dot === true) {
        this.output = "(?!\\.)" + this.output;
      }
      var output = prefix + star();
      if (this.options.capture) {
        output = "(" + output + ")";
      }
      return this.emit(output, node);
    }).set("text", function(node) {
      return this.emit(node.val, node);
    }).set("eos", function(node) {
      var prev = this.prev();
      var val = node.val;
      this.output = "(?:\\.[" + slash() + "](?=.))?" + this.output;
      if (this.state.metachar && prev.type !== "qmark" && prev.type !== "slash") {
        val += this.options.contains ? "[" + slash() + "]?" : "(?:[" + slash() + "]|$)";
      }
      return this.emit(val, node);
    });
    if (options && typeof options.compilers === "function") {
      options.compilers(nanomatch.compiler);
    }
  };
});

// node_modules/nanomatch/lib/parsers.js
var require_parsers2 = __commonJS((exports2, module2) => {
  "use strict";
  var regexNot = require_regex_not();
  var toRegex = require_to_regex();
  var cached;
  var NOT_REGEX = `[\\[!*+?$^"'.\\\\/]+`;
  var not = createTextRegex(NOT_REGEX);
  module2.exports = function(nanomatch, options) {
    var parser = nanomatch.parser;
    var opts = parser.options;
    parser.state = {
      slashes: 0,
      paths: []
    };
    parser.ast.state = parser.state;
    parser.capture("prefix", function() {
      if (this.parsed)
        return;
      var m = this.match(/^\.[\\/]/);
      if (!m)
        return;
      this.state.strictOpen = !!this.options.strictOpen;
      this.state.addPrefix = true;
    }).capture("escape", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|([$^]))/);
      if (!m)
        return;
      return pos({
        type: "escape",
        val: m[2] || m[1]
      });
    }).capture("quoted", function() {
      var pos = this.position();
      var m = this.match(/^["']/);
      if (!m)
        return;
      var quote = m[0];
      if (this.input.indexOf(quote) === -1) {
        return pos({
          type: "escape",
          val: quote
        });
      }
      var tok = advanceTo(this.input, quote);
      this.consume(tok.len);
      return pos({
        type: "quoted",
        val: tok.esc
      });
    }).capture("not", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(this.notRegex || /^!+/);
      if (!m)
        return;
      var val = m[0];
      var isNegated = val.length % 2 === 1;
      if (parsed === "" && !isNegated) {
        val = "";
      }
      if (parsed === "" && isNegated && this.options.nonegate !== true) {
        this.bos.val = "(?!^(?:";
        this.append = ")$).*";
        val = "";
      }
      return pos({
        type: "not",
        val
      });
    }).capture("dot", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\.+/);
      if (!m)
        return;
      var val = m[0];
      this.state.dot = val === "." && (parsed === "" || parsed.slice(-1) === "/");
      return pos({
        type: "dot",
        dotfiles: this.state.dot,
        val
      });
    }).capture("plus", /^\+(?!\()/).capture("qmark", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m)
        return;
      this.state.metachar = true;
      this.state.qmark = true;
      return pos({
        type: "qmark",
        parsed,
        val: m[0]
      });
    }).capture("globstar", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
      if (!m)
        return;
      var type = opts.noglobstar !== true ? "globstar" : "star";
      var node = pos({type, parsed});
      this.state.metachar = true;
      while (this.input.slice(0, 4) === "/**/") {
        this.input = this.input.slice(3);
      }
      node.isInside = {
        brace: this.isInside("brace"),
        paren: this.isInside("paren")
      };
      if (type === "globstar") {
        this.state.globstar = true;
        node.val = "**";
      } else {
        this.state.star = true;
        node.val = "*";
      }
      return node;
    }).capture("star", function() {
      var pos = this.position();
      var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
      var m = this.match(starRe);
      if (!m)
        return;
      this.state.metachar = true;
      this.state.star = true;
      return pos({
        type: "star",
        val: m[0]
      });
    }).capture("slash", function() {
      var pos = this.position();
      var m = this.match(/^\//);
      if (!m)
        return;
      this.state.slashes++;
      return pos({
        type: "slash",
        val: m[0]
      });
    }).capture("backslash", function() {
      var pos = this.position();
      var m = this.match(/^\\(?![*+?(){}[\]'"])/);
      if (!m)
        return;
      var val = m[0];
      if (this.isInside("bracket")) {
        val = "\\";
      } else if (val.length > 1) {
        val = "\\\\";
      }
      return pos({
        type: "backslash",
        val
      });
    }).capture("square", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(/^\[([^!^\\])\]/);
      if (!m)
        return;
      return pos({
        type: "square",
        val: m[1]
      });
    }).capture("bracket", function() {
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
      if (!m)
        return;
      var val = m[0];
      var negated = m[1] ? "^" : "";
      var inner = (m[2] || "").replace(/\\\\+/, "\\\\");
      var close = m[3] || "";
      if (m[2] && inner.length < m[2].length) {
        val = val.replace(/\\\\+/, "\\\\");
      }
      var esc = this.input.slice(0, 2);
      if (inner === "" && esc === "\\]") {
        inner += esc;
        this.consume(2);
        var str = this.input;
        var idx = -1;
        var ch;
        while (ch = str[++idx]) {
          this.consume(1);
          if (ch === "]") {
            close = ch;
            break;
          }
          inner += ch;
        }
      }
      return pos({
        type: "bracket",
        val,
        escaped: close !== "]",
        negated,
        inner,
        close
      });
    }).capture("text", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0])
        return;
      return pos({
        type: "text",
        val: m[0]
      });
    });
    if (options && typeof options.parsers === "function") {
      options.parsers(nanomatch.parser);
    }
  };
  function advanceTo(input, endChar) {
    var ch = input.charAt(0);
    var tok = {len: 1, val: "", esc: ""};
    var idx = 0;
    function advance() {
      if (ch !== "\\") {
        tok.esc += "\\" + ch;
        tok.val += ch;
      }
      ch = input.charAt(++idx);
      tok.len++;
      if (ch === "\\") {
        advance();
        advance();
      }
    }
    while (ch && ch !== endChar) {
      advance();
    }
    return tok;
  }
  function createTextRegex(pattern) {
    if (cached)
      return cached;
    var opts = {contains: true, strictClose: false};
    var not2 = regexNot.create(pattern, opts);
    var re = toRegex("^(?:[*]\\((?=.)|" + not2 + ")", opts);
    return cached = re;
  }
  module2.exports.not = NOT_REGEX;
});

// node_modules/fragment-cache/index.js
var require_fragment_cache = __commonJS((exports2, module2) => {
  /*!
   * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
   *
   * Copyright (c) 2016-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var MapCache = require_map_cache();
  function FragmentCache(caches) {
    this.caches = caches || {};
  }
  FragmentCache.prototype = {
    cache: function(cacheName) {
      return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
    },
    set: function(cacheName, key, val) {
      var cache = this.cache(cacheName);
      cache.set(key, val);
      return cache;
    },
    has: function(cacheName, key) {
      return typeof this.get(cacheName, key) !== "undefined";
    },
    get: function(name, key) {
      var cache = this.cache(name);
      if (typeof key === "string") {
        return cache.get(key);
      }
      return cache;
    }
  };
  exports2 = module2.exports = FragmentCache;
});

// node_modules/nanomatch/lib/cache.js
var require_cache = __commonJS((exports2, module2) => {
  module2.exports = new (require_fragment_cache())();
});

// node_modules/arr-diff/index.js
var require_arr_diff = __commonJS((exports2, module2) => {
  /*!
   * arr-diff <https://github.com/jonschlinkert/arr-diff>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function diff(arr) {
    var len = arguments.length;
    var idx = 0;
    while (++idx < len) {
      arr = diffArray(arr, arguments[idx]);
    }
    return arr;
  };
  function diffArray(one, two) {
    if (!Array.isArray(two)) {
      return one.slice();
    }
    var tlen = two.length;
    var olen = one.length;
    var idx = -1;
    var arr = [];
    while (++idx < olen) {
      var ele = one[idx];
      var hasEle = false;
      for (var i = 0; i < tlen; i++) {
        var val = two[i];
        if (ele === val) {
          hasEle = true;
          break;
        }
      }
      if (hasEle === false) {
        arr.push(ele);
      }
    }
    return arr;
  }
});

// node_modules/object.pick/index.js
var require_object = __commonJS((exports2, module2) => {
  /*!
   * object.pick <https://github.com/jonschlinkert/object.pick>
   *
   * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
   * Licensed under the MIT License
   */
  "use strict";
  var isObject = require_isobject();
  module2.exports = function pick(obj, keys) {
    if (!isObject(obj) && typeof obj !== "function") {
      return {};
    }
    var res = {};
    if (typeof keys === "string") {
      if (keys in obj) {
        res[keys] = obj[keys];
      }
      return res;
    }
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
      var key = keys[idx];
      if (key in obj) {
        res[key] = obj[key];
      }
    }
    return res;
  };
});

// node_modules/nanomatch/lib/utils.js
var require_utils7 = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = module2.exports;
  var path = require("path");
  var isWindows = require_is_windows()();
  var Snapdragon = require_snapdragon();
  utils2.define = require_define_property();
  utils2.diff = require_arr_diff();
  utils2.extend = require_extend_shallow();
  utils2.pick = require_object();
  utils2.typeOf = require_kind_of();
  utils2.unique = require_array_unique();
  utils2.isEmptyString = function(val) {
    return String(val) === "" || String(val) === "./";
  };
  utils2.isWindows = function() {
    return path.sep === "\\" || isWindows === true;
  };
  utils2.last = function(arr, n) {
    return arr[arr.length - (n || 1)];
  };
  utils2.instantiate = function(ast, options) {
    var snapdragon;
    if (utils2.typeOf(ast) === "object" && ast.snapdragon) {
      snapdragon = ast.snapdragon;
    } else if (utils2.typeOf(options) === "object" && options.snapdragon) {
      snapdragon = options.snapdragon;
    } else {
      snapdragon = new Snapdragon(options);
    }
    utils2.define(snapdragon, "parse", function(str, options2) {
      var parsed = Snapdragon.prototype.parse.call(this, str, options2);
      parsed.input = str;
      var last = this.parser.stack.pop();
      if (last && this.options.strictErrors !== true) {
        var open = last.nodes[0];
        var inner = last.nodes[1];
        if (last.type === "bracket") {
          if (inner.val.charAt(0) === "[") {
            inner.val = "\\" + inner.val;
          }
        } else {
          open.val = "\\" + open.val;
          var sibling = open.parent.nodes[1];
          if (sibling.type === "star") {
            sibling.loose = true;
          }
        }
      }
      utils2.define(parsed, "parser", this.parser);
      return parsed;
    });
    return snapdragon;
  };
  utils2.createKey = function(pattern, options) {
    if (typeof options === "undefined") {
      return pattern;
    }
    var key = pattern;
    for (var prop in options) {
      if (options.hasOwnProperty(prop)) {
        key += ";" + prop + "=" + String(options[prop]);
      }
    }
    return key;
  };
  utils2.arrayify = function(val) {
    if (typeof val === "string")
      return [val];
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  utils2.isString = function(val) {
    return typeof val === "string";
  };
  utils2.isRegex = function(val) {
    return utils2.typeOf(val) === "regexp";
  };
  utils2.isObject = function(val) {
    return utils2.typeOf(val) === "object";
  };
  utils2.escapeRegex = function(str) {
    return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, "\\$&");
  };
  utils2.combineDupes = function(input, patterns) {
    patterns = utils2.arrayify(patterns).join("|").split("|");
    patterns = patterns.map(function(s) {
      return s.replace(/\\?([+*\\/])/g, "\\$1");
    });
    var substr = patterns.join("|");
    var regex = new RegExp("(" + substr + ")(?=\\1)", "g");
    return input.replace(regex, "");
  };
  utils2.hasSpecialChars = function(str) {
    return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
  };
  utils2.toPosixPath = function(str) {
    return str.replace(/\\+/g, "/");
  };
  utils2.unescape = function(str) {
    return utils2.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
  };
  utils2.stripDrive = function(fp) {
    return utils2.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, "/") : fp;
  };
  utils2.stripPrefix = function(str) {
    if (str.charAt(0) === "." && (str.charAt(1) === "/" || str.charAt(1) === "\\")) {
      return str.slice(2);
    }
    return str;
  };
  utils2.isSimpleChar = function(str) {
    return str.trim() === "" || str === ".";
  };
  utils2.isSlash = function(str) {
    return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
  };
  utils2.matchPath = function(pattern, options) {
    return options && options.contains ? utils2.containsPattern(pattern, options) : utils2.equalsPattern(pattern, options);
  };
  utils2._equals = function(filepath, unixPath, pattern) {
    return pattern === filepath || pattern === unixPath;
  };
  utils2._contains = function(filepath, unixPath, pattern) {
    return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
  };
  utils2.equalsPattern = function(pattern, options) {
    var unixify = utils2.unixify(options);
    options = options || {};
    return function fn(filepath) {
      var equal = utils2._equals(filepath, unixify(filepath), pattern);
      if (equal === true || options.nocase !== true) {
        return equal;
      }
      var lower = filepath.toLowerCase();
      return utils2._equals(lower, unixify(lower), pattern);
    };
  };
  utils2.containsPattern = function(pattern, options) {
    var unixify = utils2.unixify(options);
    options = options || {};
    return function(filepath) {
      var contains = utils2._contains(filepath, unixify(filepath), pattern);
      if (contains === true || options.nocase !== true) {
        return contains;
      }
      var lower = filepath.toLowerCase();
      return utils2._contains(lower, unixify(lower), pattern);
    };
  };
  utils2.matchBasename = function(re) {
    return function(filepath) {
      return re.test(filepath) || re.test(path.basename(filepath));
    };
  };
  utils2.identity = function(val) {
    return val;
  };
  utils2.value = function(str, unixify, options) {
    if (options && options.unixify === false) {
      return str;
    }
    if (options && typeof options.unixify === "function") {
      return options.unixify(str);
    }
    return unixify(str);
  };
  utils2.unixify = function(options) {
    var opts = options || {};
    return function(filepath) {
      if (opts.stripPrefix !== false) {
        filepath = utils2.stripPrefix(filepath);
      }
      if (opts.unescape === true) {
        filepath = utils2.unescape(filepath);
      }
      if (opts.unixify === true || utils2.isWindows()) {
        filepath = utils2.toPosixPath(filepath);
      }
      return filepath;
    };
  };
});

// node_modules/nanomatch/index.js
var require_nanomatch = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var toRegex = require_to_regex();
  var extend = require_extend_shallow();
  var compilers = require_compilers2();
  var parsers = require_parsers2();
  var cache = require_cache();
  var utils2 = require_utils7();
  var MAX_LENGTH = 1024 * 64;
  function nanomatch(list, patterns, options) {
    patterns = utils2.arrayify(patterns);
    list = utils2.arrayify(list);
    var len = patterns.length;
    if (list.length === 0 || len === 0) {
      return [];
    }
    if (len === 1) {
      return nanomatch.match(list, patterns[0], options);
    }
    var negated = false;
    var omit = [];
    var keep = [];
    var idx = -1;
    while (++idx < len) {
      var pattern = patterns[idx];
      if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
        omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
        negated = true;
      } else {
        keep.push.apply(keep, nanomatch.match(list, pattern, options));
      }
    }
    if (negated && keep.length === 0) {
      if (options && options.unixify === false) {
        keep = list.slice();
      } else {
        var unixify = utils2.unixify(options);
        for (var i = 0; i < list.length; i++) {
          keep.push(unixify(list[i]));
        }
      }
    }
    var matches = utils2.diff(keep, omit);
    if (!options || options.nodupes !== false) {
      return utils2.unique(matches);
    }
    return matches;
  }
  nanomatch.match = function(list, pattern, options) {
    if (Array.isArray(pattern)) {
      throw new TypeError("expected pattern to be a string");
    }
    var unixify = utils2.unixify(options);
    var isMatch = memoize("match", pattern, options, nanomatch.matcher);
    var matches = [];
    list = utils2.arrayify(list);
    var len = list.length;
    var idx = -1;
    while (++idx < len) {
      var ele = list[idx];
      if (ele === pattern || isMatch(ele)) {
        matches.push(utils2.value(ele, unixify, options));
      }
    }
    if (typeof options === "undefined") {
      return utils2.unique(matches);
    }
    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [options.unescape ? utils2.unescape(pattern) : pattern];
      }
    }
    if (options.ignore) {
      matches = nanomatch.not(matches, options.ignore, options);
    }
    return options.nodupes !== false ? utils2.unique(matches) : matches;
  };
  nanomatch.isMatch = function(str, pattern, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (utils2.isEmptyString(str) || utils2.isEmptyString(pattern)) {
      return false;
    }
    var equals = utils2.equalsPattern(options);
    if (equals(str)) {
      return true;
    }
    var isMatch = memoize("isMatch", pattern, options, nanomatch.matcher);
    return isMatch(str);
  };
  nanomatch.some = function(list, patterns, options) {
    if (typeof list === "string") {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (nanomatch(list[i], patterns, options).length === 1) {
        return true;
      }
    }
    return false;
  };
  nanomatch.every = function(list, patterns, options) {
    if (typeof list === "string") {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (nanomatch(list[i], patterns, options).length !== 1) {
        return false;
      }
    }
    return true;
  };
  nanomatch.any = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (utils2.isEmptyString(str) || utils2.isEmptyString(patterns)) {
      return false;
    }
    if (typeof patterns === "string") {
      patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
      if (nanomatch.isMatch(str, patterns[i], options)) {
        return true;
      }
    }
    return false;
  };
  nanomatch.all = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (typeof patterns === "string") {
      patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
      if (!nanomatch.isMatch(str, patterns[i], options)) {
        return false;
      }
    }
    return true;
  };
  nanomatch.not = function(list, patterns, options) {
    var opts = extend({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;
    list = utils2.arrayify(list);
    var matches = utils2.diff(list, nanomatch(list, patterns, opts));
    if (ignore) {
      matches = utils2.diff(matches, nanomatch(list, ignore));
    }
    return opts.nodupes !== false ? utils2.unique(matches) : matches;
  };
  nanomatch.contains = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (typeof patterns === "string") {
      if (utils2.isEmptyString(str) || utils2.isEmptyString(patterns)) {
        return false;
      }
      var equals = utils2.equalsPattern(patterns, options);
      if (equals(str)) {
        return true;
      }
      var contains = utils2.containsPattern(patterns, options);
      if (contains(str)) {
        return true;
      }
    }
    var opts = extend({}, options, {contains: true});
    return nanomatch.any(str, patterns, opts);
  };
  nanomatch.matchBase = function(pattern, options) {
    if (pattern && pattern.indexOf("/") !== -1 || !options)
      return false;
    return options.basename === true || options.matchBase === true;
  };
  nanomatch.matchKeys = function(obj, patterns, options) {
    if (!utils2.isObject(obj)) {
      throw new TypeError("expected the first argument to be an object");
    }
    var keys = nanomatch(Object.keys(obj), patterns, options);
    return utils2.pick(obj, keys);
  };
  nanomatch.matcher = function matcher(pattern, options) {
    if (utils2.isEmptyString(pattern)) {
      return function() {
        return false;
      };
    }
    if (Array.isArray(pattern)) {
      return compose(pattern, options, matcher);
    }
    if (pattern instanceof RegExp) {
      return test(pattern);
    }
    if (!utils2.isString(pattern)) {
      throw new TypeError("expected pattern to be an array, string or regex");
    }
    if (!utils2.hasSpecialChars(pattern)) {
      if (options && options.nocase === true) {
        pattern = pattern.toLowerCase();
      }
      return utils2.matchPath(pattern, options);
    }
    var re = nanomatch.makeRe(pattern, options);
    if (nanomatch.matchBase(pattern, options)) {
      return utils2.matchBasename(re, options);
    }
    function test(regex) {
      var equals = utils2.equalsPattern(options);
      var unixify = utils2.unixify(options);
      return function(str) {
        if (equals(str)) {
          return true;
        }
        if (regex.test(unixify(str))) {
          return true;
        }
        return false;
      };
    }
    var matcherFn = test(re);
    utils2.define(matcherFn, "result", re.result);
    return matcherFn;
  };
  nanomatch.capture = function(pattern, str, options) {
    var re = nanomatch.makeRe(pattern, extend({capture: true}, options));
    var unixify = utils2.unixify(options);
    function match() {
      return function(string) {
        var match2 = re.exec(unixify(string));
        if (!match2) {
          return null;
        }
        return match2.slice(1);
      };
    }
    var capture = memoize("capture", pattern, options, match);
    return capture(str);
  };
  nanomatch.makeRe = function(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    if (pattern.length > MAX_LENGTH) {
      throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
    }
    function makeRe() {
      var opts = utils2.extend({wrap: false}, options);
      var result = nanomatch.create(pattern, opts);
      var regex = toRegex(result.output, opts);
      utils2.define(regex, "result", result);
      return regex;
    }
    return memoize("makeRe", pattern, options, makeRe);
  };
  nanomatch.create = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    function create() {
      return nanomatch.compile(nanomatch.parse(pattern, options), options);
    }
    return memoize("create", pattern, options, create);
  };
  nanomatch.parse = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    function parse() {
      var snapdragon = utils2.instantiate(null, options);
      parsers(snapdragon, options);
      var ast = snapdragon.parse(pattern, options);
      utils2.define(ast, "snapdragon", snapdragon);
      ast.input = pattern;
      return ast;
    }
    return memoize("parse", pattern, options, parse);
  };
  nanomatch.compile = function(ast, options) {
    if (typeof ast === "string") {
      ast = nanomatch.parse(ast, options);
    }
    function compile() {
      var snapdragon = utils2.instantiate(ast, options);
      compilers(snapdragon, options);
      return snapdragon.compile(ast, options);
    }
    return memoize("compile", ast.input, options, compile);
  };
  nanomatch.clearCache = function() {
    nanomatch.cache.__data__ = {};
  };
  function compose(patterns, options, matcher) {
    var matchers;
    return memoize("compose", String(patterns), options, function() {
      return function(file) {
        if (!matchers) {
          matchers = [];
          for (var i = 0; i < patterns.length; i++) {
            matchers.push(matcher(patterns[i], options));
          }
        }
        var len = matchers.length;
        while (len--) {
          if (matchers[len](file) === true) {
            return true;
          }
        }
        return false;
      };
    });
  }
  function memoize(type, pattern, options, fn) {
    var key = utils2.createKey(type + "=" + pattern, options);
    if (options && options.cache === false) {
      return fn(pattern, options);
    }
    if (cache.has(type, key)) {
      return cache.get(type, key);
    }
    var val = fn(pattern, options);
    cache.set(type, key, val);
    return val;
  }
  nanomatch.compilers = compilers;
  nanomatch.parsers = parsers;
  nanomatch.cache = cache;
  module2.exports = nanomatch;
});

// node_modules/extglob/node_modules/extend-shallow/index.js
var require_extend_shallow6 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/posix-character-classes/index.js
var require_posix_character_classes = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
});

// node_modules/expand-brackets/lib/compilers.js
var require_compilers3 = __commonJS((exports2, module2) => {
  "use strict";
  var posix = require_posix_character_classes();
  module2.exports = function(brackets) {
    brackets.compiler.set("escape", function(node) {
      return this.emit("\\" + node.val.replace(/^\\/, ""), node);
    }).set("text", function(node) {
      return this.emit(node.val.replace(/([{}])/g, "\\$1"), node);
    }).set("posix", function(node) {
      if (node.val === "[::]") {
        return this.emit("\\[::\\]", node);
      }
      var val = posix[node.inner];
      if (typeof val === "undefined") {
        val = "[" + node.inner + "]";
      }
      return this.emit(val, node);
    }).set("bracket", function(node) {
      return this.mapVisit(node.nodes);
    }).set("bracket.open", function(node) {
      return this.emit(node.val, node);
    }).set("bracket.inner", function(node) {
      var inner = node.val;
      if (inner === "[" || inner === "]") {
        return this.emit("\\" + node.val, node);
      }
      if (inner === "^]") {
        return this.emit("^\\]", node);
      }
      if (inner === "^") {
        return this.emit("^", node);
      }
      if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
        inner = inner.split("-").join("\\-");
      }
      var isNegated = inner.charAt(0) === "^";
      if (isNegated && inner.indexOf("/") === -1) {
        inner += "/";
      }
      if (isNegated && inner.indexOf(".") === -1) {
        inner += ".";
      }
      inner = inner.replace(/\\([1-9])/g, "$1");
      return this.emit(inner, node);
    }).set("bracket.close", function(node) {
      var val = node.val.replace(/^\\/, "");
      if (node.parent.escaped === true) {
        return this.emit("\\" + val, node);
      }
      return this.emit(val, node);
    });
  };
});

// node_modules/expand-brackets/lib/utils.js
var require_utils8 = __commonJS((exports2) => {
  "use strict";
  var toRegex = require_to_regex();
  var regexNot = require_regex_not();
  var cached;
  exports2.last = function(arr) {
    return arr[arr.length - 1];
  };
  exports2.createRegex = function(pattern, include) {
    if (cached)
      return cached;
    var opts = {contains: true, strictClose: false};
    var not = regexNot.create(pattern, opts);
    var re;
    if (typeof include === "string") {
      re = toRegex("^(?:" + include + "|" + not + ")", opts);
    } else {
      re = toRegex(not, opts);
    }
    return cached = re;
  };
});

// node_modules/expand-brackets/node_modules/define-property/index.js
var require_define_property8 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor4();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/expand-brackets/lib/parsers.js
var require_parsers3 = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = require_utils8();
  var define2 = require_define_property8();
  var TEXT_REGEX = "(\\[(?=.*\\])|\\])+";
  var not = utils2.createRegex(TEXT_REGEX);
  function parsers(brackets) {
    brackets.state = brackets.state || {};
    brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
    brackets.parser.capture("escape", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m)
        return;
      return pos({
        type: "escape",
        val: m[0]
      });
    }).capture("text", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0])
        return;
      return pos({
        type: "text",
        val: m[0]
      });
    }).capture("posix", function() {
      var pos = this.position();
      var m = this.match(/^\[:(.*?):\](?=.*\])/);
      if (!m)
        return;
      var inside = this.isInside("bracket");
      if (inside) {
        brackets.posix++;
      }
      return pos({
        type: "posix",
        insideBracket: inside,
        inner: m[1],
        val: m[0]
      });
    }).capture("bracket", function() {
    }).capture("bracket.open", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\[(?=.*\])/);
      if (!m)
        return;
      var prev = this.prev();
      var last = utils2.last(prev.nodes);
      if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
        last.val = last.val.slice(0, last.val.length - 1);
        return pos({
          type: "escape",
          val: m[0]
        });
      }
      var open = pos({
        type: "bracket.open",
        val: m[0]
      });
      if (last.type === "bracket.open" || this.isInside("bracket")) {
        open.val = "\\" + open.val;
        open.type = "bracket.inner";
        open.escaped = true;
        return open;
      }
      var node = pos({
        type: "bracket",
        nodes: [open]
      });
      define2(node, "parent", prev);
      define2(open, "parent", node);
      this.push("bracket", node);
      prev.nodes.push(node);
    }).capture("bracket.inner", function() {
      if (!this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0])
        return;
      var next = this.input.charAt(0);
      var val = m[0];
      var node = pos({
        type: "bracket.inner",
        val
      });
      if (val === "\\\\") {
        return node;
      }
      var first = val.charAt(0);
      var last = val.slice(-1);
      if (first === "!") {
        val = "^" + val.slice(1);
      }
      if (last === "\\" || val === "^" && next === "]") {
        val += this.input[0];
        this.consume(1);
      }
      node.val = val;
      return node;
    }).capture("bracket.close", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\]/);
      if (!m)
        return;
      var prev = this.prev();
      var last = utils2.last(prev.nodes);
      if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
        last.val = last.val.slice(0, last.val.length - 1);
        return pos({
          type: "escape",
          val: m[0]
        });
      }
      var node = pos({
        type: "bracket.close",
        rest: this.input,
        val: m[0]
      });
      if (last.type === "bracket.open") {
        node.type = "bracket.inner";
        node.escaped = true;
        return node;
      }
      var bracket = this.pop("bracket");
      if (!this.isType(bracket, "bracket")) {
        if (this.options.strict) {
          throw new Error('missing opening "["');
        }
        node.type = "bracket.inner";
        node.escaped = true;
        return node;
      }
      bracket.nodes.push(node);
      define2(node, "parent", bracket);
    });
  }
  module2.exports = parsers;
  module2.exports.TEXT_REGEX = TEXT_REGEX;
});

// node_modules/expand-brackets/node_modules/ms/index.js
var require_ms3 = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/expand-brackets/node_modules/debug/src/debug.js
var require_debug2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = require_ms3();
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports2.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports2.enabled(namespace);
    debug.useColors = exports2.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports2.init === "function") {
      exports2.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports2.skips.length; i < len; i++) {
      if (exports2.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports2.names.length; i < len; i++) {
      if (exports2.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/expand-brackets/node_modules/debug/src/browser.js
var require_browser3 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = require_debug2();
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
});

// node_modules/expand-brackets/node_modules/debug/src/node.js
var require_node4 = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2 = module2.exports = require_debug2();
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
  }
  exports2.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports2.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  [3" + c + ";1m" + name + " [0m";
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + "\n");
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = require("fs");
        stream2 = new fs.SyncWriteStream(fd2, {autoClose: false});
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports2.inspectOpts);
    for (var i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  exports2.enable(load());
});

// node_modules/expand-brackets/node_modules/debug/src/index.js
var require_src4 = __commonJS((exports2, module2) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = require_browser3();
  } else {
    module2.exports = require_node4();
  }
});

// node_modules/expand-brackets/node_modules/extend-shallow/index.js
var require_extend_shallow7 = __commonJS((exports2, module2) => {
  "use strict";
  var isObject = require_is_extendable2();
  module2.exports = function extend(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/expand-brackets/index.js
var require_expand_brackets = __commonJS((exports2, module2) => {
  "use strict";
  var compilers = require_compilers3();
  var parsers = require_parsers3();
  var debug = require_src4()("expand-brackets");
  var extend = require_extend_shallow7();
  var Snapdragon = require_snapdragon();
  var toRegex = require_to_regex();
  function brackets(pattern, options) {
    debug("initializing from <%s>", __filename);
    var res = brackets.create(pattern, options);
    return res.output;
  }
  brackets.match = function(arr, pattern, options) {
    arr = [].concat(arr);
    var opts = extend({}, options);
    var isMatch = brackets.matcher(pattern, opts);
    var len = arr.length;
    var idx = -1;
    var res = [];
    while (++idx < len) {
      var ele = arr[idx];
      if (isMatch(ele)) {
        res.push(ele);
      }
    }
    if (res.length === 0) {
      if (opts.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (opts.nonull === true || opts.nullglob === true) {
        return [pattern.split("\\").join("")];
      }
    }
    return res;
  };
  brackets.isMatch = function(str, pattern, options) {
    return brackets.matcher(pattern, options)(str);
  };
  brackets.matcher = function(pattern, options) {
    var re = brackets.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  };
  brackets.makeRe = function(pattern, options) {
    var res = brackets.create(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(res.output, opts);
  };
  brackets.create = function(pattern, options) {
    var snapdragon = options && options.snapdragon || new Snapdragon(options);
    compilers(snapdragon);
    parsers(snapdragon);
    var ast = snapdragon.parse(pattern, options);
    ast.input = pattern;
    var res = snapdragon.compile(ast, options);
    res.input = pattern;
    return res;
  };
  brackets.compilers = compilers;
  brackets.parsers = parsers;
  module2.exports = brackets;
});

// node_modules/extglob/lib/compilers.js
var require_compilers4 = __commonJS((exports2, module2) => {
  "use strict";
  var brackets = require_expand_brackets();
  module2.exports = function(extglob) {
    function star() {
      if (typeof extglob.options.star === "function") {
        return extglob.options.star.apply(this, arguments);
      }
      if (typeof extglob.options.star === "string") {
        return extglob.options.star;
      }
      return ".*?";
    }
    extglob.use(brackets.compilers);
    extglob.compiler.set("escape", function(node) {
      return this.emit(node.val, node);
    }).set("dot", function(node) {
      return this.emit("\\" + node.val, node);
    }).set("qmark", function(node) {
      var val = "[^\\\\/.]";
      var prev = this.prev();
      if (node.parsed.slice(-1) === "(") {
        var ch = node.rest.charAt(0);
        if (ch !== "!" && ch !== "=" && ch !== ":") {
          return this.emit(val, node);
        }
        return this.emit(node.val, node);
      }
      if (prev.type === "text" && prev.val) {
        return this.emit(val, node);
      }
      if (node.val.length > 1) {
        val += "{" + node.val.length + "}";
      }
      return this.emit(val, node);
    }).set("plus", function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === "]" || prev === ")") {
        return this.emit(node.val, node);
      }
      var ch = this.output.slice(-1);
      if (!this.output || /[?*+]/.test(ch) && node.parent.type !== "bracket") {
        return this.emit("\\+", node);
      }
      if (/\w/.test(ch) && !node.inside) {
        return this.emit("+\\+?", node);
      }
      return this.emit("+", node);
    }).set("star", function(node) {
      var prev = this.prev();
      var prefix = prev.type !== "text" && prev.type !== "escape" ? "(?!\\.)" : "";
      return this.emit(prefix + star.call(this, node), node);
    }).set("paren", function(node) {
      return this.mapVisit(node.nodes);
    }).set("paren.open", function(node) {
      var capture = this.options.capture ? "(" : "";
      switch (node.parent.prefix) {
        case "!":
        case "^":
          return this.emit(capture + "(?:(?!(?:", node);
        case "*":
        case "+":
        case "?":
        case "@":
          return this.emit(capture + "(?:", node);
        default: {
          var val = node.val;
          if (this.options.bash === true) {
            val = "\\" + val;
          } else if (!this.options.capture && val === "(" && node.parent.rest[0] !== "?") {
            val += "?:";
          }
          return this.emit(val, node);
        }
      }
    }).set("paren.close", function(node) {
      var capture = this.options.capture ? ")" : "";
      switch (node.prefix) {
        case "!":
        case "^":
          var prefix = /^(\)|$)/.test(node.rest) ? "$" : "";
          var str = star.call(this, node);
          if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
            str = ".*?";
          }
          return this.emit(prefix + ("))" + str + ")") + capture, node);
        case "*":
        case "+":
        case "?":
          return this.emit(")" + node.prefix + capture, node);
        case "@":
          return this.emit(")" + capture, node);
        default: {
          var val = (this.options.bash === true ? "\\" : "") + ")";
          return this.emit(val, node);
        }
      }
    }).set("text", function(node) {
      var val = node.val.replace(/[\[\]]/g, "\\$&");
      return this.emit(val, node);
    });
  };
});

// node_modules/extglob/node_modules/is-accessor-descriptor/index.js
var require_is_accessor_descriptor5 = __commonJS((exports2, module2) => {
  /*!
   * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var accessor = {
    get: "function",
    set: "function",
    configurable: "boolean",
    enumerable: "boolean"
  };
  function isAccessorDescriptor(obj, prop) {
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (has(obj, "value") || has(obj, "writable")) {
      return false;
    }
    if (!has(obj, "get") || typeof obj.get !== "function") {
      return false;
    }
    if (has(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
      return false;
    }
    for (var key in obj) {
      if (!accessor.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === accessor[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  }
  function has(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  module2.exports = isAccessorDescriptor;
});

// node_modules/extglob/node_modules/is-data-descriptor/index.js
var require_is_data_descriptor5 = __commonJS((exports2, module2) => {
  /*!
   * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  module2.exports = function isDataDescriptor(obj, prop) {
    var data = {
      configurable: "boolean",
      enumerable: "boolean",
      writable: "boolean"
    };
    if (typeOf(obj) !== "object") {
      return false;
    }
    if (typeof prop === "string") {
      var val = Object.getOwnPropertyDescriptor(obj, prop);
      return typeof val !== "undefined";
    }
    if (!("value" in obj) && !("writable" in obj)) {
      return false;
    }
    for (var key in obj) {
      if (key === "value")
        continue;
      if (!data.hasOwnProperty(key)) {
        continue;
      }
      if (typeOf(obj[key]) === data[key]) {
        continue;
      }
      if (typeof obj[key] !== "undefined") {
        return false;
      }
    }
    return true;
  };
});

// node_modules/extglob/node_modules/is-descriptor/index.js
var require_is_descriptor5 = __commonJS((exports2, module2) => {
  /*!
   * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var typeOf = require_kind_of();
  var isAccessor = require_is_accessor_descriptor5();
  var isData = require_is_data_descriptor5();
  module2.exports = function isDescriptor(obj, key) {
    if (typeOf(obj) !== "object") {
      return false;
    }
    if ("get" in obj) {
      return isAccessor(obj, key);
    }
    return isData(obj, key);
  };
});

// node_modules/extglob/node_modules/define-property/index.js
var require_define_property9 = __commonJS((exports2, module2) => {
  /*!
   * define-property <https://github.com/jonschlinkert/define-property>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isDescriptor = require_is_descriptor5();
  module2.exports = function defineProperty(obj, prop, val) {
    if (typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("expected an object or function.");
    }
    if (typeof prop !== "string") {
      throw new TypeError("expected `prop` to be a string.");
    }
    if (isDescriptor(val) && ("set" in val || "get" in val)) {
      return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: false,
      writable: true,
      value: val
    });
  };
});

// node_modules/extglob/lib/utils.js
var require_utils9 = __commonJS((exports2, module2) => {
  "use strict";
  var regex = require_regex_not();
  var Cache = require_fragment_cache();
  var utils2 = module2.exports;
  var cache = utils2.cache = new Cache();
  utils2.arrayify = function(val) {
    if (!Array.isArray(val)) {
      return [val];
    }
    return val;
  };
  utils2.memoize = function(type, pattern, options, fn) {
    var key = utils2.createKey(type + pattern, options);
    if (cache.has(type, key)) {
      return cache.get(type, key);
    }
    var val = fn(pattern, options);
    if (options && options.cache === false) {
      return val;
    }
    cache.set(type, key, val);
    return val;
  };
  utils2.createKey = function(pattern, options) {
    var key = pattern;
    if (typeof options === "undefined") {
      return key;
    }
    for (var prop in options) {
      key += ";" + prop + "=" + String(options[prop]);
    }
    return key;
  };
  utils2.createRegex = function(str) {
    var opts = {contains: true, strictClose: false};
    return regex(str, opts);
  };
});

// node_modules/extglob/lib/parsers.js
var require_parsers4 = __commonJS((exports2, module2) => {
  "use strict";
  var brackets = require_expand_brackets();
  var define2 = require_define_property9();
  var utils2 = require_utils9();
  var TEXT_REGEX = "([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+";
  var not = utils2.createRegex(TEXT_REGEX);
  function parsers(extglob) {
    extglob.state = extglob.state || {};
    extglob.use(brackets.parsers);
    extglob.parser.sets.paren = extglob.parser.sets.paren || [];
    extglob.parser.capture("paren.open", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^([!@*?+])?\(/);
      if (!m)
        return;
      var prev = this.prev();
      var prefix = m[1];
      var val = m[0];
      var open = pos({
        type: "paren.open",
        parsed,
        val
      });
      var node = pos({
        type: "paren",
        prefix,
        nodes: [open]
      });
      if (prefix === "!" && prev.type === "paren" && prev.prefix === "!") {
        prev.prefix = "@";
        node.prefix = "@";
      }
      define2(node, "rest", this.input);
      define2(node, "parsed", parsed);
      define2(node, "parent", prev);
      define2(open, "parent", node);
      this.push("paren", node);
      prev.nodes.push(node);
    }).capture("paren.close", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\)/);
      if (!m)
        return;
      var parent = this.pop("paren");
      var node = pos({
        type: "paren.close",
        rest: this.input,
        parsed,
        val: m[0]
      });
      if (!this.isType(parent, "paren")) {
        if (this.options.strict) {
          throw new Error('missing opening paren: "("');
        }
        node.escaped = true;
        return node;
      }
      node.prefix = parent.prefix;
      parent.nodes.push(node);
      define2(node, "parent", parent);
    }).capture("escape", function() {
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m)
        return;
      return pos({
        type: "escape",
        val: m[0],
        ch: m[1]
      });
    }).capture("qmark", function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m)
        return;
      extglob.state.metachar = true;
      return pos({
        type: "qmark",
        rest: this.input,
        parsed,
        val: m[0]
      });
    }).capture("star", /^\*(?!\()/).capture("plus", /^\+(?!\()/).capture("dot", /^\./).capture("text", not);
  }
  module2.exports.TEXT_REGEX = TEXT_REGEX;
  module2.exports = parsers;
});

// node_modules/extglob/lib/extglob.js
var require_extglob = __commonJS((exports2, module2) => {
  "use strict";
  var Snapdragon = require_snapdragon();
  var define2 = require_define_property9();
  var extend = require_extend_shallow6();
  var compilers = require_compilers4();
  var parsers = require_parsers4();
  function Extglob(options) {
    this.options = extend({source: "extglob"}, options);
    this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
    this.snapdragon.patterns = this.snapdragon.patterns || {};
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;
    compilers(this.snapdragon);
    parsers(this.snapdragon);
    define2(this.snapdragon, "parse", function(str, options2) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      parsed.input = str;
      var last = this.parser.stack.pop();
      if (last && this.options.strict !== true) {
        var node = last.nodes[0];
        node.val = "\\" + node.val;
        var sibling = node.parent.nodes[1];
        if (sibling.type === "star") {
          sibling.loose = true;
        }
      }
      define2(parsed, "parser", this.parser);
      return parsed;
    });
    define2(this, "parse", function(ast, options2) {
      return this.snapdragon.parse.apply(this.snapdragon, arguments);
    });
    define2(this, "compile", function(ast, options2) {
      return this.snapdragon.compile.apply(this.snapdragon, arguments);
    });
  }
  module2.exports = Extglob;
});

// node_modules/extglob/index.js
var require_extglob2 = __commonJS((exports2, module2) => {
  "use strict";
  var extend = require_extend_shallow6();
  var unique = require_array_unique();
  var toRegex = require_to_regex();
  var compilers = require_compilers4();
  var parsers = require_parsers4();
  var Extglob = require_extglob();
  var utils2 = require_utils9();
  var MAX_LENGTH = 1024 * 64;
  function extglob(pattern, options) {
    return extglob.create(pattern, options).output;
  }
  extglob.match = function(list, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    list = utils2.arrayify(list);
    var isMatch = extglob.matcher(pattern, options);
    var len = list.length;
    var idx = -1;
    var matches = [];
    while (++idx < len) {
      var ele = list[idx];
      if (isMatch(ele)) {
        matches.push(ele);
      }
    }
    if (typeof options === "undefined") {
      return unique(matches);
    }
    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [pattern.split("\\").join("")];
      }
    }
    return options.nodupes !== false ? unique(matches) : matches;
  };
  extglob.isMatch = function(str, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (pattern === str) {
      return true;
    }
    if (pattern === "" || pattern === " " || pattern === ".") {
      return pattern === str;
    }
    var isMatch = utils2.memoize("isMatch", pattern, options, extglob.matcher);
    return isMatch(str);
  };
  extglob.contains = function(str, pattern, options) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (pattern === "" || pattern === " " || pattern === ".") {
      return pattern === str;
    }
    var opts = extend({}, options, {contains: true});
    opts.strictClose = false;
    opts.strictOpen = false;
    return extglob.isMatch(str, pattern, opts);
  };
  extglob.matcher = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    function matcher() {
      var re = extglob.makeRe(pattern, options);
      return function(str) {
        return re.test(str);
      };
    }
    return utils2.memoize("matcher", pattern, options, matcher);
  };
  extglob.create = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    function create() {
      var ext = new Extglob(options);
      var ast = ext.parse(pattern, options);
      return ext.compile(ast, options);
    }
    return utils2.memoize("create", pattern, options, create);
  };
  extglob.capture = function(pattern, str, options) {
    var re = extglob.makeRe(pattern, extend({capture: true}, options));
    function match() {
      return function(string) {
        var match2 = re.exec(string);
        if (!match2) {
          return null;
        }
        return match2.slice(1);
      };
    }
    var capture = utils2.memoize("capture", pattern, options, match);
    return capture(str);
  };
  extglob.makeRe = function(pattern, options) {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    if (pattern.length > MAX_LENGTH) {
      throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
    }
    function makeRe() {
      var opts = extend({strictErrors: false}, options);
      if (opts.strictErrors === true)
        opts.strict = true;
      var res = extglob.create(pattern, opts);
      return toRegex(res.output, opts);
    }
    var regex = utils2.memoize("makeRe", pattern, options, makeRe);
    if (regex.source.length > MAX_LENGTH) {
      throw new SyntaxError("potentially malicious regex detected");
    }
    return regex;
  };
  extglob.cache = utils2.cache;
  extglob.clearCache = function() {
    extglob.cache.__data__ = {};
  };
  extglob.Extglob = Extglob;
  extglob.compilers = compilers;
  extglob.parsers = parsers;
  module2.exports = extglob;
});

// node_modules/findup-sync/node_modules/micromatch/lib/compilers.js
var require_compilers5 = __commonJS((exports2, module2) => {
  "use strict";
  var nanomatch = require_nanomatch();
  var extglob = require_extglob2();
  module2.exports = function(snapdragon) {
    var compilers = snapdragon.compiler.compilers;
    var opts = snapdragon.options;
    snapdragon.use(nanomatch.compilers);
    var escape = compilers.escape;
    var qmark = compilers.qmark;
    var slash = compilers.slash;
    var star = compilers.star;
    var text = compilers.text;
    var plus = compilers.plus;
    var dot = compilers.dot;
    if (opts.extglob === false || opts.noext === true) {
      snapdragon.compiler.use(escapeExtglobs);
    } else {
      snapdragon.use(extglob.compilers);
    }
    snapdragon.use(function() {
      this.options.star = this.options.star || function() {
        return "[^\\\\/]*?";
      };
    });
    snapdragon.compiler.set("dot", dot).set("escape", escape).set("plus", plus).set("slash", slash).set("qmark", qmark).set("star", star).set("text", text);
  };
  function escapeExtglobs(compiler) {
    compiler.set("paren", function(node) {
      var val = "";
      visit(node, function(tok) {
        if (tok.val)
          val += (/^\W/.test(tok.val) ? "\\" : "") + tok.val;
      });
      return this.emit(val, node);
    });
    function visit(node, fn) {
      return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
    }
    function mapVisit(nodes, fn) {
      var len = nodes.length;
      var idx = -1;
      while (++idx < len) {
        visit(nodes[idx], fn);
      }
    }
  }
});

// node_modules/findup-sync/node_modules/micromatch/lib/parsers.js
var require_parsers5 = __commonJS((exports2, module2) => {
  "use strict";
  var extglob = require_extglob2();
  var nanomatch = require_nanomatch();
  var regexNot = require_regex_not();
  var toRegex = require_to_regex();
  var not;
  var TEXT = "([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+";
  var createNotRegex = function(opts) {
    return not || (not = textRegex(TEXT));
  };
  module2.exports = function(snapdragon) {
    var parsers = snapdragon.parser.parsers;
    snapdragon.use(nanomatch.parsers);
    var escape = parsers.escape;
    var slash = parsers.slash;
    var qmark = parsers.qmark;
    var plus = parsers.plus;
    var star = parsers.star;
    var dot = parsers.dot;
    snapdragon.use(extglob.parsers);
    snapdragon.parser.use(function() {
      this.notRegex = /^\!+(?!\()/;
    }).capture("escape", escape).capture("slash", slash).capture("qmark", qmark).capture("star", star).capture("plus", plus).capture("dot", dot).capture("text", function() {
      if (this.isInside("bracket"))
        return;
      var pos = this.position();
      var m = this.match(createNotRegex(this.options));
      if (!m || !m[0])
        return;
      var val = m[0].replace(/([[\]^$])/g, "\\$1");
      return pos({
        type: "text",
        val
      });
    });
  };
  function textRegex(pattern) {
    var notStr = regexNot.create(pattern, {contains: true, strictClose: false});
    var prefix = "(?:[\\^]|\\\\|";
    return toRegex(prefix + notStr + ")", {strictClose: false});
  }
});

// node_modules/findup-sync/node_modules/micromatch/lib/cache.js
var require_cache2 = __commonJS((exports2, module2) => {
  module2.exports = new (require_fragment_cache())();
});

// node_modules/findup-sync/node_modules/micromatch/lib/utils.js
var require_utils10 = __commonJS((exports2, module2) => {
  "use strict";
  var utils2 = module2.exports;
  var path = require("path");
  var Snapdragon = require_snapdragon();
  utils2.define = require_define_property();
  utils2.diff = require_arr_diff();
  utils2.extend = require_extend_shallow();
  utils2.pick = require_object();
  utils2.typeOf = require_kind_of();
  utils2.unique = require_array_unique();
  utils2.isWindows = function() {
    return path.sep === "\\" || process.platform === "win32";
  };
  utils2.instantiate = function(ast, options) {
    var snapdragon;
    if (utils2.typeOf(ast) === "object" && ast.snapdragon) {
      snapdragon = ast.snapdragon;
    } else if (utils2.typeOf(options) === "object" && options.snapdragon) {
      snapdragon = options.snapdragon;
    } else {
      snapdragon = new Snapdragon(options);
    }
    utils2.define(snapdragon, "parse", function(str, options2) {
      var parsed = Snapdragon.prototype.parse.apply(this, arguments);
      parsed.input = str;
      var last = this.parser.stack.pop();
      if (last && this.options.strictErrors !== true) {
        var open = last.nodes[0];
        var inner = last.nodes[1];
        if (last.type === "bracket") {
          if (inner.val.charAt(0) === "[") {
            inner.val = "\\" + inner.val;
          }
        } else {
          open.val = "\\" + open.val;
          var sibling = open.parent.nodes[1];
          if (sibling.type === "star") {
            sibling.loose = true;
          }
        }
      }
      utils2.define(parsed, "parser", this.parser);
      return parsed;
    });
    return snapdragon;
  };
  utils2.createKey = function(pattern, options) {
    if (utils2.typeOf(options) !== "object") {
      return pattern;
    }
    var val = pattern;
    var keys = Object.keys(options);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      val += ";" + key + "=" + String(options[key]);
    }
    return val;
  };
  utils2.arrayify = function(val) {
    if (typeof val === "string")
      return [val];
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  utils2.isString = function(val) {
    return typeof val === "string";
  };
  utils2.isObject = function(val) {
    return utils2.typeOf(val) === "object";
  };
  utils2.hasSpecialChars = function(str) {
    return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
  };
  utils2.escapeRegex = function(str) {
    return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, "\\$&");
  };
  utils2.toPosixPath = function(str) {
    return str.replace(/\\+/g, "/");
  };
  utils2.unescape = function(str) {
    return utils2.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
  };
  utils2.stripPrefix = function(str) {
    if (str.charAt(0) !== ".") {
      return str;
    }
    var ch = str.charAt(1);
    if (utils2.isSlash(ch)) {
      return str.slice(2);
    }
    return str;
  };
  utils2.isSlash = function(str) {
    return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
  };
  utils2.matchPath = function(pattern, options) {
    return options && options.contains ? utils2.containsPattern(pattern, options) : utils2.equalsPattern(pattern, options);
  };
  utils2._equals = function(filepath, unixPath, pattern) {
    return pattern === filepath || pattern === unixPath;
  };
  utils2._contains = function(filepath, unixPath, pattern) {
    return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
  };
  utils2.equalsPattern = function(pattern, options) {
    var unixify = utils2.unixify(options);
    options = options || {};
    return function fn(filepath) {
      var equal = utils2._equals(filepath, unixify(filepath), pattern);
      if (equal === true || options.nocase !== true) {
        return equal;
      }
      var lower = filepath.toLowerCase();
      return utils2._equals(lower, unixify(lower), pattern);
    };
  };
  utils2.containsPattern = function(pattern, options) {
    var unixify = utils2.unixify(options);
    options = options || {};
    return function(filepath) {
      var contains = utils2._contains(filepath, unixify(filepath), pattern);
      if (contains === true || options.nocase !== true) {
        return contains;
      }
      var lower = filepath.toLowerCase();
      return utils2._contains(lower, unixify(lower), pattern);
    };
  };
  utils2.matchBasename = function(re) {
    return function(filepath) {
      return re.test(path.basename(filepath));
    };
  };
  utils2.value = function(str, unixify, options) {
    if (options && options.unixify === false) {
      return str;
    }
    return unixify(str);
  };
  utils2.unixify = function(options) {
    options = options || {};
    return function(filepath) {
      if (utils2.isWindows() || options.unixify === true) {
        filepath = utils2.toPosixPath(filepath);
      }
      if (options.stripPrefix !== false) {
        filepath = utils2.stripPrefix(filepath);
      }
      if (options.unescape === true) {
        filepath = utils2.unescape(filepath);
      }
      return filepath;
    };
  };
});

// node_modules/findup-sync/node_modules/micromatch/index.js
var require_micromatch2 = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var braces = require_braces3();
  var toRegex = require_to_regex();
  var extend = require_extend_shallow();
  var compilers = require_compilers5();
  var parsers = require_parsers5();
  var cache = require_cache2();
  var utils2 = require_utils10();
  var MAX_LENGTH = 1024 * 64;
  function micromatch(list, patterns, options) {
    patterns = utils2.arrayify(patterns);
    list = utils2.arrayify(list);
    var len = patterns.length;
    if (list.length === 0 || len === 0) {
      return [];
    }
    if (len === 1) {
      return micromatch.match(list, patterns[0], options);
    }
    var omit = [];
    var keep = [];
    var idx = -1;
    while (++idx < len) {
      var pattern = patterns[idx];
      if (typeof pattern === "string" && pattern.charCodeAt(0) === 33) {
        omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
      } else {
        keep.push.apply(keep, micromatch.match(list, pattern, options));
      }
    }
    var matches = utils2.diff(keep, omit);
    if (!options || options.nodupes !== false) {
      return utils2.unique(matches);
    }
    return matches;
  }
  micromatch.match = function(list, pattern, options) {
    if (Array.isArray(pattern)) {
      throw new TypeError("expected pattern to be a string");
    }
    var unixify = utils2.unixify(options);
    var isMatch = memoize("match", pattern, options, micromatch.matcher);
    var matches = [];
    list = utils2.arrayify(list);
    var len = list.length;
    var idx = -1;
    while (++idx < len) {
      var ele = list[idx];
      if (ele === pattern || isMatch(ele)) {
        matches.push(utils2.value(ele, unixify, options));
      }
    }
    if (typeof options === "undefined") {
      return utils2.unique(matches);
    }
    if (matches.length === 0) {
      if (options.failglob === true) {
        throw new Error('no matches found for "' + pattern + '"');
      }
      if (options.nonull === true || options.nullglob === true) {
        return [options.unescape ? utils2.unescape(pattern) : pattern];
      }
    }
    if (options.ignore) {
      matches = micromatch.not(matches, options.ignore, options);
    }
    return options.nodupes !== false ? utils2.unique(matches) : matches;
  };
  micromatch.isMatch = function(str, pattern, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }
    var equals = utils2.equalsPattern(options);
    if (equals(str)) {
      return true;
    }
    var isMatch = memoize("isMatch", pattern, options, micromatch.matcher);
    return isMatch(str);
  };
  micromatch.some = function(list, patterns, options) {
    if (typeof list === "string") {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (micromatch(list[i], patterns, options).length === 1) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = function(list, patterns, options) {
    if (typeof list === "string") {
      list = [list];
    }
    for (var i = 0; i < list.length; i++) {
      if (micromatch(list[i], patterns, options).length !== 1) {
        return false;
      }
    }
    return true;
  };
  micromatch.any = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (isEmptyString(str) || isEmptyString(patterns)) {
      return false;
    }
    if (typeof patterns === "string") {
      patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
      if (micromatch.isMatch(str, patterns[i], options)) {
        return true;
      }
    }
    return false;
  };
  micromatch.all = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (typeof patterns === "string") {
      patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
      if (!micromatch.isMatch(str, patterns[i], options)) {
        return false;
      }
    }
    return true;
  };
  micromatch.not = function(list, patterns, options) {
    var opts = extend({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;
    var unixify = utils2.unixify(opts);
    list = utils2.arrayify(list).map(unixify);
    var matches = utils2.diff(list, micromatch(list, patterns, opts));
    if (ignore) {
      matches = utils2.diff(matches, micromatch(list, ignore));
    }
    return opts.nodupes !== false ? utils2.unique(matches) : matches;
  };
  micromatch.contains = function(str, patterns, options) {
    if (typeof str !== "string") {
      throw new TypeError('expected a string: "' + util.inspect(str) + '"');
    }
    if (typeof patterns === "string") {
      if (isEmptyString(str) || isEmptyString(patterns)) {
        return false;
      }
      var equals = utils2.equalsPattern(patterns, options);
      if (equals(str)) {
        return true;
      }
      var contains = utils2.containsPattern(patterns, options);
      if (contains(str)) {
        return true;
      }
    }
    var opts = extend({}, options, {contains: true});
    return micromatch.any(str, patterns, opts);
  };
  micromatch.matchBase = function(pattern, options) {
    if (pattern && pattern.indexOf("/") !== -1 || !options)
      return false;
    return options.basename === true || options.matchBase === true;
  };
  micromatch.matchKeys = function(obj, patterns, options) {
    if (!utils2.isObject(obj)) {
      throw new TypeError("expected the first argument to be an object");
    }
    var keys = micromatch(Object.keys(obj), patterns, options);
    return utils2.pick(obj, keys);
  };
  micromatch.matcher = function matcher(pattern, options) {
    if (Array.isArray(pattern)) {
      return compose(pattern, options, matcher);
    }
    if (pattern instanceof RegExp) {
      return test(pattern);
    }
    if (!utils2.isString(pattern)) {
      throw new TypeError("expected pattern to be an array, string or regex");
    }
    if (!utils2.hasSpecialChars(pattern)) {
      if (options && options.nocase === true) {
        pattern = pattern.toLowerCase();
      }
      return utils2.matchPath(pattern, options);
    }
    var re = micromatch.makeRe(pattern, options);
    if (micromatch.matchBase(pattern, options)) {
      return utils2.matchBasename(re, options);
    }
    function test(regex) {
      var equals = utils2.equalsPattern(options);
      var unixify = utils2.unixify(options);
      return function(str) {
        if (equals(str)) {
          return true;
        }
        if (regex.test(unixify(str))) {
          return true;
        }
        return false;
      };
    }
    var fn = test(re);
    Object.defineProperty(fn, "result", {
      configurable: true,
      enumerable: false,
      value: re.result
    });
    return fn;
  };
  micromatch.capture = function(pattern, str, options) {
    var re = micromatch.makeRe(pattern, extend({capture: true}, options));
    var unixify = utils2.unixify(options);
    function match() {
      return function(string) {
        var match2 = re.exec(unixify(string));
        if (!match2) {
          return null;
        }
        return match2.slice(1);
      };
    }
    var capture = memoize("capture", pattern, options, match);
    return capture(str);
  };
  micromatch.makeRe = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected pattern to be a string");
    }
    if (pattern.length > MAX_LENGTH) {
      throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
    }
    function makeRe() {
      var result = micromatch.create(pattern, options);
      var ast_array = [];
      var output = result.map(function(obj) {
        obj.ast.state = obj.state;
        ast_array.push(obj.ast);
        return obj.output;
      });
      var regex = toRegex(output.join("|"), options);
      Object.defineProperty(regex, "result", {
        configurable: true,
        enumerable: false,
        value: ast_array
      });
      return regex;
    }
    return memoize("makeRe", pattern, options, makeRe);
  };
  micromatch.braces = function(pattern, options) {
    if (typeof pattern !== "string" && !Array.isArray(pattern)) {
      throw new TypeError("expected pattern to be an array or string");
    }
    function expand() {
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return utils2.arrayify(pattern);
      }
      return braces(pattern, options);
    }
    return memoize("braces", pattern, options, expand);
  };
  micromatch.braceExpand = function(pattern, options) {
    var opts = extend({}, options, {expand: true});
    return micromatch.braces(pattern, opts);
  };
  micromatch.create = function(pattern, options) {
    return memoize("create", pattern, options, function() {
      function create(str, opts) {
        return micromatch.compile(micromatch.parse(str, opts), opts);
      }
      pattern = micromatch.braces(pattern, options);
      var len = pattern.length;
      var idx = -1;
      var res = [];
      while (++idx < len) {
        res.push(create(pattern[idx], options));
      }
      return res;
    });
  };
  micromatch.parse = function(pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("expected a string");
    }
    function parse() {
      var snapdragon = utils2.instantiate(null, options);
      parsers(snapdragon, options);
      var ast = snapdragon.parse(pattern, options);
      utils2.define(ast, "snapdragon", snapdragon);
      ast.input = pattern;
      return ast;
    }
    return memoize("parse", pattern, options, parse);
  };
  micromatch.compile = function(ast, options) {
    if (typeof ast === "string") {
      ast = micromatch.parse(ast, options);
    }
    return memoize("compile", ast.input, options, function() {
      var snapdragon = utils2.instantiate(ast, options);
      compilers(snapdragon, options);
      return snapdragon.compile(ast, options);
    });
  };
  micromatch.clearCache = function() {
    micromatch.cache.caches = {};
  };
  function isEmptyString(val) {
    return String(val) === "" || String(val) === "./";
  }
  function compose(patterns, options, matcher) {
    var matchers;
    return memoize("compose", String(patterns), options, function() {
      return function(file) {
        if (!matchers) {
          matchers = [];
          for (var i = 0; i < patterns.length; i++) {
            matchers.push(matcher(patterns[i], options));
          }
        }
        var len = matchers.length;
        while (len--) {
          if (matchers[len](file) === true) {
            return true;
          }
        }
        return false;
      };
    });
  }
  function memoize(type, pattern, options, fn) {
    var key = utils2.createKey(type + "=" + pattern, options);
    if (options && options.cache === false) {
      return fn(pattern, options);
    }
    if (cache.has(type, key)) {
      return cache.get(type, key);
    }
    var val = fn(pattern, options);
    cache.set(type, key, val);
    return val;
  }
  micromatch.compilers = compilers;
  micromatch.parsers = parsers;
  micromatch.caches = cache.caches;
  module2.exports = micromatch;
});

// node_modules/findup-sync/index.js
var require_findup_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var path = require("path");
  var isGlob = require_is_glob();
  var resolveDir = require_resolve_dir();
  var detect = require_detect_file();
  var mm = require_micromatch2();
  module2.exports = function(patterns, options) {
    options = options || {};
    var cwd = path.resolve(resolveDir(options.cwd || ""));
    if (typeof patterns === "string") {
      return lookup(cwd, [patterns], options);
    }
    if (!Array.isArray(patterns)) {
      throw new TypeError("findup-sync expects a string or array as the first argument.");
    }
    return lookup(cwd, patterns, options);
  };
  function lookup(cwd, patterns, options) {
    var len = patterns.length;
    var idx = -1;
    var res;
    while (++idx < len) {
      if (isGlob(patterns[idx])) {
        res = matchFile(cwd, patterns[idx], options);
      } else {
        res = findFile(cwd, patterns[idx], options);
      }
      if (res) {
        return res;
      }
    }
    var dir = path.dirname(cwd);
    if (dir === cwd) {
      return null;
    }
    return lookup(dir, patterns, options);
  }
  function matchFile(cwd, pattern, opts) {
    var isMatch = mm.matcher(pattern, opts);
    var files = tryReaddirSync(cwd);
    var len = files.length;
    var idx = -1;
    while (++idx < len) {
      var name = files[idx];
      var fp = path.join(cwd, name);
      if (isMatch(name) || isMatch(fp)) {
        return fp;
      }
    }
    return null;
  }
  function findFile(cwd, filename, options) {
    var fp = cwd ? path.resolve(cwd, filename) : filename;
    return detect(fp, options);
  }
  function tryReaddirSync(fp) {
    try {
      return fs.readdirSync(fp);
    } catch (err) {
    }
    return [];
  }
});

// node_modules/git-branch/index.js
var require_git_branch = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var util = require("util");
  var find = require_findup_sync();
  var readFile = util.promisify(fs.readFile);
  function branch(cwd, callback) {
    if (typeof cwd === "function") {
      callback = cwd;
      cwd = null;
    }
    const promise = readFile(gitHeadPath(cwd)).then((buf) => parseBranch(buf));
    if (typeof callback === "function") {
      promise.then((res) => callback(null, res)).catch(callback);
      return;
    }
    return promise;
  }
  branch.sync = function(cwd) {
    return parseBranch(fs.readFileSync(gitHeadPath(cwd)));
  };
  function parseBranch(buf) {
    const match = /ref: refs\/heads\/([^\n]+)/.exec(buf.toString());
    return match ? match[1] : null;
  }
  function gitHeadPath(cwd) {
    const filepath = find(".git/HEAD", {cwd: cwd || process.cwd()});
    if (!fs.existsSync(filepath)) {
      throw new Error(".git/HEAD does not exist");
    }
    return filepath;
  }
  module2.exports = branch;
});

// node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false)
      return false;
    ctor = o.constructor;
    if (ctor === void 0)
      return true;
    prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  exports2.isPlainObject = isPlainObject;
});

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports2.getUserAgent = getUserAgent;
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var isPlainObject = require_is_plain_object4();
  var universalUserAgent = require_dist_node();
  function lowercaseKeys(object) {
    if (!object) {
      return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
      newObj[key.toLowerCase()] = object[key];
      return newObj;
    }, {});
  }
  function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
      if (isPlainObject.isPlainObject(options[key])) {
        if (!(key in defaults))
          Object.assign(result, {
            [key]: options[key]
          });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      } else {
        Object.assign(result, {
          [key]: options[key]
        });
      }
    });
    return result;
  }
  function removeUndefinedProperties(obj) {
    for (const key in obj) {
      if (obj[key] === void 0) {
        delete obj[key];
      }
    }
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? {
        method,
        url
      } : {
        url: method
      }, options);
    } else {
      options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (defaults && defaults.mediaType.previews.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
      return url;
    }
    return url + separator + names.map((name) => {
      if (name === "q") {
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      }
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
      return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
      obj[key] = object[key];
      return obj;
    }, {});
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
      return encodeUnreserved(key) + "=" + value;
    } else {
      return value;
    }
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
        if (modifier && modifier !== "*") {
          value = value.substring(0, parseInt(modifier, 10));
        }
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else {
        if (modifier === "*") {
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                result.push(encodeValue(operator, value[k], k));
              }
            });
          }
        } else {
          const tmp = [];
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              tmp.push(encodeValue(operator, value2));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                tmp.push(encodeUnreserved(k));
                tmp.push(encodeValue(operator, value[k].toString()));
              }
            });
          }
          if (isKeyOperator(operator)) {
            result.push(encodeUnreserved(key) + "=" + tmp.join(","));
          } else if (tmp.length !== 0) {
            result.push(tmp.join(","));
          }
        }
      }
    } else {
      if (operator === ";") {
        if (isDefined(value)) {
          result.push(encodeUnreserved(key));
        }
      } else if (value === "" && (operator === "&" || operator === "?")) {
        result.push(encodeUnreserved(key) + "=");
      } else if (value === "") {
        result.push("");
      }
    }
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    });
  }
  function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
      url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
      if (options.mediaType.format) {
        headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      }
      if (options.mediaType.previews.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
    if (["GET", "HEAD"].includes(method)) {
      url = addQueryParameters(url, remainingParameters);
    } else {
      if ("data" in remainingParameters) {
        body = remainingParameters.data;
      } else {
        if (Object.keys(remainingParameters).length) {
          body = remainingParameters;
        } else {
          headers["content-length"] = 0;
        }
      }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
      headers["content-type"] = "application/json; charset=utf-8";
    }
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
      body = "";
    }
    return Object.assign({
      method,
      url,
      headers
    }, typeof body !== "undefined" ? {
      body
    } : null, options.request ? {
      request: options.request
    } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var VERSION = "6.0.10";
  var userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`;
  var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: "",
      previews: []
    }
  };
  var endpoint = withDefaults(null, DEFAULTS);
  exports2.endpoint = endpoint;
});

// node_modules/@octokit/request/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports2.getUserAgent = getUserAgent;
});

// node_modules/node-fetch/lib/index.mjs
var require_lib6 = __commonJS((exports2) => {
  __export(exports2, {
    FetchError: () => FetchError,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    default: () => lib_default
  });
  var import_stream = __toModule(require("stream"));
  var import_http = __toModule(require("http"));
  var import_url = __toModule(require("url"));
  var import_https = __toModule(require("https"));
  var import_zlib = __toModule(require("zlib"));
  var Readable = import_stream.default.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");
  var Blob = class {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0; i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable();
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  };
  Object.defineProperties(Blob.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require("encoding").convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = import_stream.default.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream.default) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  var MAP = Symbol("map");
  var Headers = class {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  };
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = import_http.default.STATUS_CODES;
  var Response = class {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  };
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    redirected: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var parse_url = import_url.default.parse;
  var format_url = import_url.default.format;
  var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  var Request = class {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  };
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true},
    signal: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var PassThrough$1 = import_stream.default.PassThrough;
  var resolve_url = import_url.default.resolve;
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof import_stream.default.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  var lib_default = fetch;
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Deprecation = class extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "Deprecation";
    }
  };
  exports2.Deprecation = Deprecation;
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var deprecation = require_dist_node4();
  var once = _interopDefault(require_once());
  var logOnce = once((deprecation2) => console.warn(deprecation2));
  var RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.status = statusCode;
      Object.defineProperty(this, "code", {
        get() {
          logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
          return statusCode;
        }
      });
      this.headers = options.headers || {};
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
    }
  };
  exports2.RequestError = RequestError;
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var endpoint = require_dist_node2();
  var universalUserAgent = require_dist_node3();
  var isPlainObject = require_is_plain_object4();
  var nodeFetch = _interopDefault(require_lib6());
  var requestError = require_dist_node5();
  var VERSION = "5.4.12";
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
      requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
    return fetch(requestOptions.url, Object.assign({
      method: requestOptions.method,
      body: requestOptions.body,
      headers: requestOptions.headers,
      redirect: requestOptions.redirect
    }, requestOptions.request)).then((response) => {
      url = response.url;
      status = response.status;
      for (const keyAndValue of response.headers) {
        headers[keyAndValue[0]] = keyAndValue[1];
      }
      if (status === 204 || status === 205) {
        return;
      }
      if (requestOptions.method === "HEAD") {
        if (status < 400) {
          return;
        }
        throw new requestError.RequestError(response.statusText, status, {
          headers,
          request: requestOptions
        });
      }
      if (status === 304) {
        throw new requestError.RequestError("Not modified", status, {
          headers,
          request: requestOptions
        });
      }
      if (status >= 400) {
        return response.text().then((message) => {
          const error = new requestError.RequestError(message, status, {
            headers,
            request: requestOptions
          });
          try {
            let responseBody = JSON.parse(error.message);
            Object.assign(error, responseBody);
            let errors = responseBody.errors;
            error.message = error.message + ": " + errors.map(JSON.stringify).join(", ");
          } catch (e) {
          }
          throw error;
        });
      }
      const contentType = response.headers.get("content-type");
      if (/application\/json/.test(contentType)) {
        return response.json();
      }
      if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
      }
      return getBufferResponse(response);
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof requestError.RequestError) {
        throw error;
      }
      throw new requestError.RequestError(error.message, 500, {
        headers,
        request: requestOptions
      });
    });
  }
  function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
      const endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook) {
        return fetchWrapper(endpoint2.parse(endpointOptions));
      }
      const request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
      return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
    }
  });
  exports2.request = request;
});

// node_modules/macos-release/index.js
var require_macos_release = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var nameMap = new Map([
    [20, ["Big Sur", "11"]],
    [19, ["Catalina", "10.15"]],
    [18, ["Mojave", "10.14"]],
    [17, ["High Sierra", "10.13"]],
    [16, ["Sierra", "10.12"]],
    [15, ["El Capitan", "10.11"]],
    [14, ["Yosemite", "10.10"]],
    [13, ["Mavericks", "10.9"]],
    [12, ["Mountain Lion", "10.8"]],
    [11, ["Lion", "10.7"]],
    [10, ["Snow Leopard", "10.6"]],
    [9, ["Leopard", "10.5"]],
    [8, ["Tiger", "10.4"]],
    [7, ["Panther", "10.3"]],
    [6, ["Jaguar", "10.2"]],
    [5, ["Puma", "10.1"]]
  ]);
  var macosRelease = (release) => {
    release = Number((release || os.release()).split(".")[0]);
    const [name, version] = nameMap.get(release);
    return {
      name,
      version
    };
  };
  module2.exports = macosRelease;
  module2.exports.default = macosRelease;
});

// node_modules/nice-try/src/index.js
var require_src5 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(fn) {
    try {
      return fn();
    } catch (e) {
    }
  };
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (opts) => {
    opts = opts || {};
    const env = opts.env || process.env;
    const platform = opts.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
  };
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var which = require_which();
  var pathKey = require_path_key()();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    if (hasCustomCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: (parsed.options.env || process.env)[pathKey],
        pathExt: withoutPathExt ? path.delimiter : void 0
      });
    } catch (e) {
    } finally {
      process.chdir(cwd);
    }
    if (resolved) {
      resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = /^#!.*/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex();
  module2.exports = function(str) {
    var match = str.match(shebangRegex);
    if (!match) {
      return null;
    }
    var arr = match[0].replace(/#! ?/, "").split(" ");
    var bin = arr[0].split("/").pop();
    var arg = arr[1];
    return bin === "env" ? arg : bin + (arg ? " " + arg : "");
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports2, module2) => {
  "use strict";
  var fs = require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    let buffer;
    if (Buffer.alloc) {
      buffer = Buffer.alloc(size);
    } else {
      buffer = new Buffer(size);
      buffer.fill(0);
    }
    let fd;
    try {
      fd = fs.openSync(command, "r");
      fs.readSync(fd, buffer, 0, size, 0);
      fs.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// node_modules/cross-spawn/node_modules/semver/semver.js
var require_semver3 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var niceTry = require_src5();
  var resolveCommand = require_resolveCommand();
  var escape = require_escape();
  var readShebang = require_readShebang();
  var semver = require_semver3();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parseShell(parsed) {
    if (supportsShellOption) {
      return parsed;
    }
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    if (isWin) {
      parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.options.windowsVerbatimArguments = true;
    } else {
      if (typeof parsed.options.shell === "string") {
        parsed.command = parsed.options.shell;
      } else if (process.platform === "android") {
        parsed.command = "/system/bin/sh";
      } else {
        parsed.command = "/bin/sh";
      }
      parsed.args = ["-c", shellCommand];
    }
    return parsed;
  }
  function parse(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parseShell(parsed) : parseNonShell(parsed);
  }
  module2.exports = parse;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var parse = require_parse4();
  var enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn;
  module2.exports.spawn = spawn;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse;
  module2.exports._enoent = enoent;
});

// node_modules/strip-eof/index.js
var require_strip_eof = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(x) {
    var lf = typeof x === "string" ? "\n" : "\n".charCodeAt();
    var cr = typeof x === "string" ? "\r" : "\r".charCodeAt();
    if (x[x.length - 1] === lf) {
      x = x.slice(0, x.length - 1);
    }
    if (x[x.length - 1] === cr) {
      x = x.slice(0, x.length - 1);
    }
    return x;
  };
});

// node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var pathKey = require_path_key();
  module2.exports = (opts) => {
    opts = Object.assign({
      cwd: process.cwd(),
      path: process.env[pathKey()]
    }, opts);
    let prev;
    let pth = path.resolve(opts.cwd);
    const ret = [];
    while (prev !== pth) {
      ret.push(path.join(pth, "node_modules/.bin"));
      prev = pth;
      pth = path.resolve(pth, "..");
    }
    ret.push(path.dirname(process.execPath));
    return ret.concat(opts.path).join(path.delimiter);
  };
  module2.exports.env = (opts) => {
    opts = Object.assign({
      env: process.env
    }, opts);
    const env = Object.assign({}, opts.env);
    const path2 = pathKey({env});
    opts.path = env[path2];
    env[path2] = module2.exports(opts);
    return env;
  };
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  "use strict";
  var isStream = module2.exports = function(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  };
  isStream.writable = function(stream) {
    return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  };
  isStream.readable = function(stream) {
    return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  };
  isStream.duplex = function(stream) {
    return isStream.writable(stream) && isStream.readable(stream);
  };
  isStream.transform = function(stream) {
    return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
  };
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS((exports2, module2) => {
  "use strict";
  var {PassThrough} = require("stream");
  module2.exports = (options) => {
    options = Object.assign({}, options);
    const {array} = options;
    let {encoding} = options;
    const buffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || buffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (buffer) {
      encoding = null;
    }
    let len = 0;
    const ret = [];
    const stream = new PassThrough({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    stream.on("data", (chunk) => {
      ret.push(chunk);
      if (objectMode) {
        len = ret.length;
      } else {
        len += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return ret;
      }
      return buffer ? Buffer.concat(ret, len) : ret.join("");
    };
    stream.getBufferedLength = () => len;
    return stream;
  };
});

// node_modules/get-stream/index.js
var require_get_stream2 = __commonJS((exports2, module2) => {
  "use strict";
  var pump = require_pump();
  var bufferStream = require_buffer_stream2();
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = Object.assign({maxBuffer: Infinity}, options);
    const {maxBuffer} = options;
    let stream;
    return new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    }).then(() => stream.getBufferedValue());
  }
  module2.exports = getStream;
  module2.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {encoding: "buffer"}));
  module2.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {array: true}));
  module2.exports.MaxBufferError = MaxBufferError;
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then((val) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => val), (err) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => {
      throw err;
    }));
  };
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load;
  var loaded = false;
  function load() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg) {
    if (ev === "exit") {
      if (arg !== void 0) {
        process.exitCode = arg;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// node_modules/execa/lib/errname.js
var require_errname = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var uv;
  if (typeof util.getSystemErrorName === "function") {
    module2.exports = util.getSystemErrorName;
  } else {
    try {
      uv = process.binding("uv");
      if (typeof uv.errname !== "function") {
        throw new TypeError("uv.errname is not a function");
      }
    } catch (err) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
      uv = null;
    }
    module2.exports = (code) => errname(uv, code);
  }
  module2.exports.__test__ = errname;
  function errname(uv2, code) {
    if (uv2) {
      return uv2.errname(code);
    }
    if (!(code < 0)) {
      throw new Error("err >= 0");
    }
    return `Unknown system error ${code}`;
  }
});

// node_modules/execa/lib/stdio.js
var require_stdio = __commonJS((exports2, module2) => {
  "use strict";
  var alias = ["stdin", "stdout", "stderr"];
  var hasAlias = (opts) => alias.some((x) => Boolean(opts[x]));
  module2.exports = (opts) => {
    if (!opts) {
      return null;
    }
    if (opts.stdio && hasAlias(opts)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
    }
    if (typeof opts.stdio === "string") {
      return opts.stdio;
    }
    const stdio = opts.stdio || [];
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const result = [];
    const len = Math.max(stdio.length, alias.length);
    for (let i = 0; i < len; i++) {
      let value = null;
      if (stdio[i] !== void 0) {
        value = stdio[i];
      } else if (opts[alias[i]] !== void 0) {
        value = opts[alias[i]];
      }
      result[i] = value;
    }
    return result;
  };
});

// node_modules/execa/index.js
var require_execa = __commonJS((exports2, module2) => {
  "use strict";
  var path = require("path");
  var childProcess = require("child_process");
  var crossSpawn = require_cross_spawn();
  var stripEof = require_strip_eof();
  var npmRunPath = require_npm_run_path();
  var isStream = require_is_stream();
  var _getStream = require_get_stream2();
  var pFinally = require_p_finally();
  var onExit = require_signal_exit();
  var errname = require_errname();
  var stdio = require_stdio();
  var TEN_MEGABYTES = 1e3 * 1e3 * 10;
  function handleArgs(cmd, args, opts) {
    let parsed;
    opts = Object.assign({
      extendEnv: true,
      env: {}
    }, opts);
    if (opts.extendEnv) {
      opts.env = Object.assign({}, process.env, opts.env);
    }
    if (opts.__winShell === true) {
      delete opts.__winShell;
      parsed = {
        command: cmd,
        args,
        options: opts,
        file: cmd,
        original: {
          cmd,
          args
        }
      };
    } else {
      parsed = crossSpawn._parse(cmd, args, opts);
    }
    opts = Object.assign({
      maxBuffer: TEN_MEGABYTES,
      buffer: true,
      stripEof: true,
      preferLocal: true,
      localDir: parsed.options.cwd || process.cwd(),
      encoding: "utf8",
      reject: true,
      cleanup: true
    }, parsed.options);
    opts.stdio = stdio(opts);
    if (opts.preferLocal) {
      opts.env = npmRunPath.env(Object.assign({}, opts, {cwd: opts.localDir}));
    }
    if (opts.detached) {
      opts.cleanup = false;
    }
    if (process.platform === "win32" && path.basename(parsed.command) === "cmd.exe") {
      parsed.args.unshift("/q");
    }
    return {
      cmd: parsed.command,
      args: parsed.args,
      opts,
      parsed
    };
  }
  function handleInput(spawned, input) {
    if (input === null || input === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  }
  function handleOutput(opts, val) {
    if (val && opts.stripEof) {
      val = stripEof(val);
    }
    return val;
  }
  function handleShell(fn, cmd, opts) {
    let file = "/bin/sh";
    let args = ["-c", cmd];
    opts = Object.assign({}, opts);
    if (process.platform === "win32") {
      opts.__winShell = true;
      file = process.env.comspec || "cmd.exe";
      args = ["/s", "/c", `"${cmd}"`];
      opts.windowsVerbatimArguments = true;
    }
    if (opts.shell) {
      file = opts.shell;
      delete opts.shell;
    }
    return fn(file, args, opts);
  }
  function getStream(process2, stream, {encoding, buffer, maxBuffer}) {
    if (!process2[stream]) {
      return null;
    }
    let ret;
    if (!buffer) {
      ret = new Promise((resolve, reject) => {
        process2[stream].once("end", resolve).once("error", reject);
      });
    } else if (encoding) {
      ret = _getStream(process2[stream], {
        encoding,
        maxBuffer
      });
    } else {
      ret = _getStream.buffer(process2[stream], {maxBuffer});
    }
    return ret.catch((err) => {
      err.stream = stream;
      err.message = `${stream} ${err.message}`;
      throw err;
    });
  }
  function makeError(result, options) {
    const {stdout, stderr} = result;
    let err = result.error;
    const {code, signal} = result;
    const {parsed, joinedCmd} = options;
    const timedOut = options.timedOut || false;
    if (!err) {
      let output = "";
      if (Array.isArray(parsed.opts.stdio)) {
        if (parsed.opts.stdio[2] !== "inherit") {
          output += output.length > 0 ? stderr : `
${stderr}`;
        }
        if (parsed.opts.stdio[1] !== "inherit") {
          output += `
${stdout}`;
        }
      } else if (parsed.opts.stdio !== "inherit") {
        output = `
${stderr}${stdout}`;
      }
      err = new Error(`Command failed: ${joinedCmd}${output}`);
      err.code = code < 0 ? errname(code) : code;
    }
    err.stdout = stdout;
    err.stderr = stderr;
    err.failed = true;
    err.signal = signal || null;
    err.cmd = joinedCmd;
    err.timedOut = timedOut;
    return err;
  }
  function joinCmd(cmd, args) {
    let joinedCmd = cmd;
    if (Array.isArray(args) && args.length > 0) {
      joinedCmd += " " + args.join(" ");
    }
    return joinedCmd;
  }
  module2.exports = (cmd, args, opts) => {
    const parsed = handleArgs(cmd, args, opts);
    const {encoding, buffer, maxBuffer} = parsed.opts;
    const joinedCmd = joinCmd(cmd, args);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
    } catch (err) {
      return Promise.reject(err);
    }
    let removeExitHandler;
    if (parsed.opts.cleanup) {
      removeExitHandler = onExit(() => {
        spawned.kill();
      });
    }
    let timeoutId = null;
    let timedOut = false;
    const cleanup = () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (removeExitHandler) {
        removeExitHandler();
      }
    };
    if (parsed.opts.timeout > 0) {
      timeoutId = setTimeout(() => {
        timeoutId = null;
        timedOut = true;
        spawned.kill(parsed.opts.killSignal);
      }, parsed.opts.timeout);
    }
    const processDone = new Promise((resolve) => {
      spawned.on("exit", (code, signal) => {
        cleanup();
        resolve({code, signal});
      });
      spawned.on("error", (err) => {
        cleanup();
        resolve({error: err});
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (err) => {
          cleanup();
          resolve({error: err});
        });
      }
    });
    function destroy() {
      if (spawned.stdout) {
        spawned.stdout.destroy();
      }
      if (spawned.stderr) {
        spawned.stderr.destroy();
      }
    }
    const handlePromise = () => pFinally(Promise.all([
      processDone,
      getStream(spawned, "stdout", {encoding, buffer, maxBuffer}),
      getStream(spawned, "stderr", {encoding, buffer, maxBuffer})
    ]).then((arr) => {
      const result = arr[0];
      result.stdout = arr[1];
      result.stderr = arr[2];
      if (result.error || result.code !== 0 || result.signal !== null) {
        const err = makeError(result, {
          joinedCmd,
          parsed,
          timedOut
        });
        err.killed = err.killed || spawned.killed;
        if (!parsed.opts.reject) {
          return err;
        }
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        killed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    }), destroy);
    crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
    handleInput(spawned, parsed.opts.input);
    spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
    spawned.catch = (onrejected) => handlePromise().catch(onrejected);
    return spawned;
  };
  module2.exports.stdout = (...args) => module2.exports(...args).then((x) => x.stdout);
  module2.exports.stderr = (...args) => module2.exports(...args).then((x) => x.stderr);
  module2.exports.shell = (cmd, opts) => handleShell(module2.exports, cmd, opts);
  module2.exports.sync = (cmd, args, opts) => {
    const parsed = handleArgs(cmd, args, opts);
    const joinedCmd = joinCmd(cmd, args);
    if (isStream(parsed.opts.input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
    const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
    result.code = result.status;
    if (result.error || result.status !== 0 || result.signal !== null) {
      const err = makeError(result, {
        joinedCmd,
        parsed
      });
      if (!parsed.opts.reject) {
        return err;
      }
      throw err;
    }
    return {
      stdout: handleOutput(parsed.opts, result.stdout),
      stderr: handleOutput(parsed.opts, result.stderr),
      code: 0,
      failed: false,
      signal: null,
      cmd: joinedCmd,
      timedOut: false
    };
  };
  module2.exports.shellSync = (cmd, opts) => handleShell(module2.exports.sync, cmd, opts);
});

// node_modules/windows-release/index.js
var require_windows_release = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var execa = require_execa();
  var names = new Map([
    ["10.0", "10"],
    ["6.3", "8.1"],
    ["6.2", "8"],
    ["6.1", "7"],
    ["6.0", "Vista"],
    ["5.2", "Server 2003"],
    ["5.1", "XP"],
    ["5.0", "2000"],
    ["4.9", "ME"],
    ["4.1", "98"],
    ["4.0", "95"]
  ]);
  var windowsRelease = (release) => {
    const version = /\d+\.\d/.exec(release || os.release());
    if (release && !version) {
      throw new Error("`release` argument doesn't match `n.n`");
    }
    const ver = (version || [])[0];
    if ((!release || release === os.release()) && ["6.1", "6.2", "6.3", "10.0"].includes(ver)) {
      let stdout;
      try {
        stdout = execa.sync("wmic", ["os", "get", "Caption"]).stdout || "";
      } catch (_) {
        stdout = execa.sync("powershell", ["(Get-CimInstance -ClassName Win32_OperatingSystem).caption"]).stdout || "";
      }
      const year = (stdout.match(/2008|2012|2016|2019/) || [])[0];
      if (year) {
        return `Server ${year}`;
      }
    }
    return names.get(ver);
  };
  module2.exports = windowsRelease;
});

// node_modules/os-name/index.js
var require_os_name = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var macosRelease = require_macos_release();
  var winRelease = require_windows_release();
  var osName = (platform, release) => {
    if (!platform && release) {
      throw new Error("You can't specify a `release` without specifying `platform`");
    }
    platform = platform || os.platform();
    let id;
    if (platform === "darwin") {
      if (!release && os.platform() === "darwin") {
        release = os.release();
      }
      const prefix = release ? Number(release.split(".")[0]) > 15 ? "macOS" : "OS X" : "macOS";
      id = release ? macosRelease(release).name : "";
      return prefix + (id ? " " + id : "");
    }
    if (platform === "linux") {
      if (!release && os.platform() === "linux") {
        release = os.release();
      }
      id = release ? release.replace(/^(\d+\.\d+).*/, "$1") : "";
      return "Linux" + (id ? " " + id : "");
    }
    if (platform === "win32") {
      if (!release && os.platform() === "win32") {
        release = os.release();
      }
      id = release ? winRelease(release) : "";
      return "Windows" + (id ? " " + id : "");
    }
    return platform;
  };
  module2.exports = osName;
});

// node_modules/universal-user-agent/index.js
var require_universal_user_agent = __commonJS((exports2, module2) => {
  module2.exports = getUserAgentNode;
  var osName = require_os_name();
  function getUserAgentNode() {
    try {
      return `Node.js/${process.version.substr(1)} (${osName()}; ${process.arch})`;
    } catch (error) {
      if (/wmic os get Caption/.test(error.message)) {
        return "Windows <version undetectable>";
      }
      throw error;
    }
  }
});

// node_modules/@octokit/graphql/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    _from: "@octokit/graphql@^2.0.1",
    _id: "@octokit/graphql@2.1.3",
    _inBundle: false,
    _integrity: "sha512-XoXJqL2ondwdnMIW3wtqJWEwcBfKk37jO/rYkoxNPEVeLBDGsGO1TCWggrAlq3keGt/O+C/7VepXnukUxwt5vA==",
    _location: "/@octokit/graphql",
    _phantomChildren: {},
    _requested: {
      type: "range",
      registry: true,
      raw: "@octokit/graphql@^2.0.1",
      name: "@octokit/graphql",
      escapedName: "@octokit%2fgraphql",
      scope: "@octokit",
      rawSpec: "^2.0.1",
      saveSpec: null,
      fetchSpec: "^2.0.1"
    },
    _requiredBy: [
      "/@actions/github"
    ],
    _resolved: "https://registry.npmjs.org/@octokit/graphql/-/graphql-2.1.3.tgz",
    _shasum: "60c058a0ed5fa242eca6f938908d95fd1a2f4b92",
    _spec: "@octokit/graphql@^2.0.1",
    _where: "/Users/orshefi/workspace/ci/github-tag-action/node_modules/@actions/github",
    author: {
      name: "Gregor Martynus",
      url: "https://github.com/gr2m"
    },
    bugs: {
      url: "https://github.com/octokit/graphql.js/issues"
    },
    bundleDependencies: false,
    bundlesize: [
      {
        path: "./dist/octokit-graphql.min.js.gz",
        maxSize: "5KB"
      }
    ],
    dependencies: {
      "@octokit/request": "^5.0.0",
      "universal-user-agent": "^2.0.3"
    },
    deprecated: false,
    description: "GitHub GraphQL API client for browsers and Node",
    devDependencies: {
      chai: "^4.2.0",
      "compression-webpack-plugin": "^2.0.0",
      coveralls: "^3.0.3",
      cypress: "^3.1.5",
      "fetch-mock": "^7.3.1",
      mkdirp: "^0.5.1",
      mocha: "^6.0.0",
      "npm-run-all": "^4.1.3",
      nyc: "^14.0.0",
      "semantic-release": "^15.13.3",
      "simple-mock": "^0.8.0",
      standard: "^12.0.1",
      webpack: "^4.29.6",
      "webpack-bundle-analyzer": "^3.1.0",
      "webpack-cli": "^3.2.3"
    },
    files: [
      "lib"
    ],
    homepage: "https://github.com/octokit/graphql.js#readme",
    keywords: [
      "octokit",
      "github",
      "api",
      "graphql"
    ],
    license: "MIT",
    main: "index.js",
    name: "@octokit/graphql",
    publishConfig: {
      access: "public"
    },
    release: {
      publish: [
        "@semantic-release/npm",
        {
          path: "@semantic-release/github",
          assets: [
            "dist/*",
            "!dist/*.map.gz"
          ]
        }
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/octokit/graphql.js.git"
    },
    scripts: {
      build: "npm-run-all build:*",
      "build:development": "webpack --mode development --entry . --output-library=octokitGraphql --output=./dist/octokit-graphql.js --profile --json > dist/bundle-stats.json",
      "build:production": "webpack --mode production --entry . --plugin=compression-webpack-plugin --output-library=octokitGraphql --output-path=./dist --output-filename=octokit-graphql.min.js --devtool source-map",
      "bundle-report": "webpack-bundle-analyzer dist/bundle-stats.json --mode=static --no-open --report dist/bundle-report.html",
      coverage: "nyc report --reporter=html && open coverage/index.html",
      "coverage:upload": "nyc report --reporter=text-lcov | coveralls",
      prebuild: "mkdirp dist/",
      pretest: "standard",
      test: "nyc mocha test/*-test.js",
      "test:browser": "cypress run --browser chrome"
    },
    standard: {
      globals: [
        "describe",
        "before",
        "beforeEach",
        "afterEach",
        "after",
        "it",
        "expect"
      ]
    },
    version: "2.1.3"
  };
});

// node_modules/@octokit/graphql/lib/error.js
var require_error = __commonJS((exports2, module2) => {
  module2.exports = class GraphqlError extends Error {
    constructor(request, response) {
      const message = response.data.errors[0].message;
      super(message);
      Object.assign(this, response.data);
      this.name = "GraphqlError";
      this.request = request;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };
});

// node_modules/@octokit/graphql/lib/graphql.js
var require_graphql = __commonJS((exports2, module2) => {
  module2.exports = graphql;
  var GraphqlError = require_error();
  var NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query"];
  function graphql(request, query, options) {
    if (typeof query === "string") {
      options = Object.assign({query}, options);
    } else {
      options = query;
    }
    const requestOptions = Object.keys(options).reduce((result, key) => {
      if (NON_VARIABLE_OPTIONS.includes(key)) {
        result[key] = options[key];
        return result;
      }
      if (!result.variables) {
        result.variables = {};
      }
      result.variables[key] = options[key];
      return result;
    }, {});
    return request(requestOptions).then((response) => {
      if (response.data.errors) {
        throw new GraphqlError(requestOptions, response);
      }
      return response.data.data;
    });
  }
});

// node_modules/@octokit/graphql/lib/with-defaults.js
var require_with_defaults = __commonJS((exports2, module2) => {
  module2.exports = withDefaults;
  var graphql = require_graphql();
  function withDefaults(request, newDefaults) {
    const newRequest = request.defaults(newDefaults);
    const newApi = function(query, options) {
      return graphql(newRequest, query, options);
    };
    newApi.defaults = withDefaults.bind(null, newRequest);
    return newApi;
  }
});

// node_modules/@octokit/graphql/index.js
var require_graphql2 = __commonJS((exports2, module2) => {
  var {request} = require_dist_node6();
  var getUserAgent = require_universal_user_agent();
  var version = require_package().version;
  var userAgent = `octokit-graphql.js/${version} ${getUserAgent()}`;
  var withDefaults = require_with_defaults();
  module2.exports = withDefaults(request, {
    method: "POST",
    url: "/graphql",
    headers: {
      "user-agent": userAgent
    }
  });
});

// node_modules/@octokit/plugin-request-log/dist-node/index.js
var require_dist_node7 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var VERSION = "1.0.2";
  function requestLog(octokit) {
    octokit.hook.wrap("request", (request, options) => {
      octokit.log.debug("request", options);
      const start = Date.now();
      const requestOptions = octokit.request.endpoint.parse(options);
      const path = requestOptions.url.replace(options.baseUrl, "");
      return request(options).then((response) => {
        octokit.log.info(`${requestOptions.method} ${path} - ${response.status} in ${Date.now() - start}ms`);
        return response;
      }).catch((error) => {
        octokit.log.info(`${requestOptions.method} ${path} - ${error.status} in ${Date.now() - start}ms`);
        throw error;
      });
    });
  }
  requestLog.VERSION = VERSION;
  exports2.requestLog = requestLog;
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var deprecation = require_dist_node4();
  var endpointsByScope = {
    actions: {
      cancelWorkflowRun: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id/cancel"
      },
      createOrUpdateSecretForRepo: {
        method: "PUT",
        params: {
          encrypted_value: {
            type: "string"
          },
          key_id: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/secrets/:name"
      },
      createRegistrationToken: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/runners/registration-token"
      },
      createRemoveToken: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/runners/remove-token"
      },
      deleteArtifact: {
        method: "DELETE",
        params: {
          artifact_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/artifacts/:artifact_id"
      },
      deleteSecretFromRepo: {
        method: "DELETE",
        params: {
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/secrets/:name"
      },
      downloadArtifact: {
        method: "GET",
        params: {
          archive_format: {
            required: true,
            type: "string"
          },
          artifact_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format"
      },
      getArtifact: {
        method: "GET",
        params: {
          artifact_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/artifacts/:artifact_id"
      },
      getPublicKey: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/secrets/public-key"
      },
      getSecret: {
        method: "GET",
        params: {
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/secrets/:name"
      },
      getSelfHostedRunner: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          runner_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runners/:runner_id"
      },
      getWorkflow: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          workflow_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/workflows/:workflow_id"
      },
      getWorkflowJob: {
        method: "GET",
        params: {
          job_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/jobs/:job_id"
      },
      getWorkflowRun: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id"
      },
      listDownloadsForSelfHostedRunnerApplication: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/runners/downloads"
      },
      listJobsForWorkflowRun: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id/jobs"
      },
      listRepoWorkflowRuns: {
        method: "GET",
        params: {
          actor: {
            type: "string"
          },
          branch: {
            type: "string"
          },
          event: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          status: {
            enum: ["completed", "status", "conclusion"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/runs"
      },
      listRepoWorkflows: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/workflows"
      },
      listSecretsForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/secrets"
      },
      listSelfHostedRunnersForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/runners"
      },
      listWorkflowJobLogs: {
        method: "GET",
        params: {
          job_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/actions/jobs/:job_id/logs"
      },
      listWorkflowRunArtifacts: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id/artifacts"
      },
      listWorkflowRunLogs: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id/logs"
      },
      listWorkflowRuns: {
        method: "GET",
        params: {
          actor: {
            type: "string"
          },
          branch: {
            type: "string"
          },
          event: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          status: {
            enum: ["completed", "status", "conclusion"],
            type: "string"
          },
          workflow_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/workflows/:workflow_id/runs"
      },
      reRunWorkflow: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          run_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runs/:run_id/rerun"
      },
      removeSelfHostedRunner: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          runner_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/actions/runners/:runner_id"
      }
    },
    activity: {
      checkStarringRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/user/starred/:owner/:repo"
      },
      deleteRepoSubscription: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/subscription"
      },
      deleteThreadSubscription: {
        method: "DELETE",
        params: {
          thread_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/notifications/threads/:thread_id/subscription"
      },
      getRepoSubscription: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/subscription"
      },
      getThread: {
        method: "GET",
        params: {
          thread_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/notifications/threads/:thread_id"
      },
      getThreadSubscription: {
        method: "GET",
        params: {
          thread_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/notifications/threads/:thread_id/subscription"
      },
      listEventsForOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/events/orgs/:org"
      },
      listEventsForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/events"
      },
      listFeeds: {
        method: "GET",
        params: {},
        url: "/feeds"
      },
      listNotifications: {
        method: "GET",
        params: {
          all: {
            type: "boolean"
          },
          before: {
            type: "string"
          },
          page: {
            type: "integer"
          },
          participating: {
            type: "boolean"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          }
        },
        url: "/notifications"
      },
      listNotificationsForRepo: {
        method: "GET",
        params: {
          all: {
            type: "boolean"
          },
          before: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          participating: {
            type: "boolean"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/notifications"
      },
      listPublicEvents: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/events"
      },
      listPublicEventsForOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/events"
      },
      listPublicEventsForRepoNetwork: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/networks/:owner/:repo/events"
      },
      listPublicEventsForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/events/public"
      },
      listReceivedEventsForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/received_events"
      },
      listReceivedPublicEventsForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/received_events/public"
      },
      listRepoEvents: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/events"
      },
      listReposStarredByAuthenticatedUser: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/user/starred"
      },
      listReposStarredByUser: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/starred"
      },
      listReposWatchedByUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/subscriptions"
      },
      listStargazersForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stargazers"
      },
      listWatchedReposForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/subscriptions"
      },
      listWatchersForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/subscribers"
      },
      markAsRead: {
        method: "PUT",
        params: {
          last_read_at: {
            type: "string"
          }
        },
        url: "/notifications"
      },
      markNotificationsAsReadForRepo: {
        method: "PUT",
        params: {
          last_read_at: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/notifications"
      },
      markThreadAsRead: {
        method: "PATCH",
        params: {
          thread_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/notifications/threads/:thread_id"
      },
      setRepoSubscription: {
        method: "PUT",
        params: {
          ignored: {
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          subscribed: {
            type: "boolean"
          }
        },
        url: "/repos/:owner/:repo/subscription"
      },
      setThreadSubscription: {
        method: "PUT",
        params: {
          ignored: {
            type: "boolean"
          },
          thread_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/notifications/threads/:thread_id/subscription"
      },
      starRepo: {
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/user/starred/:owner/:repo"
      },
      unstarRepo: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/user/starred/:owner/:repo"
      }
    },
    apps: {
      addRepoToInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "PUT",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          },
          repository_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/installations/:installation_id/repositories/:repository_id"
      },
      checkAccountIsAssociatedWithAny: {
        method: "GET",
        params: {
          account_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/marketplace_listing/accounts/:account_id"
      },
      checkAccountIsAssociatedWithAnyStubbed: {
        method: "GET",
        params: {
          account_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/marketplace_listing/stubbed/accounts/:account_id"
      },
      checkAuthorization: {
        deprecated: "octokit.apps.checkAuthorization() is deprecated, see https://developer.github.com/v3/apps/oauth_applications/#check-an-authorization",
        method: "GET",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      checkToken: {
        headers: {
          accept: "application/vnd.github.doctor-strange-preview+json"
        },
        method: "POST",
        params: {
          access_token: {
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/token"
      },
      createContentAttachment: {
        headers: {
          accept: "application/vnd.github.corsair-preview+json"
        },
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          content_reference_id: {
            required: true,
            type: "integer"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/content_references/:content_reference_id/attachments"
      },
      createFromManifest: {
        headers: {
          accept: "application/vnd.github.fury-preview+json"
        },
        method: "POST",
        params: {
          code: {
            required: true,
            type: "string"
          }
        },
        url: "/app-manifests/:code/conversions"
      },
      createInstallationToken: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "POST",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          },
          permissions: {
            type: "object"
          },
          repository_ids: {
            type: "integer[]"
          }
        },
        url: "/app/installations/:installation_id/access_tokens"
      },
      deleteAuthorization: {
        headers: {
          accept: "application/vnd.github.doctor-strange-preview+json"
        },
        method: "DELETE",
        params: {
          access_token: {
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/grant"
      },
      deleteInstallation: {
        headers: {
          accept: "application/vnd.github.gambit-preview+json,application/vnd.github.machine-man-preview+json"
        },
        method: "DELETE",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/app/installations/:installation_id"
      },
      deleteToken: {
        headers: {
          accept: "application/vnd.github.doctor-strange-preview+json"
        },
        method: "DELETE",
        params: {
          access_token: {
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/token"
      },
      findOrgInstallation: {
        deprecated: "octokit.apps.findOrgInstallation() has been renamed to octokit.apps.getOrgInstallation() (2019-04-10)",
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/installation"
      },
      findRepoInstallation: {
        deprecated: "octokit.apps.findRepoInstallation() has been renamed to octokit.apps.getRepoInstallation() (2019-04-10)",
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/installation"
      },
      findUserInstallation: {
        deprecated: "octokit.apps.findUserInstallation() has been renamed to octokit.apps.getUserInstallation() (2019-04-10)",
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/installation"
      },
      getAuthenticated: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {},
        url: "/app"
      },
      getBySlug: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          app_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/apps/:app_slug"
      },
      getInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/app/installations/:installation_id"
      },
      getOrgInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/installation"
      },
      getRepoInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/installation"
      },
      getUserInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/installation"
      },
      listAccountsUserOrOrgOnPlan: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          plan_id: {
            required: true,
            type: "integer"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/marketplace_listing/plans/:plan_id/accounts"
      },
      listAccountsUserOrOrgOnPlanStubbed: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          plan_id: {
            required: true,
            type: "integer"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/marketplace_listing/stubbed/plans/:plan_id/accounts"
      },
      listInstallationReposForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/installations/:installation_id/repositories"
      },
      listInstallations: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/app/installations"
      },
      listInstallationsForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/installations"
      },
      listMarketplacePurchasesForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/marketplace_purchases"
      },
      listMarketplacePurchasesForAuthenticatedUserStubbed: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/marketplace_purchases/stubbed"
      },
      listPlans: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/marketplace_listing/plans"
      },
      listPlansStubbed: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/marketplace_listing/stubbed/plans"
      },
      listRepos: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/installation/repositories"
      },
      removeRepoFromInstallation: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "DELETE",
        params: {
          installation_id: {
            required: true,
            type: "integer"
          },
          repository_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/installations/:installation_id/repositories/:repository_id"
      },
      resetAuthorization: {
        deprecated: "octokit.apps.resetAuthorization() is deprecated, see https://developer.github.com/v3/apps/oauth_applications/#reset-an-authorization",
        method: "POST",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      resetToken: {
        headers: {
          accept: "application/vnd.github.doctor-strange-preview+json"
        },
        method: "PATCH",
        params: {
          access_token: {
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/token"
      },
      revokeAuthorizationForApplication: {
        deprecated: "octokit.apps.revokeAuthorizationForApplication() is deprecated, see https://developer.github.com/v3/apps/oauth_applications/#revoke-an-authorization-for-an-application",
        method: "DELETE",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      revokeGrantForApplication: {
        deprecated: "octokit.apps.revokeGrantForApplication() is deprecated, see https://developer.github.com/v3/apps/oauth_applications/#revoke-a-grant-for-an-application",
        method: "DELETE",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/grants/:access_token"
      },
      revokeInstallationToken: {
        headers: {
          accept: "application/vnd.github.gambit-preview+json"
        },
        method: "DELETE",
        params: {},
        url: "/installation/token"
      }
    },
    checks: {
      create: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "POST",
        params: {
          actions: {
            type: "object[]"
          },
          "actions[].description": {
            required: true,
            type: "string"
          },
          "actions[].identifier": {
            required: true,
            type: "string"
          },
          "actions[].label": {
            required: true,
            type: "string"
          },
          completed_at: {
            type: "string"
          },
          conclusion: {
            enum: ["success", "failure", "neutral", "cancelled", "timed_out", "action_required"],
            type: "string"
          },
          details_url: {
            type: "string"
          },
          external_id: {
            type: "string"
          },
          head_sha: {
            required: true,
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          output: {
            type: "object"
          },
          "output.annotations": {
            type: "object[]"
          },
          "output.annotations[].annotation_level": {
            enum: ["notice", "warning", "failure"],
            required: true,
            type: "string"
          },
          "output.annotations[].end_column": {
            type: "integer"
          },
          "output.annotations[].end_line": {
            required: true,
            type: "integer"
          },
          "output.annotations[].message": {
            required: true,
            type: "string"
          },
          "output.annotations[].path": {
            required: true,
            type: "string"
          },
          "output.annotations[].raw_details": {
            type: "string"
          },
          "output.annotations[].start_column": {
            type: "integer"
          },
          "output.annotations[].start_line": {
            required: true,
            type: "integer"
          },
          "output.annotations[].title": {
            type: "string"
          },
          "output.images": {
            type: "object[]"
          },
          "output.images[].alt": {
            required: true,
            type: "string"
          },
          "output.images[].caption": {
            type: "string"
          },
          "output.images[].image_url": {
            required: true,
            type: "string"
          },
          "output.summary": {
            required: true,
            type: "string"
          },
          "output.text": {
            type: "string"
          },
          "output.title": {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          started_at: {
            type: "string"
          },
          status: {
            enum: ["queued", "in_progress", "completed"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-runs"
      },
      createSuite: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "POST",
        params: {
          head_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-suites"
      },
      get: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          check_run_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-runs/:check_run_id"
      },
      getSuite: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          check_suite_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-suites/:check_suite_id"
      },
      listAnnotations: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          check_run_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-runs/:check_run_id/annotations"
      },
      listForRef: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          check_name: {
            type: "string"
          },
          filter: {
            enum: ["latest", "all"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          status: {
            enum: ["queued", "in_progress", "completed"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref/check-runs"
      },
      listForSuite: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          check_name: {
            type: "string"
          },
          check_suite_id: {
            required: true,
            type: "integer"
          },
          filter: {
            enum: ["latest", "all"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          status: {
            enum: ["queued", "in_progress", "completed"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-suites/:check_suite_id/check-runs"
      },
      listSuitesForRef: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "GET",
        params: {
          app_id: {
            type: "integer"
          },
          check_name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref/check-suites"
      },
      rerequestSuite: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "POST",
        params: {
          check_suite_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-suites/:check_suite_id/rerequest"
      },
      setSuitesPreferences: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "PATCH",
        params: {
          auto_trigger_checks: {
            type: "object[]"
          },
          "auto_trigger_checks[].app_id": {
            required: true,
            type: "integer"
          },
          "auto_trigger_checks[].setting": {
            required: true,
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-suites/preferences"
      },
      update: {
        headers: {
          accept: "application/vnd.github.antiope-preview+json"
        },
        method: "PATCH",
        params: {
          actions: {
            type: "object[]"
          },
          "actions[].description": {
            required: true,
            type: "string"
          },
          "actions[].identifier": {
            required: true,
            type: "string"
          },
          "actions[].label": {
            required: true,
            type: "string"
          },
          check_run_id: {
            required: true,
            type: "integer"
          },
          completed_at: {
            type: "string"
          },
          conclusion: {
            enum: ["success", "failure", "neutral", "cancelled", "timed_out", "action_required"],
            type: "string"
          },
          details_url: {
            type: "string"
          },
          external_id: {
            type: "string"
          },
          name: {
            type: "string"
          },
          output: {
            type: "object"
          },
          "output.annotations": {
            type: "object[]"
          },
          "output.annotations[].annotation_level": {
            enum: ["notice", "warning", "failure"],
            required: true,
            type: "string"
          },
          "output.annotations[].end_column": {
            type: "integer"
          },
          "output.annotations[].end_line": {
            required: true,
            type: "integer"
          },
          "output.annotations[].message": {
            required: true,
            type: "string"
          },
          "output.annotations[].path": {
            required: true,
            type: "string"
          },
          "output.annotations[].raw_details": {
            type: "string"
          },
          "output.annotations[].start_column": {
            type: "integer"
          },
          "output.annotations[].start_line": {
            required: true,
            type: "integer"
          },
          "output.annotations[].title": {
            type: "string"
          },
          "output.images": {
            type: "object[]"
          },
          "output.images[].alt": {
            required: true,
            type: "string"
          },
          "output.images[].caption": {
            type: "string"
          },
          "output.images[].image_url": {
            required: true,
            type: "string"
          },
          "output.summary": {
            required: true,
            type: "string"
          },
          "output.text": {
            type: "string"
          },
          "output.title": {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          started_at: {
            type: "string"
          },
          status: {
            enum: ["queued", "in_progress", "completed"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/check-runs/:check_run_id"
      }
    },
    codesOfConduct: {
      getConductCode: {
        headers: {
          accept: "application/vnd.github.scarlet-witch-preview+json"
        },
        method: "GET",
        params: {
          key: {
            required: true,
            type: "string"
          }
        },
        url: "/codes_of_conduct/:key"
      },
      getForRepo: {
        headers: {
          accept: "application/vnd.github.scarlet-witch-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/community/code_of_conduct"
      },
      listConductCodes: {
        headers: {
          accept: "application/vnd.github.scarlet-witch-preview+json"
        },
        method: "GET",
        params: {},
        url: "/codes_of_conduct"
      }
    },
    emojis: {
      get: {
        method: "GET",
        params: {},
        url: "/emojis"
      }
    },
    gists: {
      checkIsStarred: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/star"
      },
      create: {
        method: "POST",
        params: {
          description: {
            type: "string"
          },
          files: {
            required: true,
            type: "object"
          },
          "files.content": {
            type: "string"
          },
          public: {
            type: "boolean"
          }
        },
        url: "/gists"
      },
      createComment: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/comments"
      },
      delete: {
        method: "DELETE",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id"
      },
      deleteComment: {
        method: "DELETE",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/comments/:comment_id"
      },
      fork: {
        method: "POST",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/forks"
      },
      get: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id"
      },
      getComment: {
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/comments/:comment_id"
      },
      getRevision: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          },
          sha: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/:sha"
      },
      list: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          }
        },
        url: "/gists"
      },
      listComments: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/gists/:gist_id/comments"
      },
      listCommits: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/gists/:gist_id/commits"
      },
      listForks: {
        method: "GET",
        params: {
          gist_id: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/gists/:gist_id/forks"
      },
      listPublic: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          }
        },
        url: "/gists/public"
      },
      listPublicForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/gists"
      },
      listStarred: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          }
        },
        url: "/gists/starred"
      },
      star: {
        method: "PUT",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/star"
      },
      unstar: {
        method: "DELETE",
        params: {
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/star"
      },
      update: {
        method: "PATCH",
        params: {
          description: {
            type: "string"
          },
          files: {
            type: "object"
          },
          "files.content": {
            type: "string"
          },
          "files.filename": {
            type: "string"
          },
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id"
      },
      updateComment: {
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_id: {
            required: true,
            type: "integer"
          },
          gist_id: {
            required: true,
            type: "string"
          }
        },
        url: "/gists/:gist_id/comments/:comment_id"
      }
    },
    git: {
      createBlob: {
        method: "POST",
        params: {
          content: {
            required: true,
            type: "string"
          },
          encoding: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/blobs"
      },
      createCommit: {
        method: "POST",
        params: {
          author: {
            type: "object"
          },
          "author.date": {
            type: "string"
          },
          "author.email": {
            type: "string"
          },
          "author.name": {
            type: "string"
          },
          committer: {
            type: "object"
          },
          "committer.date": {
            type: "string"
          },
          "committer.email": {
            type: "string"
          },
          "committer.name": {
            type: "string"
          },
          message: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          parents: {
            required: true,
            type: "string[]"
          },
          repo: {
            required: true,
            type: "string"
          },
          signature: {
            type: "string"
          },
          tree: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/commits"
      },
      createRef: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/refs"
      },
      createTag: {
        method: "POST",
        params: {
          message: {
            required: true,
            type: "string"
          },
          object: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          tag: {
            required: true,
            type: "string"
          },
          tagger: {
            type: "object"
          },
          "tagger.date": {
            type: "string"
          },
          "tagger.email": {
            type: "string"
          },
          "tagger.name": {
            type: "string"
          },
          type: {
            enum: ["commit", "tree", "blob"],
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/tags"
      },
      createTree: {
        method: "POST",
        params: {
          base_tree: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          tree: {
            required: true,
            type: "object[]"
          },
          "tree[].content": {
            type: "string"
          },
          "tree[].mode": {
            enum: ["100644", "100755", "040000", "160000", "120000"],
            type: "string"
          },
          "tree[].path": {
            type: "string"
          },
          "tree[].sha": {
            allowNull: true,
            type: "string"
          },
          "tree[].type": {
            enum: ["blob", "tree", "commit"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/trees"
      },
      deleteRef: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/refs/:ref"
      },
      getBlob: {
        method: "GET",
        params: {
          file_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/blobs/:file_sha"
      },
      getCommit: {
        method: "GET",
        params: {
          commit_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/commits/:commit_sha"
      },
      getRef: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/ref/:ref"
      },
      getTag: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          tag_sha: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/tags/:tag_sha"
      },
      getTree: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          recursive: {
            enum: ["1"],
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          tree_sha: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/trees/:tree_sha"
      },
      listMatchingRefs: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/matching-refs/:ref"
      },
      listRefs: {
        method: "GET",
        params: {
          namespace: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/refs/:namespace"
      },
      updateRef: {
        method: "PATCH",
        params: {
          force: {
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/git/refs/:ref"
      }
    },
    gitignore: {
      getTemplate: {
        method: "GET",
        params: {
          name: {
            required: true,
            type: "string"
          }
        },
        url: "/gitignore/templates/:name"
      },
      listTemplates: {
        method: "GET",
        params: {},
        url: "/gitignore/templates"
      }
    },
    interactions: {
      addOrUpdateRestrictionsForOrg: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "PUT",
        params: {
          limit: {
            enum: ["existing_users", "contributors_only", "collaborators_only"],
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/interaction-limits"
      },
      addOrUpdateRestrictionsForRepo: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "PUT",
        params: {
          limit: {
            enum: ["existing_users", "contributors_only", "collaborators_only"],
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/interaction-limits"
      },
      getRestrictionsForOrg: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/interaction-limits"
      },
      getRestrictionsForRepo: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/interaction-limits"
      },
      removeRestrictionsForOrg: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/interaction-limits"
      },
      removeRestrictionsForRepo: {
        headers: {
          accept: "application/vnd.github.sombra-preview+json"
        },
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/interaction-limits"
      }
    },
    issues: {
      addAssignees: {
        method: "POST",
        params: {
          assignees: {
            type: "string[]"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/assignees"
      },
      addLabels: {
        method: "POST",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          labels: {
            required: true,
            type: "string[]"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/labels"
      },
      checkAssignee: {
        method: "GET",
        params: {
          assignee: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/assignees/:assignee"
      },
      create: {
        method: "POST",
        params: {
          assignee: {
            type: "string"
          },
          assignees: {
            type: "string[]"
          },
          body: {
            type: "string"
          },
          labels: {
            type: "string[]"
          },
          milestone: {
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues"
      },
      createComment: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/comments"
      },
      createLabel: {
        method: "POST",
        params: {
          color: {
            required: true,
            type: "string"
          },
          description: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/labels"
      },
      createMilestone: {
        method: "POST",
        params: {
          description: {
            type: "string"
          },
          due_on: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["open", "closed"],
            type: "string"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones"
      },
      deleteComment: {
        method: "DELETE",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments/:comment_id"
      },
      deleteLabel: {
        method: "DELETE",
        params: {
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/labels/:name"
      },
      deleteMilestone: {
        method: "DELETE",
        params: {
          milestone_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "milestone_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones/:milestone_number"
      },
      get: {
        method: "GET",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number"
      },
      getComment: {
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments/:comment_id"
      },
      getEvent: {
        method: "GET",
        params: {
          event_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/events/:event_id"
      },
      getLabel: {
        method: "GET",
        params: {
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/labels/:name"
      },
      getMilestone: {
        method: "GET",
        params: {
          milestone_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "milestone_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones/:milestone_number"
      },
      list: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          filter: {
            enum: ["assigned", "created", "mentioned", "subscribed", "all"],
            type: "string"
          },
          labels: {
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated", "comments"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/issues"
      },
      listAssignees: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/assignees"
      },
      listComments: {
        method: "GET",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/comments"
      },
      listCommentsForRepo: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments"
      },
      listEvents: {
        method: "GET",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/events"
      },
      listEventsForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/events"
      },
      listEventsForTimeline: {
        headers: {
          accept: "application/vnd.github.mockingbird-preview+json"
        },
        method: "GET",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/timeline"
      },
      listForAuthenticatedUser: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          filter: {
            enum: ["assigned", "created", "mentioned", "subscribed", "all"],
            type: "string"
          },
          labels: {
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated", "comments"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/user/issues"
      },
      listForOrg: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          filter: {
            enum: ["assigned", "created", "mentioned", "subscribed", "all"],
            type: "string"
          },
          labels: {
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated", "comments"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/orgs/:org/issues"
      },
      listForRepo: {
        method: "GET",
        params: {
          assignee: {
            type: "string"
          },
          creator: {
            type: "string"
          },
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          labels: {
            type: "string"
          },
          mentioned: {
            type: "string"
          },
          milestone: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated", "comments"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues"
      },
      listLabelsForMilestone: {
        method: "GET",
        params: {
          milestone_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "milestone_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones/:milestone_number/labels"
      },
      listLabelsForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/labels"
      },
      listLabelsOnIssue: {
        method: "GET",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/labels"
      },
      listMilestonesForRepo: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["due_on", "completeness"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones"
      },
      lock: {
        method: "PUT",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          lock_reason: {
            enum: ["off-topic", "too heated", "resolved", "spam"],
            type: "string"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/lock"
      },
      removeAssignees: {
        method: "DELETE",
        params: {
          assignees: {
            type: "string[]"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/assignees"
      },
      removeLabel: {
        method: "DELETE",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          name: {
            required: true,
            type: "string"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/labels/:name"
      },
      removeLabels: {
        method: "DELETE",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/labels"
      },
      replaceLabels: {
        method: "PUT",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          labels: {
            type: "string[]"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/labels"
      },
      unlock: {
        method: "DELETE",
        params: {
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/lock"
      },
      update: {
        method: "PATCH",
        params: {
          assignee: {
            type: "string"
          },
          assignees: {
            type: "string[]"
          },
          body: {
            type: "string"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          labels: {
            type: "string[]"
          },
          milestone: {
            allowNull: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["open", "closed"],
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number"
      },
      updateComment: {
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments/:comment_id"
      },
      updateLabel: {
        method: "PATCH",
        params: {
          color: {
            type: "string"
          },
          current_name: {
            required: true,
            type: "string"
          },
          description: {
            type: "string"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/labels/:current_name"
      },
      updateMilestone: {
        method: "PATCH",
        params: {
          description: {
            type: "string"
          },
          due_on: {
            type: "string"
          },
          milestone_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "milestone_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["open", "closed"],
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/milestones/:milestone_number"
      }
    },
    licenses: {
      get: {
        method: "GET",
        params: {
          license: {
            required: true,
            type: "string"
          }
        },
        url: "/licenses/:license"
      },
      getForRepo: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/license"
      },
      list: {
        deprecated: "octokit.licenses.list() has been renamed to octokit.licenses.listCommonlyUsed() (2019-03-05)",
        method: "GET",
        params: {},
        url: "/licenses"
      },
      listCommonlyUsed: {
        method: "GET",
        params: {},
        url: "/licenses"
      }
    },
    markdown: {
      render: {
        method: "POST",
        params: {
          context: {
            type: "string"
          },
          mode: {
            enum: ["markdown", "gfm"],
            type: "string"
          },
          text: {
            required: true,
            type: "string"
          }
        },
        url: "/markdown"
      },
      renderRaw: {
        headers: {
          "content-type": "text/plain; charset=utf-8"
        },
        method: "POST",
        params: {
          data: {
            mapTo: "data",
            required: true,
            type: "string"
          }
        },
        url: "/markdown/raw"
      }
    },
    meta: {
      get: {
        method: "GET",
        params: {},
        url: "/meta"
      }
    },
    migrations: {
      cancelImport: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import"
      },
      deleteArchiveForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "DELETE",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/migrations/:migration_id/archive"
      },
      deleteArchiveForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "DELETE",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/migrations/:migration_id/archive"
      },
      downloadArchiveForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/migrations/:migration_id/archive"
      },
      getArchiveForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/migrations/:migration_id/archive"
      },
      getArchiveForOrg: {
        deprecated: "octokit.migrations.getArchiveForOrg() has been renamed to octokit.migrations.downloadArchiveForOrg() (2020-01-27)",
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/migrations/:migration_id/archive"
      },
      getCommitAuthors: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import/authors"
      },
      getImportProgress: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import"
      },
      getLargeFiles: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import/large_files"
      },
      getStatusForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/migrations/:migration_id"
      },
      getStatusForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/migrations/:migration_id"
      },
      listForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/migrations"
      },
      listForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/migrations"
      },
      listReposForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/migrations/:migration_id/repositories"
      },
      listReposForUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "GET",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/:migration_id/repositories"
      },
      mapCommitAuthor: {
        method: "PATCH",
        params: {
          author_id: {
            required: true,
            type: "integer"
          },
          email: {
            type: "string"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import/authors/:author_id"
      },
      setLfsPreference: {
        method: "PATCH",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          use_lfs: {
            enum: ["opt_in", "opt_out"],
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import/lfs"
      },
      startForAuthenticatedUser: {
        method: "POST",
        params: {
          exclude_attachments: {
            type: "boolean"
          },
          lock_repositories: {
            type: "boolean"
          },
          repositories: {
            required: true,
            type: "string[]"
          }
        },
        url: "/user/migrations"
      },
      startForOrg: {
        method: "POST",
        params: {
          exclude_attachments: {
            type: "boolean"
          },
          lock_repositories: {
            type: "boolean"
          },
          org: {
            required: true,
            type: "string"
          },
          repositories: {
            required: true,
            type: "string[]"
          }
        },
        url: "/orgs/:org/migrations"
      },
      startImport: {
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          tfvc_project: {
            type: "string"
          },
          vcs: {
            enum: ["subversion", "git", "mercurial", "tfvc"],
            type: "string"
          },
          vcs_password: {
            type: "string"
          },
          vcs_url: {
            required: true,
            type: "string"
          },
          vcs_username: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import"
      },
      unlockRepoForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "DELETE",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          repo_name: {
            required: true,
            type: "string"
          }
        },
        url: "/user/migrations/:migration_id/repos/:repo_name/lock"
      },
      unlockRepoForOrg: {
        headers: {
          accept: "application/vnd.github.wyandotte-preview+json"
        },
        method: "DELETE",
        params: {
          migration_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          repo_name: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/migrations/:migration_id/repos/:repo_name/lock"
      },
      updateImport: {
        method: "PATCH",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          vcs_password: {
            type: "string"
          },
          vcs_username: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/import"
      }
    },
    oauthAuthorizations: {
      checkAuthorization: {
        deprecated: "octokit.oauthAuthorizations.checkAuthorization() has been renamed to octokit.apps.checkAuthorization() (2019-11-05)",
        method: "GET",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      createAuthorization: {
        deprecated: "octokit.oauthAuthorizations.createAuthorization() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization",
        method: "POST",
        params: {
          client_id: {
            type: "string"
          },
          client_secret: {
            type: "string"
          },
          fingerprint: {
            type: "string"
          },
          note: {
            required: true,
            type: "string"
          },
          note_url: {
            type: "string"
          },
          scopes: {
            type: "string[]"
          }
        },
        url: "/authorizations"
      },
      deleteAuthorization: {
        deprecated: "octokit.oauthAuthorizations.deleteAuthorization() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#delete-an-authorization",
        method: "DELETE",
        params: {
          authorization_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/authorizations/:authorization_id"
      },
      deleteGrant: {
        deprecated: "octokit.oauthAuthorizations.deleteGrant() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#delete-a-grant",
        method: "DELETE",
        params: {
          grant_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/applications/grants/:grant_id"
      },
      getAuthorization: {
        deprecated: "octokit.oauthAuthorizations.getAuthorization() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#get-a-single-authorization",
        method: "GET",
        params: {
          authorization_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/authorizations/:authorization_id"
      },
      getGrant: {
        deprecated: "octokit.oauthAuthorizations.getGrant() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#get-a-single-grant",
        method: "GET",
        params: {
          grant_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/applications/grants/:grant_id"
      },
      getOrCreateAuthorizationForApp: {
        deprecated: "octokit.oauthAuthorizations.getOrCreateAuthorizationForApp() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app",
        method: "PUT",
        params: {
          client_id: {
            required: true,
            type: "string"
          },
          client_secret: {
            required: true,
            type: "string"
          },
          fingerprint: {
            type: "string"
          },
          note: {
            type: "string"
          },
          note_url: {
            type: "string"
          },
          scopes: {
            type: "string[]"
          }
        },
        url: "/authorizations/clients/:client_id"
      },
      getOrCreateAuthorizationForAppAndFingerprint: {
        deprecated: "octokit.oauthAuthorizations.getOrCreateAuthorizationForAppAndFingerprint() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#get-or-create-an-authorization-for-a-specific-app-and-fingerprint",
        method: "PUT",
        params: {
          client_id: {
            required: true,
            type: "string"
          },
          client_secret: {
            required: true,
            type: "string"
          },
          fingerprint: {
            required: true,
            type: "string"
          },
          note: {
            type: "string"
          },
          note_url: {
            type: "string"
          },
          scopes: {
            type: "string[]"
          }
        },
        url: "/authorizations/clients/:client_id/:fingerprint"
      },
      getOrCreateAuthorizationForAppFingerprint: {
        deprecated: "octokit.oauthAuthorizations.getOrCreateAuthorizationForAppFingerprint() has been renamed to octokit.oauthAuthorizations.getOrCreateAuthorizationForAppAndFingerprint() (2018-12-27)",
        method: "PUT",
        params: {
          client_id: {
            required: true,
            type: "string"
          },
          client_secret: {
            required: true,
            type: "string"
          },
          fingerprint: {
            required: true,
            type: "string"
          },
          note: {
            type: "string"
          },
          note_url: {
            type: "string"
          },
          scopes: {
            type: "string[]"
          }
        },
        url: "/authorizations/clients/:client_id/:fingerprint"
      },
      listAuthorizations: {
        deprecated: "octokit.oauthAuthorizations.listAuthorizations() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#list-your-authorizations",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/authorizations"
      },
      listGrants: {
        deprecated: "octokit.oauthAuthorizations.listGrants() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#list-your-grants",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/applications/grants"
      },
      resetAuthorization: {
        deprecated: "octokit.oauthAuthorizations.resetAuthorization() has been renamed to octokit.apps.resetAuthorization() (2019-11-05)",
        method: "POST",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      revokeAuthorizationForApplication: {
        deprecated: "octokit.oauthAuthorizations.revokeAuthorizationForApplication() has been renamed to octokit.apps.revokeAuthorizationForApplication() (2019-11-05)",
        method: "DELETE",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/tokens/:access_token"
      },
      revokeGrantForApplication: {
        deprecated: "octokit.oauthAuthorizations.revokeGrantForApplication() has been renamed to octokit.apps.revokeGrantForApplication() (2019-11-05)",
        method: "DELETE",
        params: {
          access_token: {
            required: true,
            type: "string"
          },
          client_id: {
            required: true,
            type: "string"
          }
        },
        url: "/applications/:client_id/grants/:access_token"
      },
      updateAuthorization: {
        deprecated: "octokit.oauthAuthorizations.updateAuthorization() is deprecated, see https://developer.github.com/v3/oauth_authorizations/#update-an-existing-authorization",
        method: "PATCH",
        params: {
          add_scopes: {
            type: "string[]"
          },
          authorization_id: {
            required: true,
            type: "integer"
          },
          fingerprint: {
            type: "string"
          },
          note: {
            type: "string"
          },
          note_url: {
            type: "string"
          },
          remove_scopes: {
            type: "string[]"
          },
          scopes: {
            type: "string[]"
          }
        },
        url: "/authorizations/:authorization_id"
      }
    },
    orgs: {
      addOrUpdateMembership: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          role: {
            enum: ["admin", "member"],
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/memberships/:username"
      },
      blockUser: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/blocks/:username"
      },
      checkBlockedUser: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/blocks/:username"
      },
      checkMembership: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/members/:username"
      },
      checkPublicMembership: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/public_members/:username"
      },
      concealMembership: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/public_members/:username"
      },
      convertMemberToOutsideCollaborator: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/outside_collaborators/:username"
      },
      createHook: {
        method: "POST",
        params: {
          active: {
            type: "boolean"
          },
          config: {
            required: true,
            type: "object"
          },
          "config.content_type": {
            type: "string"
          },
          "config.insecure_ssl": {
            type: "string"
          },
          "config.secret": {
            type: "string"
          },
          "config.url": {
            required: true,
            type: "string"
          },
          events: {
            type: "string[]"
          },
          name: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/hooks"
      },
      createInvitation: {
        method: "POST",
        params: {
          email: {
            type: "string"
          },
          invitee_id: {
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          role: {
            enum: ["admin", "direct_member", "billing_manager"],
            type: "string"
          },
          team_ids: {
            type: "integer[]"
          }
        },
        url: "/orgs/:org/invitations"
      },
      deleteHook: {
        method: "DELETE",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/hooks/:hook_id"
      },
      get: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org"
      },
      getHook: {
        method: "GET",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/hooks/:hook_id"
      },
      getMembership: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/memberships/:username"
      },
      getMembershipForAuthenticatedUser: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/user/memberships/orgs/:org"
      },
      list: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "integer"
          }
        },
        url: "/organizations"
      },
      listBlockedUsers: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/blocks"
      },
      listForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/orgs"
      },
      listForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/orgs"
      },
      listHooks: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/hooks"
      },
      listInstallations: {
        headers: {
          accept: "application/vnd.github.machine-man-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/installations"
      },
      listInvitationTeams: {
        method: "GET",
        params: {
          invitation_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/invitations/:invitation_id/teams"
      },
      listMembers: {
        method: "GET",
        params: {
          filter: {
            enum: ["2fa_disabled", "all"],
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          role: {
            enum: ["all", "admin", "member"],
            type: "string"
          }
        },
        url: "/orgs/:org/members"
      },
      listMemberships: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          state: {
            enum: ["active", "pending"],
            type: "string"
          }
        },
        url: "/user/memberships/orgs"
      },
      listOutsideCollaborators: {
        method: "GET",
        params: {
          filter: {
            enum: ["2fa_disabled", "all"],
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/outside_collaborators"
      },
      listPendingInvitations: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/invitations"
      },
      listPublicMembers: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/public_members"
      },
      pingHook: {
        method: "POST",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/hooks/:hook_id/pings"
      },
      publicizeMembership: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/public_members/:username"
      },
      removeMember: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/members/:username"
      },
      removeMembership: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/memberships/:username"
      },
      removeOutsideCollaborator: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/outside_collaborators/:username"
      },
      unblockUser: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/blocks/:username"
      },
      update: {
        method: "PATCH",
        params: {
          billing_email: {
            type: "string"
          },
          company: {
            type: "string"
          },
          default_repository_permission: {
            enum: ["read", "write", "admin", "none"],
            type: "string"
          },
          description: {
            type: "string"
          },
          email: {
            type: "string"
          },
          has_organization_projects: {
            type: "boolean"
          },
          has_repository_projects: {
            type: "boolean"
          },
          location: {
            type: "string"
          },
          members_allowed_repository_creation_type: {
            enum: ["all", "private", "none"],
            type: "string"
          },
          members_can_create_internal_repositories: {
            type: "boolean"
          },
          members_can_create_private_repositories: {
            type: "boolean"
          },
          members_can_create_public_repositories: {
            type: "boolean"
          },
          members_can_create_repositories: {
            type: "boolean"
          },
          name: {
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org"
      },
      updateHook: {
        method: "PATCH",
        params: {
          active: {
            type: "boolean"
          },
          config: {
            type: "object"
          },
          "config.content_type": {
            type: "string"
          },
          "config.insecure_ssl": {
            type: "string"
          },
          "config.secret": {
            type: "string"
          },
          "config.url": {
            required: true,
            type: "string"
          },
          events: {
            type: "string[]"
          },
          hook_id: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/hooks/:hook_id"
      },
      updateMembership: {
        method: "PATCH",
        params: {
          org: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["active"],
            required: true,
            type: "string"
          }
        },
        url: "/user/memberships/orgs/:org"
      }
    },
    projects: {
      addCollaborator: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PUT",
        params: {
          permission: {
            enum: ["read", "write", "admin"],
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/projects/:project_id/collaborators/:username"
      },
      createCard: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          column_id: {
            required: true,
            type: "integer"
          },
          content_id: {
            type: "integer"
          },
          content_type: {
            type: "string"
          },
          note: {
            type: "string"
          }
        },
        url: "/projects/columns/:column_id/cards"
      },
      createColumn: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          name: {
            required: true,
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/:project_id/columns"
      },
      createForAuthenticatedUser: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          }
        },
        url: "/user/projects"
      },
      createForOrg: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/projects"
      },
      createForRepo: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/projects"
      },
      delete: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "DELETE",
        params: {
          project_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/:project_id"
      },
      deleteCard: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "DELETE",
        params: {
          card_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/columns/cards/:card_id"
      },
      deleteColumn: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "DELETE",
        params: {
          column_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/columns/:column_id"
      },
      get: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          project_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/:project_id"
      },
      getCard: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          card_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/columns/cards/:card_id"
      },
      getColumn: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          column_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/columns/:column_id"
      },
      listCards: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          archived_state: {
            enum: ["all", "archived", "not_archived"],
            type: "string"
          },
          column_id: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/projects/columns/:column_id/cards"
      },
      listCollaborators: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          affiliation: {
            enum: ["outside", "direct", "all"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          project_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/:project_id/collaborators"
      },
      listColumns: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          project_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/projects/:project_id/columns"
      },
      listForOrg: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/orgs/:org/projects"
      },
      listForRepo: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/projects"
      },
      listForUser: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/projects"
      },
      moveCard: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          card_id: {
            required: true,
            type: "integer"
          },
          column_id: {
            type: "integer"
          },
          position: {
            required: true,
            type: "string",
            validation: "^(top|bottom|after:\\d+)$"
          }
        },
        url: "/projects/columns/cards/:card_id/moves"
      },
      moveColumn: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "POST",
        params: {
          column_id: {
            required: true,
            type: "integer"
          },
          position: {
            required: true,
            type: "string",
            validation: "^(first|last|after:\\d+)$"
          }
        },
        url: "/projects/columns/:column_id/moves"
      },
      removeCollaborator: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "DELETE",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/projects/:project_id/collaborators/:username"
      },
      reviewUserPermissionLevel: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/projects/:project_id/collaborators/:username/permission"
      },
      update: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PATCH",
        params: {
          body: {
            type: "string"
          },
          name: {
            type: "string"
          },
          organization_permission: {
            type: "string"
          },
          private: {
            type: "boolean"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          state: {
            enum: ["open", "closed"],
            type: "string"
          }
        },
        url: "/projects/:project_id"
      },
      updateCard: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PATCH",
        params: {
          archived: {
            type: "boolean"
          },
          card_id: {
            required: true,
            type: "integer"
          },
          note: {
            type: "string"
          }
        },
        url: "/projects/columns/cards/:card_id"
      },
      updateColumn: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PATCH",
        params: {
          column_id: {
            required: true,
            type: "integer"
          },
          name: {
            required: true,
            type: "string"
          }
        },
        url: "/projects/columns/:column_id"
      }
    },
    pulls: {
      checkIfMerged: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/merge"
      },
      create: {
        method: "POST",
        params: {
          base: {
            required: true,
            type: "string"
          },
          body: {
            type: "string"
          },
          draft: {
            type: "boolean"
          },
          head: {
            required: true,
            type: "string"
          },
          maintainer_can_modify: {
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls"
      },
      createComment: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          commit_id: {
            required: true,
            type: "string"
          },
          in_reply_to: {
            deprecated: true,
            description: "The comment ID to reply to. **Note**: This must be the ID of a top-level comment, not a reply to that comment. Replies to replies are not supported.",
            type: "integer"
          },
          line: {
            type: "integer"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          position: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          side: {
            enum: ["LEFT", "RIGHT"],
            type: "string"
          },
          start_line: {
            type: "integer"
          },
          start_side: {
            enum: ["LEFT", "RIGHT", "side"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/comments"
      },
      createCommentReply: {
        deprecated: "octokit.pulls.createCommentReply() has been renamed to octokit.pulls.createComment() (2019-09-09)",
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          commit_id: {
            required: true,
            type: "string"
          },
          in_reply_to: {
            deprecated: true,
            description: "The comment ID to reply to. **Note**: This must be the ID of a top-level comment, not a reply to that comment. Replies to replies are not supported.",
            type: "integer"
          },
          line: {
            type: "integer"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          position: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          side: {
            enum: ["LEFT", "RIGHT"],
            type: "string"
          },
          start_line: {
            type: "integer"
          },
          start_side: {
            enum: ["LEFT", "RIGHT", "side"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/comments"
      },
      createFromIssue: {
        deprecated: "octokit.pulls.createFromIssue() is deprecated, see https://developer.github.com/v3/pulls/#create-a-pull-request",
        method: "POST",
        params: {
          base: {
            required: true,
            type: "string"
          },
          draft: {
            type: "boolean"
          },
          head: {
            required: true,
            type: "string"
          },
          issue: {
            required: true,
            type: "integer"
          },
          maintainer_can_modify: {
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls"
      },
      createReview: {
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          comments: {
            type: "object[]"
          },
          "comments[].body": {
            required: true,
            type: "string"
          },
          "comments[].path": {
            required: true,
            type: "string"
          },
          "comments[].position": {
            required: true,
            type: "integer"
          },
          commit_id: {
            type: "string"
          },
          event: {
            enum: ["APPROVE", "REQUEST_CHANGES", "COMMENT"],
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews"
      },
      createReviewCommentReply: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies"
      },
      createReviewRequest: {
        method: "POST",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          reviewers: {
            type: "string[]"
          },
          team_reviewers: {
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers"
      },
      deleteComment: {
        method: "DELETE",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments/:comment_id"
      },
      deletePendingReview: {
        method: "DELETE",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id"
      },
      deleteReviewRequest: {
        method: "DELETE",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          reviewers: {
            type: "string[]"
          },
          team_reviewers: {
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers"
      },
      dismissReview: {
        method: "PUT",
        params: {
          message: {
            required: true,
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals"
      },
      get: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number"
      },
      getComment: {
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments/:comment_id"
      },
      getCommentsForReview: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments"
      },
      getReview: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id"
      },
      list: {
        method: "GET",
        params: {
          base: {
            type: "string"
          },
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          head: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["created", "updated", "popularity", "long-running"],
            type: "string"
          },
          state: {
            enum: ["open", "closed", "all"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls"
      },
      listComments: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/comments"
      },
      listCommentsForRepo: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          since: {
            type: "string"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments"
      },
      listCommits: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/commits"
      },
      listFiles: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/files"
      },
      listReviewRequests: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers"
      },
      listReviews: {
        method: "GET",
        params: {
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews"
      },
      merge: {
        method: "PUT",
        params: {
          commit_message: {
            type: "string"
          },
          commit_title: {
            type: "string"
          },
          merge_method: {
            enum: ["merge", "squash", "rebase"],
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/merge"
      },
      submitReview: {
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          event: {
            enum: ["APPROVE", "REQUEST_CHANGES", "COMMENT"],
            required: true,
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events"
      },
      update: {
        method: "PATCH",
        params: {
          base: {
            type: "string"
          },
          body: {
            type: "string"
          },
          maintainer_can_modify: {
            type: "boolean"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["open", "closed"],
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number"
      },
      updateBranch: {
        headers: {
          accept: "application/vnd.github.lydian-preview+json"
        },
        method: "PUT",
        params: {
          expected_head_sha: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/update-branch"
      },
      updateComment: {
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments/:comment_id"
      },
      updateReview: {
        method: "PUT",
        params: {
          body: {
            required: true,
            type: "string"
          },
          number: {
            alias: "pull_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          pull_number: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          review_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id"
      }
    },
    rateLimit: {
      get: {
        method: "GET",
        params: {},
        url: "/rate_limit"
      }
    },
    reactions: {
      createForCommitComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments/:comment_id/reactions"
      },
      createForIssue: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/reactions"
      },
      createForIssueComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments/:comment_id/reactions"
      },
      createForPullRequestReviewComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments/:comment_id/reactions"
      },
      createForTeamDiscussion: {
        deprecated: "octokit.reactions.createForTeamDiscussion() has been renamed to octokit.reactions.createForTeamDiscussionLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/reactions"
      },
      createForTeamDiscussionComment: {
        deprecated: "octokit.reactions.createForTeamDiscussionComment() has been renamed to octokit.reactions.createForTeamDiscussionCommentLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      createForTeamDiscussionCommentInOrg: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      createForTeamDiscussionCommentLegacy: {
        deprecated: "octokit.reactions.createForTeamDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-comment-legacy",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      createForTeamDiscussionInOrg: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions"
      },
      createForTeamDiscussionLegacy: {
        deprecated: "octokit.reactions.createForTeamDiscussionLegacy() is deprecated, see https://developer.github.com/v3/reactions/#create-reaction-for-a-team-discussion-legacy",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "POST",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/reactions"
      },
      delete: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "DELETE",
        params: {
          reaction_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/reactions/:reaction_id"
      },
      listForCommitComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments/:comment_id/reactions"
      },
      listForIssue: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          issue_number: {
            required: true,
            type: "integer"
          },
          number: {
            alias: "issue_number",
            deprecated: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/:issue_number/reactions"
      },
      listForIssueComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/issues/comments/:comment_id/reactions"
      },
      listForPullRequestReviewComment: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pulls/comments/:comment_id/reactions"
      },
      listForTeamDiscussion: {
        deprecated: "octokit.reactions.listForTeamDiscussion() has been renamed to octokit.reactions.listForTeamDiscussionLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/reactions"
      },
      listForTeamDiscussionComment: {
        deprecated: "octokit.reactions.listForTeamDiscussionComment() has been renamed to octokit.reactions.listForTeamDiscussionCommentLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      listForTeamDiscussionCommentInOrg: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      listForTeamDiscussionCommentLegacy: {
        deprecated: "octokit.reactions.listForTeamDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-comment-legacy",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions"
      },
      listForTeamDiscussionInOrg: {
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions"
      },
      listForTeamDiscussionLegacy: {
        deprecated: "octokit.reactions.listForTeamDiscussionLegacy() is deprecated, see https://developer.github.com/v3/reactions/#list-reactions-for-a-team-discussion-legacy",
        headers: {
          accept: "application/vnd.github.squirrel-girl-preview+json"
        },
        method: "GET",
        params: {
          content: {
            enum: ["+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/reactions"
      }
    },
    repos: {
      acceptInvitation: {
        method: "PATCH",
        params: {
          invitation_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/repository_invitations/:invitation_id"
      },
      addCollaborator: {
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/collaborators/:username"
      },
      addDeployKey: {
        method: "POST",
        params: {
          key: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          read_only: {
            type: "boolean"
          },
          repo: {
            required: true,
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/keys"
      },
      addProtectedBranchAdminEnforcement: {
        method: "POST",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
      },
      addProtectedBranchAppRestrictions: {
        method: "POST",
        params: {
          apps: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps"
      },
      addProtectedBranchRequiredSignatures: {
        headers: {
          accept: "application/vnd.github.zzzax-preview+json"
        },
        method: "POST",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
      },
      addProtectedBranchRequiredStatusChecksContexts: {
        method: "POST",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          contexts: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
      },
      addProtectedBranchTeamRestrictions: {
        method: "POST",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          teams: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      addProtectedBranchUserRestrictions: {
        method: "POST",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          users: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      checkCollaborator: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/collaborators/:username"
      },
      checkVulnerabilityAlerts: {
        headers: {
          accept: "application/vnd.github.dorian-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/vulnerability-alerts"
      },
      compareCommits: {
        method: "GET",
        params: {
          base: {
            required: true,
            type: "string"
          },
          head: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/compare/:base...:head"
      },
      createCommitComment: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          commit_sha: {
            required: true,
            type: "string"
          },
          line: {
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            type: "string"
          },
          position: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            alias: "commit_sha",
            deprecated: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:commit_sha/comments"
      },
      createDeployment: {
        method: "POST",
        params: {
          auto_merge: {
            type: "boolean"
          },
          description: {
            type: "string"
          },
          environment: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          payload: {
            type: "string"
          },
          production_environment: {
            type: "boolean"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          required_contexts: {
            type: "string[]"
          },
          task: {
            type: "string"
          },
          transient_environment: {
            type: "boolean"
          }
        },
        url: "/repos/:owner/:repo/deployments"
      },
      createDeploymentStatus: {
        method: "POST",
        params: {
          auto_inactive: {
            type: "boolean"
          },
          deployment_id: {
            required: true,
            type: "integer"
          },
          description: {
            type: "string"
          },
          environment: {
            enum: ["production", "staging", "qa"],
            type: "string"
          },
          environment_url: {
            type: "string"
          },
          log_url: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["error", "failure", "inactive", "in_progress", "queued", "pending", "success"],
            required: true,
            type: "string"
          },
          target_url: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/deployments/:deployment_id/statuses"
      },
      createDispatchEvent: {
        method: "POST",
        params: {
          client_payload: {
            type: "object"
          },
          event_type: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/dispatches"
      },
      createFile: {
        deprecated: "octokit.repos.createFile() has been renamed to octokit.repos.createOrUpdateFile() (2019-06-07)",
        method: "PUT",
        params: {
          author: {
            type: "object"
          },
          "author.email": {
            required: true,
            type: "string"
          },
          "author.name": {
            required: true,
            type: "string"
          },
          branch: {
            type: "string"
          },
          committer: {
            type: "object"
          },
          "committer.email": {
            required: true,
            type: "string"
          },
          "committer.name": {
            required: true,
            type: "string"
          },
          content: {
            required: true,
            type: "string"
          },
          message: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contents/:path"
      },
      createForAuthenticatedUser: {
        method: "POST",
        params: {
          allow_merge_commit: {
            type: "boolean"
          },
          allow_rebase_merge: {
            type: "boolean"
          },
          allow_squash_merge: {
            type: "boolean"
          },
          auto_init: {
            type: "boolean"
          },
          delete_branch_on_merge: {
            type: "boolean"
          },
          description: {
            type: "string"
          },
          gitignore_template: {
            type: "string"
          },
          has_issues: {
            type: "boolean"
          },
          has_projects: {
            type: "boolean"
          },
          has_wiki: {
            type: "boolean"
          },
          homepage: {
            type: "string"
          },
          is_template: {
            type: "boolean"
          },
          license_template: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          team_id: {
            type: "integer"
          },
          visibility: {
            enum: ["public", "private", "visibility", "internal"],
            type: "string"
          }
        },
        url: "/user/repos"
      },
      createFork: {
        method: "POST",
        params: {
          organization: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/forks"
      },
      createHook: {
        method: "POST",
        params: {
          active: {
            type: "boolean"
          },
          config: {
            required: true,
            type: "object"
          },
          "config.content_type": {
            type: "string"
          },
          "config.insecure_ssl": {
            type: "string"
          },
          "config.secret": {
            type: "string"
          },
          "config.url": {
            required: true,
            type: "string"
          },
          events: {
            type: "string[]"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks"
      },
      createInOrg: {
        method: "POST",
        params: {
          allow_merge_commit: {
            type: "boolean"
          },
          allow_rebase_merge: {
            type: "boolean"
          },
          allow_squash_merge: {
            type: "boolean"
          },
          auto_init: {
            type: "boolean"
          },
          delete_branch_on_merge: {
            type: "boolean"
          },
          description: {
            type: "string"
          },
          gitignore_template: {
            type: "string"
          },
          has_issues: {
            type: "boolean"
          },
          has_projects: {
            type: "boolean"
          },
          has_wiki: {
            type: "boolean"
          },
          homepage: {
            type: "string"
          },
          is_template: {
            type: "boolean"
          },
          license_template: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          team_id: {
            type: "integer"
          },
          visibility: {
            enum: ["public", "private", "visibility", "internal"],
            type: "string"
          }
        },
        url: "/orgs/:org/repos"
      },
      createOrUpdateFile: {
        method: "PUT",
        params: {
          author: {
            type: "object"
          },
          "author.email": {
            required: true,
            type: "string"
          },
          "author.name": {
            required: true,
            type: "string"
          },
          branch: {
            type: "string"
          },
          committer: {
            type: "object"
          },
          "committer.email": {
            required: true,
            type: "string"
          },
          "committer.name": {
            required: true,
            type: "string"
          },
          content: {
            required: true,
            type: "string"
          },
          message: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contents/:path"
      },
      createRelease: {
        method: "POST",
        params: {
          body: {
            type: "string"
          },
          draft: {
            type: "boolean"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          prerelease: {
            type: "boolean"
          },
          repo: {
            required: true,
            type: "string"
          },
          tag_name: {
            required: true,
            type: "string"
          },
          target_commitish: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases"
      },
      createStatus: {
        method: "POST",
        params: {
          context: {
            type: "string"
          },
          description: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            required: true,
            type: "string"
          },
          state: {
            enum: ["error", "failure", "pending", "success"],
            required: true,
            type: "string"
          },
          target_url: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/statuses/:sha"
      },
      createUsingTemplate: {
        headers: {
          accept: "application/vnd.github.baptiste-preview+json"
        },
        method: "POST",
        params: {
          description: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          owner: {
            type: "string"
          },
          private: {
            type: "boolean"
          },
          template_owner: {
            required: true,
            type: "string"
          },
          template_repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:template_owner/:template_repo/generate"
      },
      declineInvitation: {
        method: "DELETE",
        params: {
          invitation_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/repository_invitations/:invitation_id"
      },
      delete: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo"
      },
      deleteCommitComment: {
        method: "DELETE",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments/:comment_id"
      },
      deleteDownload: {
        method: "DELETE",
        params: {
          download_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/downloads/:download_id"
      },
      deleteFile: {
        method: "DELETE",
        params: {
          author: {
            type: "object"
          },
          "author.email": {
            type: "string"
          },
          "author.name": {
            type: "string"
          },
          branch: {
            type: "string"
          },
          committer: {
            type: "object"
          },
          "committer.email": {
            type: "string"
          },
          "committer.name": {
            type: "string"
          },
          message: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contents/:path"
      },
      deleteHook: {
        method: "DELETE",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks/:hook_id"
      },
      deleteInvitation: {
        method: "DELETE",
        params: {
          invitation_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/invitations/:invitation_id"
      },
      deleteRelease: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          release_id: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/:release_id"
      },
      deleteReleaseAsset: {
        method: "DELETE",
        params: {
          asset_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/assets/:asset_id"
      },
      disableAutomatedSecurityFixes: {
        headers: {
          accept: "application/vnd.github.london-preview+json"
        },
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/automated-security-fixes"
      },
      disablePagesSite: {
        headers: {
          accept: "application/vnd.github.switcheroo-preview+json"
        },
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages"
      },
      disableVulnerabilityAlerts: {
        headers: {
          accept: "application/vnd.github.dorian-preview+json"
        },
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/vulnerability-alerts"
      },
      enableAutomatedSecurityFixes: {
        headers: {
          accept: "application/vnd.github.london-preview+json"
        },
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/automated-security-fixes"
      },
      enablePagesSite: {
        headers: {
          accept: "application/vnd.github.switcheroo-preview+json"
        },
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          source: {
            type: "object"
          },
          "source.branch": {
            enum: ["master", "gh-pages"],
            type: "string"
          },
          "source.path": {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages"
      },
      enableVulnerabilityAlerts: {
        headers: {
          accept: "application/vnd.github.dorian-preview+json"
        },
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/vulnerability-alerts"
      },
      get: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo"
      },
      getAppsWithAccessToProtectedBranch: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps"
      },
      getArchiveLink: {
        method: "GET",
        params: {
          archive_format: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/:archive_format/:ref"
      },
      getBranch: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch"
      },
      getBranchProtection: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection"
      },
      getClones: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          per: {
            enum: ["day", "week"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/traffic/clones"
      },
      getCodeFrequencyStats: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stats/code_frequency"
      },
      getCollaboratorPermissionLevel: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/collaborators/:username/permission"
      },
      getCombinedStatusForRef: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref/status"
      },
      getCommit: {
        method: "GET",
        params: {
          commit_sha: {
            alias: "ref",
            deprecated: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            alias: "ref",
            deprecated: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref"
      },
      getCommitActivityStats: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stats/commit_activity"
      },
      getCommitComment: {
        method: "GET",
        params: {
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments/:comment_id"
      },
      getCommitRefSha: {
        deprecated: "octokit.repos.getCommitRefSha() is deprecated, see https://developer.github.com/v3/repos/commits/#get-a-single-commit",
        headers: {
          accept: "application/vnd.github.v3.sha"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref"
      },
      getContents: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          ref: {
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contents/:path"
      },
      getContributorsStats: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stats/contributors"
      },
      getDeployKey: {
        method: "GET",
        params: {
          key_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/keys/:key_id"
      },
      getDeployment: {
        method: "GET",
        params: {
          deployment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/deployments/:deployment_id"
      },
      getDeploymentStatus: {
        method: "GET",
        params: {
          deployment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          status_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id"
      },
      getDownload: {
        method: "GET",
        params: {
          download_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/downloads/:download_id"
      },
      getHook: {
        method: "GET",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks/:hook_id"
      },
      getLatestPagesBuild: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages/builds/latest"
      },
      getLatestRelease: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/latest"
      },
      getPages: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages"
      },
      getPagesBuild: {
        method: "GET",
        params: {
          build_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages/builds/:build_id"
      },
      getParticipationStats: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stats/participation"
      },
      getProtectedBranchAdminEnforcement: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
      },
      getProtectedBranchPullRequestReviewEnforcement: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews"
      },
      getProtectedBranchRequiredSignatures: {
        headers: {
          accept: "application/vnd.github.zzzax-preview+json"
        },
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
      },
      getProtectedBranchRequiredStatusChecks: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
      },
      getProtectedBranchRestrictions: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions"
      },
      getPunchCardStats: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/stats/punch_card"
      },
      getReadme: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          ref: {
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/readme"
      },
      getRelease: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          release_id: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/:release_id"
      },
      getReleaseAsset: {
        method: "GET",
        params: {
          asset_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/assets/:asset_id"
      },
      getReleaseByTag: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          tag: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/tags/:tag"
      },
      getTeamsWithAccessToProtectedBranch: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      getTopPaths: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/traffic/popular/paths"
      },
      getTopReferrers: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/traffic/popular/referrers"
      },
      getUsersWithAccessToProtectedBranch: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      getViews: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          per: {
            enum: ["day", "week"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/traffic/views"
      },
      list: {
        method: "GET",
        params: {
          affiliation: {
            type: "string"
          },
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          sort: {
            enum: ["created", "updated", "pushed", "full_name"],
            type: "string"
          },
          type: {
            enum: ["all", "owner", "public", "private", "member"],
            type: "string"
          },
          visibility: {
            enum: ["all", "public", "private"],
            type: "string"
          }
        },
        url: "/user/repos"
      },
      listAppsWithAccessToProtectedBranch: {
        deprecated: "octokit.repos.listAppsWithAccessToProtectedBranch() has been renamed to octokit.repos.getAppsWithAccessToProtectedBranch() (2019-09-13)",
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps"
      },
      listAssetsForRelease: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          release_id: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/:release_id/assets"
      },
      listBranches: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          protected: {
            type: "boolean"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches"
      },
      listBranchesForHeadCommit: {
        headers: {
          accept: "application/vnd.github.groot-preview+json"
        },
        method: "GET",
        params: {
          commit_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:commit_sha/branches-where-head"
      },
      listCollaborators: {
        method: "GET",
        params: {
          affiliation: {
            enum: ["outside", "direct", "all"],
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/collaborators"
      },
      listCommentsForCommit: {
        method: "GET",
        params: {
          commit_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            alias: "commit_sha",
            deprecated: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:commit_sha/comments"
      },
      listCommitComments: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments"
      },
      listCommits: {
        method: "GET",
        params: {
          author: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          path: {
            type: "string"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          },
          since: {
            type: "string"
          },
          until: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits"
      },
      listContributors: {
        method: "GET",
        params: {
          anon: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contributors"
      },
      listDeployKeys: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/keys"
      },
      listDeploymentStatuses: {
        method: "GET",
        params: {
          deployment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/deployments/:deployment_id/statuses"
      },
      listDeployments: {
        method: "GET",
        params: {
          environment: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          },
          task: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/deployments"
      },
      listDownloads: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/downloads"
      },
      listForOrg: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          sort: {
            enum: ["created", "updated", "pushed", "full_name"],
            type: "string"
          },
          type: {
            enum: ["all", "public", "private", "forks", "sources", "member", "internal"],
            type: "string"
          }
        },
        url: "/orgs/:org/repos"
      },
      listForUser: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          sort: {
            enum: ["created", "updated", "pushed", "full_name"],
            type: "string"
          },
          type: {
            enum: ["all", "owner", "member"],
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/repos"
      },
      listForks: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["newest", "oldest", "stargazers"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/forks"
      },
      listHooks: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks"
      },
      listInvitations: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/invitations"
      },
      listInvitationsForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/repository_invitations"
      },
      listLanguages: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/languages"
      },
      listPagesBuilds: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages/builds"
      },
      listProtectedBranchRequiredStatusChecksContexts: {
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
      },
      listProtectedBranchTeamRestrictions: {
        deprecated: "octokit.repos.listProtectedBranchTeamRestrictions() has been renamed to octokit.repos.getTeamsWithAccessToProtectedBranch() (2019-09-09)",
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      listProtectedBranchUserRestrictions: {
        deprecated: "octokit.repos.listProtectedBranchUserRestrictions() has been renamed to octokit.repos.getUsersWithAccessToProtectedBranch() (2019-09-09)",
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      listPublic: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "integer"
          }
        },
        url: "/repositories"
      },
      listPullRequestsAssociatedWithCommit: {
        headers: {
          accept: "application/vnd.github.groot-preview+json"
        },
        method: "GET",
        params: {
          commit_sha: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:commit_sha/pulls"
      },
      listReleases: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases"
      },
      listStatusesForRef: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          ref: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/commits/:ref/statuses"
      },
      listTags: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/tags"
      },
      listTeams: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/teams"
      },
      listTeamsWithAccessToProtectedBranch: {
        deprecated: "octokit.repos.listTeamsWithAccessToProtectedBranch() has been renamed to octokit.repos.getTeamsWithAccessToProtectedBranch() (2019-09-13)",
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      listTopics: {
        headers: {
          accept: "application/vnd.github.mercy-preview+json"
        },
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/topics"
      },
      listUsersWithAccessToProtectedBranch: {
        deprecated: "octokit.repos.listUsersWithAccessToProtectedBranch() has been renamed to octokit.repos.getUsersWithAccessToProtectedBranch() (2019-09-13)",
        method: "GET",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      merge: {
        method: "POST",
        params: {
          base: {
            required: true,
            type: "string"
          },
          commit_message: {
            type: "string"
          },
          head: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/merges"
      },
      pingHook: {
        method: "POST",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks/:hook_id/pings"
      },
      removeBranchProtection: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection"
      },
      removeCollaborator: {
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/collaborators/:username"
      },
      removeDeployKey: {
        method: "DELETE",
        params: {
          key_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/keys/:key_id"
      },
      removeProtectedBranchAdminEnforcement: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
      },
      removeProtectedBranchAppRestrictions: {
        method: "DELETE",
        params: {
          apps: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps"
      },
      removeProtectedBranchPullRequestReviewEnforcement: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews"
      },
      removeProtectedBranchRequiredSignatures: {
        headers: {
          accept: "application/vnd.github.zzzax-preview+json"
        },
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
      },
      removeProtectedBranchRequiredStatusChecks: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
      },
      removeProtectedBranchRequiredStatusChecksContexts: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          contexts: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
      },
      removeProtectedBranchRestrictions: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions"
      },
      removeProtectedBranchTeamRestrictions: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          teams: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      removeProtectedBranchUserRestrictions: {
        method: "DELETE",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          users: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      replaceProtectedBranchAppRestrictions: {
        method: "PUT",
        params: {
          apps: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps"
      },
      replaceProtectedBranchRequiredStatusChecksContexts: {
        method: "PUT",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          contexts: {
            mapTo: "data",
            required: true,
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
      },
      replaceProtectedBranchTeamRestrictions: {
        method: "PUT",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          teams: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
      },
      replaceProtectedBranchUserRestrictions: {
        method: "PUT",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          users: {
            mapTo: "data",
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
      },
      replaceTopics: {
        headers: {
          accept: "application/vnd.github.mercy-preview+json"
        },
        method: "PUT",
        params: {
          names: {
            required: true,
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/topics"
      },
      requestPageBuild: {
        method: "POST",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages/builds"
      },
      retrieveCommunityProfileMetrics: {
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/community/profile"
      },
      testPushHook: {
        method: "POST",
        params: {
          hook_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks/:hook_id/tests"
      },
      transfer: {
        method: "POST",
        params: {
          new_owner: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_ids: {
            type: "integer[]"
          }
        },
        url: "/repos/:owner/:repo/transfer"
      },
      update: {
        method: "PATCH",
        params: {
          allow_merge_commit: {
            type: "boolean"
          },
          allow_rebase_merge: {
            type: "boolean"
          },
          allow_squash_merge: {
            type: "boolean"
          },
          archived: {
            type: "boolean"
          },
          default_branch: {
            type: "string"
          },
          delete_branch_on_merge: {
            type: "boolean"
          },
          description: {
            type: "string"
          },
          has_issues: {
            type: "boolean"
          },
          has_projects: {
            type: "boolean"
          },
          has_wiki: {
            type: "boolean"
          },
          homepage: {
            type: "string"
          },
          is_template: {
            type: "boolean"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          repo: {
            required: true,
            type: "string"
          },
          visibility: {
            enum: ["public", "private", "visibility", "internal"],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo"
      },
      updateBranchProtection: {
        method: "PUT",
        params: {
          allow_deletions: {
            type: "boolean"
          },
          allow_force_pushes: {
            allowNull: true,
            type: "boolean"
          },
          branch: {
            required: true,
            type: "string"
          },
          enforce_admins: {
            allowNull: true,
            required: true,
            type: "boolean"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          required_linear_history: {
            type: "boolean"
          },
          required_pull_request_reviews: {
            allowNull: true,
            required: true,
            type: "object"
          },
          "required_pull_request_reviews.dismiss_stale_reviews": {
            type: "boolean"
          },
          "required_pull_request_reviews.dismissal_restrictions": {
            type: "object"
          },
          "required_pull_request_reviews.dismissal_restrictions.teams": {
            type: "string[]"
          },
          "required_pull_request_reviews.dismissal_restrictions.users": {
            type: "string[]"
          },
          "required_pull_request_reviews.require_code_owner_reviews": {
            type: "boolean"
          },
          "required_pull_request_reviews.required_approving_review_count": {
            type: "integer"
          },
          required_status_checks: {
            allowNull: true,
            required: true,
            type: "object"
          },
          "required_status_checks.contexts": {
            required: true,
            type: "string[]"
          },
          "required_status_checks.strict": {
            required: true,
            type: "boolean"
          },
          restrictions: {
            allowNull: true,
            required: true,
            type: "object"
          },
          "restrictions.apps": {
            type: "string[]"
          },
          "restrictions.teams": {
            required: true,
            type: "string[]"
          },
          "restrictions.users": {
            required: true,
            type: "string[]"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection"
      },
      updateCommitComment: {
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/comments/:comment_id"
      },
      updateFile: {
        deprecated: "octokit.repos.updateFile() has been renamed to octokit.repos.createOrUpdateFile() (2019-06-07)",
        method: "PUT",
        params: {
          author: {
            type: "object"
          },
          "author.email": {
            required: true,
            type: "string"
          },
          "author.name": {
            required: true,
            type: "string"
          },
          branch: {
            type: "string"
          },
          committer: {
            type: "object"
          },
          "committer.email": {
            required: true,
            type: "string"
          },
          "committer.name": {
            required: true,
            type: "string"
          },
          content: {
            required: true,
            type: "string"
          },
          message: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          path: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          sha: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/contents/:path"
      },
      updateHook: {
        method: "PATCH",
        params: {
          active: {
            type: "boolean"
          },
          add_events: {
            type: "string[]"
          },
          config: {
            type: "object"
          },
          "config.content_type": {
            type: "string"
          },
          "config.insecure_ssl": {
            type: "string"
          },
          "config.secret": {
            type: "string"
          },
          "config.url": {
            required: true,
            type: "string"
          },
          events: {
            type: "string[]"
          },
          hook_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          remove_events: {
            type: "string[]"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/hooks/:hook_id"
      },
      updateInformationAboutPagesSite: {
        method: "PUT",
        params: {
          cname: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          source: {
            enum: ['"gh-pages"', '"master"', '"master /docs"'],
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/pages"
      },
      updateInvitation: {
        method: "PATCH",
        params: {
          invitation_id: {
            required: true,
            type: "integer"
          },
          owner: {
            required: true,
            type: "string"
          },
          permissions: {
            enum: ["read", "write", "admin"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/invitations/:invitation_id"
      },
      updateProtectedBranchPullRequestReviewEnforcement: {
        method: "PATCH",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          dismiss_stale_reviews: {
            type: "boolean"
          },
          dismissal_restrictions: {
            type: "object"
          },
          "dismissal_restrictions.teams": {
            type: "string[]"
          },
          "dismissal_restrictions.users": {
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          require_code_owner_reviews: {
            type: "boolean"
          },
          required_approving_review_count: {
            type: "integer"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews"
      },
      updateProtectedBranchRequiredStatusChecks: {
        method: "PATCH",
        params: {
          branch: {
            required: true,
            type: "string"
          },
          contexts: {
            type: "string[]"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          strict: {
            type: "boolean"
          }
        },
        url: "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
      },
      updateRelease: {
        method: "PATCH",
        params: {
          body: {
            type: "string"
          },
          draft: {
            type: "boolean"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          prerelease: {
            type: "boolean"
          },
          release_id: {
            required: true,
            type: "integer"
          },
          repo: {
            required: true,
            type: "string"
          },
          tag_name: {
            type: "string"
          },
          target_commitish: {
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/:release_id"
      },
      updateReleaseAsset: {
        method: "PATCH",
        params: {
          asset_id: {
            required: true,
            type: "integer"
          },
          label: {
            type: "string"
          },
          name: {
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          }
        },
        url: "/repos/:owner/:repo/releases/assets/:asset_id"
      },
      uploadReleaseAsset: {
        method: "POST",
        params: {
          data: {
            mapTo: "data",
            required: true,
            type: "string | object"
          },
          file: {
            alias: "data",
            deprecated: true,
            type: "string | object"
          },
          headers: {
            required: true,
            type: "object"
          },
          "headers.content-length": {
            required: true,
            type: "integer"
          },
          "headers.content-type": {
            required: true,
            type: "string"
          },
          label: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          url: {
            required: true,
            type: "string"
          }
        },
        url: ":url"
      }
    },
    search: {
      code: {
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["indexed"],
            type: "string"
          }
        },
        url: "/search/code"
      },
      commits: {
        headers: {
          accept: "application/vnd.github.cloak-preview+json"
        },
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["author-date", "committer-date"],
            type: "string"
          }
        },
        url: "/search/commits"
      },
      issues: {
        deprecated: "octokit.search.issues() has been renamed to octokit.search.issuesAndPullRequests() (2018-12-27)",
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["comments", "reactions", "reactions-+1", "reactions--1", "reactions-smile", "reactions-thinking_face", "reactions-heart", "reactions-tada", "interactions", "created", "updated"],
            type: "string"
          }
        },
        url: "/search/issues"
      },
      issuesAndPullRequests: {
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["comments", "reactions", "reactions-+1", "reactions--1", "reactions-smile", "reactions-thinking_face", "reactions-heart", "reactions-tada", "interactions", "created", "updated"],
            type: "string"
          }
        },
        url: "/search/issues"
      },
      labels: {
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          q: {
            required: true,
            type: "string"
          },
          repository_id: {
            required: true,
            type: "integer"
          },
          sort: {
            enum: ["created", "updated"],
            type: "string"
          }
        },
        url: "/search/labels"
      },
      repos: {
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["stars", "forks", "help-wanted-issues", "updated"],
            type: "string"
          }
        },
        url: "/search/repositories"
      },
      topics: {
        method: "GET",
        params: {
          q: {
            required: true,
            type: "string"
          }
        },
        url: "/search/topics"
      },
      users: {
        method: "GET",
        params: {
          order: {
            enum: ["desc", "asc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          q: {
            required: true,
            type: "string"
          },
          sort: {
            enum: ["followers", "repositories", "joined"],
            type: "string"
          }
        },
        url: "/search/users"
      }
    },
    teams: {
      addMember: {
        deprecated: "octokit.teams.addMember() has been renamed to octokit.teams.addMemberLegacy() (2020-01-16)",
        method: "PUT",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      addMemberLegacy: {
        deprecated: "octokit.teams.addMemberLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#add-team-member-legacy",
        method: "PUT",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      addOrUpdateMembership: {
        deprecated: "octokit.teams.addOrUpdateMembership() has been renamed to octokit.teams.addOrUpdateMembershipLegacy() (2020-01-16)",
        method: "PUT",
        params: {
          role: {
            enum: ["member", "maintainer"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      addOrUpdateMembershipInOrg: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          role: {
            enum: ["member", "maintainer"],
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/memberships/:username"
      },
      addOrUpdateMembershipLegacy: {
        deprecated: "octokit.teams.addOrUpdateMembershipLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#add-or-update-team-membership-legacy",
        method: "PUT",
        params: {
          role: {
            enum: ["member", "maintainer"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      addOrUpdateProject: {
        deprecated: "octokit.teams.addOrUpdateProject() has been renamed to octokit.teams.addOrUpdateProjectLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PUT",
        params: {
          permission: {
            enum: ["read", "write", "admin"],
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      addOrUpdateProjectInOrg: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          permission: {
            enum: ["read", "write", "admin"],
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/projects/:project_id"
      },
      addOrUpdateProjectLegacy: {
        deprecated: "octokit.teams.addOrUpdateProjectLegacy() is deprecated, see https://developer.github.com/v3/teams/#add-or-update-team-project-legacy",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "PUT",
        params: {
          permission: {
            enum: ["read", "write", "admin"],
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      addOrUpdateRepo: {
        deprecated: "octokit.teams.addOrUpdateRepo() has been renamed to octokit.teams.addOrUpdateRepoLegacy() (2020-01-16)",
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      addOrUpdateRepoInOrg: {
        method: "PUT",
        params: {
          org: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/repos/:owner/:repo"
      },
      addOrUpdateRepoLegacy: {
        deprecated: "octokit.teams.addOrUpdateRepoLegacy() is deprecated, see https://developer.github.com/v3/teams/#add-or-update-team-repository-legacy",
        method: "PUT",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      checkManagesRepo: {
        deprecated: "octokit.teams.checkManagesRepo() has been renamed to octokit.teams.checkManagesRepoLegacy() (2020-01-16)",
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      checkManagesRepoInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/repos/:owner/:repo"
      },
      checkManagesRepoLegacy: {
        deprecated: "octokit.teams.checkManagesRepoLegacy() is deprecated, see https://developer.github.com/v3/teams/#check-if-a-team-manages-a-repository-legacy",
        method: "GET",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      create: {
        method: "POST",
        params: {
          description: {
            type: "string"
          },
          maintainers: {
            type: "string[]"
          },
          name: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          parent_team_id: {
            type: "integer"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          privacy: {
            enum: ["secret", "closed"],
            type: "string"
          },
          repo_names: {
            type: "string[]"
          }
        },
        url: "/orgs/:org/teams"
      },
      createDiscussion: {
        deprecated: "octokit.teams.createDiscussion() has been renamed to octokit.teams.createDiscussionLegacy() (2020-01-16)",
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/discussions"
      },
      createDiscussionComment: {
        deprecated: "octokit.teams.createDiscussionComment() has been renamed to octokit.teams.createDiscussionCommentLegacy() (2020-01-16)",
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments"
      },
      createDiscussionCommentInOrg: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments"
      },
      createDiscussionCommentLegacy: {
        deprecated: "octokit.teams.createDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/teams/discussion_comments/#create-a-comment-legacy",
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments"
      },
      createDiscussionInOrg: {
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          team_slug: {
            required: true,
            type: "string"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions"
      },
      createDiscussionLegacy: {
        deprecated: "octokit.teams.createDiscussionLegacy() is deprecated, see https://developer.github.com/v3/teams/discussions/#create-a-discussion-legacy",
        method: "POST",
        params: {
          body: {
            required: true,
            type: "string"
          },
          private: {
            type: "boolean"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          title: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/discussions"
      },
      delete: {
        deprecated: "octokit.teams.delete() has been renamed to octokit.teams.deleteLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      },
      deleteDiscussion: {
        deprecated: "octokit.teams.deleteDiscussion() has been renamed to octokit.teams.deleteDiscussionLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      deleteDiscussionComment: {
        deprecated: "octokit.teams.deleteDiscussionComment() has been renamed to octokit.teams.deleteDiscussionCommentLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      deleteDiscussionCommentInOrg: {
        method: "DELETE",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number"
      },
      deleteDiscussionCommentLegacy: {
        deprecated: "octokit.teams.deleteDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/teams/discussion_comments/#delete-a-comment-legacy",
        method: "DELETE",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      deleteDiscussionInOrg: {
        method: "DELETE",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number"
      },
      deleteDiscussionLegacy: {
        deprecated: "octokit.teams.deleteDiscussionLegacy() is deprecated, see https://developer.github.com/v3/teams/discussions/#delete-a-discussion-legacy",
        method: "DELETE",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      deleteInOrg: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug"
      },
      deleteLegacy: {
        deprecated: "octokit.teams.deleteLegacy() is deprecated, see https://developer.github.com/v3/teams/#delete-team-legacy",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      },
      get: {
        deprecated: "octokit.teams.get() has been renamed to octokit.teams.getLegacy() (2020-01-16)",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      },
      getByName: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug"
      },
      getDiscussion: {
        deprecated: "octokit.teams.getDiscussion() has been renamed to octokit.teams.getDiscussionLegacy() (2020-01-16)",
        method: "GET",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      getDiscussionComment: {
        deprecated: "octokit.teams.getDiscussionComment() has been renamed to octokit.teams.getDiscussionCommentLegacy() (2020-01-16)",
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      getDiscussionCommentInOrg: {
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number"
      },
      getDiscussionCommentLegacy: {
        deprecated: "octokit.teams.getDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/teams/discussion_comments/#get-a-single-comment-legacy",
        method: "GET",
        params: {
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      getDiscussionInOrg: {
        method: "GET",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number"
      },
      getDiscussionLegacy: {
        deprecated: "octokit.teams.getDiscussionLegacy() is deprecated, see https://developer.github.com/v3/teams/discussions/#get-a-single-discussion-legacy",
        method: "GET",
        params: {
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      getLegacy: {
        deprecated: "octokit.teams.getLegacy() is deprecated, see https://developer.github.com/v3/teams/#get-team-legacy",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      },
      getMember: {
        deprecated: "octokit.teams.getMember() has been renamed to octokit.teams.getMemberLegacy() (2020-01-16)",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      getMemberLegacy: {
        deprecated: "octokit.teams.getMemberLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#get-team-member-legacy",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      getMembership: {
        deprecated: "octokit.teams.getMembership() has been renamed to octokit.teams.getMembershipLegacy() (2020-01-16)",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      getMembershipInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/memberships/:username"
      },
      getMembershipLegacy: {
        deprecated: "octokit.teams.getMembershipLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#get-team-membership-legacy",
        method: "GET",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      list: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/orgs/:org/teams"
      },
      listChild: {
        deprecated: "octokit.teams.listChild() has been renamed to octokit.teams.listChildLegacy() (2020-01-16)",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/teams"
      },
      listChildInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/teams"
      },
      listChildLegacy: {
        deprecated: "octokit.teams.listChildLegacy() is deprecated, see https://developer.github.com/v3/teams/#list-child-teams-legacy",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/teams"
      },
      listDiscussionComments: {
        deprecated: "octokit.teams.listDiscussionComments() has been renamed to octokit.teams.listDiscussionCommentsLegacy() (2020-01-16)",
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments"
      },
      listDiscussionCommentsInOrg: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments"
      },
      listDiscussionCommentsLegacy: {
        deprecated: "octokit.teams.listDiscussionCommentsLegacy() is deprecated, see https://developer.github.com/v3/teams/discussion_comments/#list-comments-legacy",
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments"
      },
      listDiscussions: {
        deprecated: "octokit.teams.listDiscussions() has been renamed to octokit.teams.listDiscussionsLegacy() (2020-01-16)",
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions"
      },
      listDiscussionsInOrg: {
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions"
      },
      listDiscussionsLegacy: {
        deprecated: "octokit.teams.listDiscussionsLegacy() is deprecated, see https://developer.github.com/v3/teams/discussions/#list-discussions-legacy",
        method: "GET",
        params: {
          direction: {
            enum: ["asc", "desc"],
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions"
      },
      listForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/teams"
      },
      listMembers: {
        deprecated: "octokit.teams.listMembers() has been renamed to octokit.teams.listMembersLegacy() (2020-01-16)",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          role: {
            enum: ["member", "maintainer", "all"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/members"
      },
      listMembersInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          role: {
            enum: ["member", "maintainer", "all"],
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/members"
      },
      listMembersLegacy: {
        deprecated: "octokit.teams.listMembersLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#list-team-members-legacy",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          role: {
            enum: ["member", "maintainer", "all"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/members"
      },
      listPendingInvitations: {
        deprecated: "octokit.teams.listPendingInvitations() has been renamed to octokit.teams.listPendingInvitationsLegacy() (2020-01-16)",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/invitations"
      },
      listPendingInvitationsInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/invitations"
      },
      listPendingInvitationsLegacy: {
        deprecated: "octokit.teams.listPendingInvitationsLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#list-pending-team-invitations-legacy",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/invitations"
      },
      listProjects: {
        deprecated: "octokit.teams.listProjects() has been renamed to octokit.teams.listProjectsLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects"
      },
      listProjectsInOrg: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/projects"
      },
      listProjectsLegacy: {
        deprecated: "octokit.teams.listProjectsLegacy() is deprecated, see https://developer.github.com/v3/teams/#list-team-projects-legacy",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects"
      },
      listRepos: {
        deprecated: "octokit.teams.listRepos() has been renamed to octokit.teams.listReposLegacy() (2020-01-16)",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos"
      },
      listReposInOrg: {
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/repos"
      },
      listReposLegacy: {
        deprecated: "octokit.teams.listReposLegacy() is deprecated, see https://developer.github.com/v3/teams/#list-team-repos-legacy",
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos"
      },
      removeMember: {
        deprecated: "octokit.teams.removeMember() has been renamed to octokit.teams.removeMemberLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      removeMemberLegacy: {
        deprecated: "octokit.teams.removeMemberLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#remove-team-member-legacy",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/members/:username"
      },
      removeMembership: {
        deprecated: "octokit.teams.removeMembership() has been renamed to octokit.teams.removeMembershipLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      removeMembershipInOrg: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/memberships/:username"
      },
      removeMembershipLegacy: {
        deprecated: "octokit.teams.removeMembershipLegacy() is deprecated, see https://developer.github.com/v3/teams/members/#remove-team-membership-legacy",
        method: "DELETE",
        params: {
          team_id: {
            required: true,
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/teams/:team_id/memberships/:username"
      },
      removeProject: {
        deprecated: "octokit.teams.removeProject() has been renamed to octokit.teams.removeProjectLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      removeProjectInOrg: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/projects/:project_id"
      },
      removeProjectLegacy: {
        deprecated: "octokit.teams.removeProjectLegacy() is deprecated, see https://developer.github.com/v3/teams/#remove-team-project-legacy",
        method: "DELETE",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      removeRepo: {
        deprecated: "octokit.teams.removeRepo() has been renamed to octokit.teams.removeRepoLegacy() (2020-01-16)",
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      removeRepoInOrg: {
        method: "DELETE",
        params: {
          org: {
            required: true,
            type: "string"
          },
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/repos/:owner/:repo"
      },
      removeRepoLegacy: {
        deprecated: "octokit.teams.removeRepoLegacy() is deprecated, see https://developer.github.com/v3/teams/#remove-team-repository-legacy",
        method: "DELETE",
        params: {
          owner: {
            required: true,
            type: "string"
          },
          repo: {
            required: true,
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/repos/:owner/:repo"
      },
      reviewProject: {
        deprecated: "octokit.teams.reviewProject() has been renamed to octokit.teams.reviewProjectLegacy() (2020-01-16)",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      reviewProjectInOrg: {
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          org: {
            required: true,
            type: "string"
          },
          project_id: {
            required: true,
            type: "integer"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/projects/:project_id"
      },
      reviewProjectLegacy: {
        deprecated: "octokit.teams.reviewProjectLegacy() is deprecated, see https://developer.github.com/v3/teams/#review-a-team-project-legacy",
        headers: {
          accept: "application/vnd.github.inertia-preview+json"
        },
        method: "GET",
        params: {
          project_id: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/projects/:project_id"
      },
      update: {
        deprecated: "octokit.teams.update() has been renamed to octokit.teams.updateLegacy() (2020-01-16)",
        method: "PATCH",
        params: {
          description: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          parent_team_id: {
            type: "integer"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          privacy: {
            enum: ["secret", "closed"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      },
      updateDiscussion: {
        deprecated: "octokit.teams.updateDiscussion() has been renamed to octokit.teams.updateDiscussionLegacy() (2020-01-16)",
        method: "PATCH",
        params: {
          body: {
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          title: {
            type: "string"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      updateDiscussionComment: {
        deprecated: "octokit.teams.updateDiscussionComment() has been renamed to octokit.teams.updateDiscussionCommentLegacy() (2020-01-16)",
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      updateDiscussionCommentInOrg: {
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number"
      },
      updateDiscussionCommentLegacy: {
        deprecated: "octokit.teams.updateDiscussionCommentLegacy() is deprecated, see https://developer.github.com/v3/teams/discussion_comments/#edit-a-comment-legacy",
        method: "PATCH",
        params: {
          body: {
            required: true,
            type: "string"
          },
          comment_number: {
            required: true,
            type: "integer"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number/comments/:comment_number"
      },
      updateDiscussionInOrg: {
        method: "PATCH",
        params: {
          body: {
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          org: {
            required: true,
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug/discussions/:discussion_number"
      },
      updateDiscussionLegacy: {
        deprecated: "octokit.teams.updateDiscussionLegacy() is deprecated, see https://developer.github.com/v3/teams/discussions/#edit-a-discussion-legacy",
        method: "PATCH",
        params: {
          body: {
            type: "string"
          },
          discussion_number: {
            required: true,
            type: "integer"
          },
          team_id: {
            required: true,
            type: "integer"
          },
          title: {
            type: "string"
          }
        },
        url: "/teams/:team_id/discussions/:discussion_number"
      },
      updateInOrg: {
        method: "PATCH",
        params: {
          description: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          org: {
            required: true,
            type: "string"
          },
          parent_team_id: {
            type: "integer"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          privacy: {
            enum: ["secret", "closed"],
            type: "string"
          },
          team_slug: {
            required: true,
            type: "string"
          }
        },
        url: "/orgs/:org/teams/:team_slug"
      },
      updateLegacy: {
        deprecated: "octokit.teams.updateLegacy() is deprecated, see https://developer.github.com/v3/teams/#edit-team-legacy",
        method: "PATCH",
        params: {
          description: {
            type: "string"
          },
          name: {
            required: true,
            type: "string"
          },
          parent_team_id: {
            type: "integer"
          },
          permission: {
            enum: ["pull", "push", "admin"],
            type: "string"
          },
          privacy: {
            enum: ["secret", "closed"],
            type: "string"
          },
          team_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/teams/:team_id"
      }
    },
    users: {
      addEmails: {
        method: "POST",
        params: {
          emails: {
            required: true,
            type: "string[]"
          }
        },
        url: "/user/emails"
      },
      block: {
        method: "PUT",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/blocks/:username"
      },
      checkBlocked: {
        method: "GET",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/blocks/:username"
      },
      checkFollowing: {
        method: "GET",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/following/:username"
      },
      checkFollowingForUser: {
        method: "GET",
        params: {
          target_user: {
            required: true,
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/following/:target_user"
      },
      createGpgKey: {
        method: "POST",
        params: {
          armored_public_key: {
            type: "string"
          }
        },
        url: "/user/gpg_keys"
      },
      createPublicKey: {
        method: "POST",
        params: {
          key: {
            type: "string"
          },
          title: {
            type: "string"
          }
        },
        url: "/user/keys"
      },
      deleteEmails: {
        method: "DELETE",
        params: {
          emails: {
            required: true,
            type: "string[]"
          }
        },
        url: "/user/emails"
      },
      deleteGpgKey: {
        method: "DELETE",
        params: {
          gpg_key_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/gpg_keys/:gpg_key_id"
      },
      deletePublicKey: {
        method: "DELETE",
        params: {
          key_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/keys/:key_id"
      },
      follow: {
        method: "PUT",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/following/:username"
      },
      getAuthenticated: {
        method: "GET",
        params: {},
        url: "/user"
      },
      getByUsername: {
        method: "GET",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username"
      },
      getContextForUser: {
        method: "GET",
        params: {
          subject_id: {
            type: "string"
          },
          subject_type: {
            enum: ["organization", "repository", "issue", "pull_request"],
            type: "string"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/hovercard"
      },
      getGpgKey: {
        method: "GET",
        params: {
          gpg_key_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/gpg_keys/:gpg_key_id"
      },
      getPublicKey: {
        method: "GET",
        params: {
          key_id: {
            required: true,
            type: "integer"
          }
        },
        url: "/user/keys/:key_id"
      },
      list: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          since: {
            type: "string"
          }
        },
        url: "/users"
      },
      listBlocked: {
        method: "GET",
        params: {},
        url: "/user/blocks"
      },
      listEmails: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/emails"
      },
      listFollowersForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/followers"
      },
      listFollowersForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/followers"
      },
      listFollowingForAuthenticatedUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/following"
      },
      listFollowingForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/following"
      },
      listGpgKeys: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/gpg_keys"
      },
      listGpgKeysForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/gpg_keys"
      },
      listPublicEmails: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/public_emails"
      },
      listPublicKeys: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          }
        },
        url: "/user/keys"
      },
      listPublicKeysForUser: {
        method: "GET",
        params: {
          page: {
            type: "integer"
          },
          per_page: {
            type: "integer"
          },
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/users/:username/keys"
      },
      togglePrimaryEmailVisibility: {
        method: "PATCH",
        params: {
          email: {
            required: true,
            type: "string"
          },
          visibility: {
            required: true,
            type: "string"
          }
        },
        url: "/user/email/visibility"
      },
      unblock: {
        method: "DELETE",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/blocks/:username"
      },
      unfollow: {
        method: "DELETE",
        params: {
          username: {
            required: true,
            type: "string"
          }
        },
        url: "/user/following/:username"
      },
      updateAuthenticated: {
        method: "PATCH",
        params: {
          bio: {
            type: "string"
          },
          blog: {
            type: "string"
          },
          company: {
            type: "string"
          },
          email: {
            type: "string"
          },
          hireable: {
            type: "boolean"
          },
          location: {
            type: "string"
          },
          name: {
            type: "string"
          }
        },
        url: "/user"
      }
    }
  };
  var VERSION = "2.4.0";
  function registerEndpoints(octokit, routes) {
    Object.keys(routes).forEach((namespaceName) => {
      if (!octokit[namespaceName]) {
        octokit[namespaceName] = {};
      }
      Object.keys(routes[namespaceName]).forEach((apiName) => {
        const apiOptions = routes[namespaceName][apiName];
        const endpointDefaults = ["method", "url", "headers"].reduce((map, key) => {
          if (typeof apiOptions[key] !== "undefined") {
            map[key] = apiOptions[key];
          }
          return map;
        }, {});
        endpointDefaults.request = {
          validate: apiOptions.params
        };
        let request = octokit.request.defaults(endpointDefaults);
        const hasDeprecatedParam = Object.keys(apiOptions.params || {}).find((key) => apiOptions.params[key].deprecated);
        if (hasDeprecatedParam) {
          const patch = patchForDeprecation.bind(null, octokit, apiOptions);
          request = patch(octokit.request.defaults(endpointDefaults), `.${namespaceName}.${apiName}()`);
          request.endpoint = patch(request.endpoint, `.${namespaceName}.${apiName}.endpoint()`);
          request.endpoint.merge = patch(request.endpoint.merge, `.${namespaceName}.${apiName}.endpoint.merge()`);
        }
        if (apiOptions.deprecated) {
          octokit[namespaceName][apiName] = Object.assign(function deprecatedEndpointMethod() {
            octokit.log.warn(new deprecation.Deprecation(`[@octokit/rest] ${apiOptions.deprecated}`));
            octokit[namespaceName][apiName] = request;
            return request.apply(null, arguments);
          }, request);
          return;
        }
        octokit[namespaceName][apiName] = request;
      });
    });
  }
  function patchForDeprecation(octokit, apiOptions, method, methodName) {
    const patchedMethod = (options) => {
      options = Object.assign({}, options);
      Object.keys(options).forEach((key) => {
        if (apiOptions.params[key] && apiOptions.params[key].deprecated) {
          const aliasKey = apiOptions.params[key].alias;
          octokit.log.warn(new deprecation.Deprecation(`[@octokit/rest] "${key}" parameter is deprecated for "${methodName}". Use "${aliasKey}" instead`));
          if (!(aliasKey in options)) {
            options[aliasKey] = options[key];
          }
          delete options[key];
        }
      });
      return method(options);
    };
    Object.keys(method).forEach((key) => {
      patchedMethod[key] = method[key];
    });
    return patchedMethod;
  }
  function restEndpointMethods(octokit) {
    octokit.registerEndpoints = registerEndpoints.bind(null, octokit);
    registerEndpoints(octokit, endpointsByScope);
    [["gitdata", "git"], ["authorization", "oauthAuthorizations"], ["pullRequests", "pulls"]].forEach(([deprecatedScope, scope]) => {
      Object.defineProperty(octokit, deprecatedScope, {
        get() {
          octokit.log.warn(new deprecation.Deprecation(`[@octokit/plugin-rest-endpoint-methods] "octokit.${deprecatedScope}.*" methods are deprecated, use "octokit.${scope}.*" instead`));
          return octokit[scope];
        }
      });
    });
    return {};
  }
  restEndpointMethods.VERSION = VERSION;
  exports2.restEndpointMethods = restEndpointMethods;
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS((exports2, module2) => {
  module2.exports = register;
  function register(state, name, method, options) {
    if (typeof method !== "function") {
      throw new Error("method for before hook must be a function");
    }
    if (!options) {
      options = {};
    }
    if (Array.isArray(name)) {
      return name.reverse().reduce(function(callback, name2) {
        return register.bind(null, state, name2, callback, options);
      }, method)();
    }
    return Promise.resolve().then(function() {
      if (!state.registry[name]) {
        return method(options);
      }
      return state.registry[name].reduce(function(method2, registered) {
        return registered.hook.bind(null, method2, options);
      }, method)();
    });
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS((exports2, module2) => {
  module2.exports = addHook;
  function addHook(state, kind, name, hook) {
    var orig = hook;
    if (!state.registry[name]) {
      state.registry[name] = [];
    }
    if (kind === "before") {
      hook = function(method, options) {
        return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
      };
    }
    if (kind === "after") {
      hook = function(method, options) {
        var result;
        return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
          result = result_;
          return orig(result, options);
        }).then(function() {
          return result;
        });
      };
    }
    if (kind === "error") {
      hook = function(method, options) {
        return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
          return orig(error, options);
        });
      };
    }
    state.registry[name].push({
      hook,
      orig
    });
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS((exports2, module2) => {
  module2.exports = removeHook;
  function removeHook(state, name, method) {
    if (!state.registry[name]) {
      return;
    }
    var index = state.registry[name].map(function(registered) {
      return registered.orig;
    }).indexOf(method);
    if (index === -1) {
      return;
    }
    state.registry[name].splice(index, 1);
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS((exports2, module2) => {
  var register = require_register();
  var addHook = require_add();
  var removeHook = require_remove();
  var bind = Function.bind;
  var bindable = bind.bind(bind);
  function bindApi(hook, state, name) {
    var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
    hook.api = {remove: removeHookRef};
    hook.remove = removeHookRef;
    ["before", "error", "after", "wrap"].forEach(function(kind) {
      var args = name ? [state, kind, name] : [state, kind];
      hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
    });
  }
  function HookSingular() {
    var singularHookName = "h";
    var singularHookState = {
      registry: {}
    };
    var singularHook = register.bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
  }
  function HookCollection() {
    var state = {
      registry: {}
    };
    var hook = register.bind(null, state);
    bindApi(hook, state);
    return hook;
  }
  var collectionHookDeprecationMessageDisplayed = false;
  function Hook() {
    if (!collectionHookDeprecationMessageDisplayed) {
      console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
      collectionHookDeprecationMessageDisplayed = true;
    }
    return HookCollection();
  }
  Hook.Singular = HookSingular.bind();
  Hook.Collection = HookCollection.bind();
  module2.exports = Hook;
  module2.exports.Hook = Hook;
  module2.exports.Singular = Hook.Singular;
  module2.exports.Collection = Hook.Collection;
});

// node_modules/@octokit/rest/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node9 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var osName = _interopDefault(require_os_name());
  function getUserAgent() {
    try {
      return `Node.js/${process.version.substr(1)} (${osName()}; ${process.arch})`;
    } catch (error) {
      if (/wmic os get Caption/.test(error.message)) {
        return "Windows <version undetectable>";
      }
      throw error;
    }
  }
  exports2.getUserAgent = getUserAgent;
});

// node_modules/@octokit/rest/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    _from: "@octokit/rest@^16.15.0",
    _id: "@octokit/rest@16.43.2",
    _inBundle: false,
    _integrity: "sha512-ngDBevLbBTFfrHZeiS7SAMAZ6ssuVmXuya+F/7RaVvlysgGa1JKJkKWY+jV6TCJYcW0OALfJ7nTIGXcBXzycfQ==",
    _location: "/@octokit/rest",
    _phantomChildren: {
      "@types/node": "14.14.22",
      deprecation: "2.3.1",
      once: "1.4.0",
      "os-name": "3.1.0"
    },
    _requested: {
      type: "range",
      registry: true,
      raw: "@octokit/rest@^16.15.0",
      name: "@octokit/rest",
      escapedName: "@octokit%2frest",
      scope: "@octokit",
      rawSpec: "^16.15.0",
      saveSpec: null,
      fetchSpec: "^16.15.0"
    },
    _requiredBy: [
      "/@actions/github"
    ],
    _resolved: "https://registry.npmjs.org/@octokit/rest/-/rest-16.43.2.tgz",
    _shasum: "c53426f1e1d1044dee967023e3279c50993dd91b",
    _spec: "@octokit/rest@^16.15.0",
    _where: "/Users/orshefi/workspace/ci/github-tag-action/node_modules/@actions/github",
    author: {
      name: "Gregor Martynus",
      url: "https://github.com/gr2m"
    },
    bugs: {
      url: "https://github.com/octokit/rest.js/issues"
    },
    bundleDependencies: false,
    bundlesize: [
      {
        path: "./dist/octokit-rest.min.js.gz",
        maxSize: "33 kB"
      }
    ],
    contributors: [
      {
        name: "Mike de Boer",
        email: "info@mikedeboer.nl"
      },
      {
        name: "Fabian Jakobs",
        email: "fabian@c9.io"
      },
      {
        name: "Joe Gallo",
        email: "joe@brassafrax.com"
      },
      {
        name: "Gregor Martynus",
        url: "https://github.com/gr2m"
      }
    ],
    dependencies: {
      "@octokit/auth-token": "^2.4.0",
      "@octokit/plugin-paginate-rest": "^1.1.1",
      "@octokit/plugin-request-log": "^1.0.0",
      "@octokit/plugin-rest-endpoint-methods": "2.4.0",
      "@octokit/request": "^5.2.0",
      "@octokit/request-error": "^1.0.2",
      "atob-lite": "^2.0.0",
      "before-after-hook": "^2.0.0",
      "btoa-lite": "^1.0.0",
      deprecation: "^2.0.0",
      "lodash.get": "^4.4.2",
      "lodash.set": "^4.3.2",
      "lodash.uniq": "^4.5.0",
      "octokit-pagination-methods": "^1.1.0",
      once: "^1.4.0",
      "universal-user-agent": "^4.0.0"
    },
    deprecated: false,
    description: "GitHub REST API client for Node.js",
    devDependencies: {
      "@gimenete/type-writer": "^0.1.3",
      "@octokit/auth": "^1.1.1",
      "@octokit/fixtures-server": "^5.0.6",
      "@octokit/graphql": "^4.2.0",
      "@types/node": "^13.1.0",
      bundlesize: "^0.18.0",
      chai: "^4.1.2",
      "compression-webpack-plugin": "^3.1.0",
      cypress: "^4.0.0",
      glob: "^7.1.2",
      "http-proxy-agent": "^4.0.0",
      "lodash.camelcase": "^4.3.0",
      "lodash.merge": "^4.6.1",
      "lodash.upperfirst": "^4.3.1",
      lolex: "^6.0.0",
      mkdirp: "^1.0.0",
      mocha: "^7.0.1",
      mustache: "^4.0.0",
      nock: "^11.3.3",
      "npm-run-all": "^4.1.2",
      nyc: "^15.0.0",
      prettier: "^1.14.2",
      proxy: "^1.0.0",
      "semantic-release": "^17.0.0",
      sinon: "^8.0.0",
      "sinon-chai": "^3.0.0",
      "sort-keys": "^4.0.0",
      "string-to-arraybuffer": "^1.0.0",
      "string-to-jsdoc-comment": "^1.0.0",
      typescript: "^3.3.1",
      webpack: "^4.0.0",
      "webpack-bundle-analyzer": "^3.0.0",
      "webpack-cli": "^3.0.0"
    },
    files: [
      "index.js",
      "index.d.ts",
      "lib",
      "plugins"
    ],
    homepage: "https://github.com/octokit/rest.js#readme",
    keywords: [
      "octokit",
      "github",
      "rest",
      "api-client"
    ],
    license: "MIT",
    name: "@octokit/rest",
    nyc: {
      ignore: [
        "test"
      ]
    },
    publishConfig: {
      access: "public"
    },
    release: {
      publish: [
        "@semantic-release/npm",
        {
          path: "@semantic-release/github",
          assets: [
            "dist/*",
            "!dist/*.map.gz"
          ]
        }
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/octokit/rest.js.git"
    },
    scripts: {
      build: "npm-run-all build:*",
      "build:browser": "npm-run-all build:browser:*",
      "build:browser:development": "webpack --mode development --entry . --output-library=Octokit --output=./dist/octokit-rest.js --profile --json > dist/bundle-stats.json",
      "build:browser:production": "webpack --mode production --entry . --plugin=compression-webpack-plugin --output-library=Octokit --output-path=./dist --output-filename=octokit-rest.min.js --devtool source-map",
      "build:ts": "npm run -s update-endpoints:typescript",
      coverage: "nyc report --reporter=html && open coverage/index.html",
      "generate-bundle-report": "webpack-bundle-analyzer dist/bundle-stats.json --mode=static --no-open --report dist/bundle-report.html",
      lint: "prettier --check '{lib,plugins,scripts,test}/**/*.{js,json,ts}' 'docs/*.{js,json}' 'docs/src/**/*' index.js README.md package.json",
      "lint:fix": "prettier --write '{lib,plugins,scripts,test}/**/*.{js,json,ts}' 'docs/*.{js,json}' 'docs/src/**/*' index.js README.md package.json",
      "postvalidate:ts": "tsc --noEmit --target es6 test/typescript-validate.ts",
      "prebuild:browser": "mkdirp dist/",
      pretest: "npm run -s lint",
      "prevalidate:ts": "npm run -s build:ts",
      "start-fixtures-server": "octokit-fixtures-server",
      test: 'nyc mocha test/mocha-node-setup.js "test/*/**/*-test.js"',
      "test:browser": "cypress run --browser chrome",
      "update-endpoints": "npm-run-all update-endpoints:*",
      "update-endpoints:fetch-json": "node scripts/update-endpoints/fetch-json",
      "update-endpoints:typescript": "node scripts/update-endpoints/typescript",
      "validate:ts": "tsc --target es6 --noImplicitAny index.d.ts"
    },
    types: "index.d.ts",
    version: "16.43.2"
  };
});

// node_modules/@octokit/rest/lib/parse-client-options.js
var require_parse_client_options = __commonJS((exports2, module2) => {
  module2.exports = parseOptions;
  var {Deprecation} = require_dist_node4();
  var {getUserAgent} = require_dist_node9();
  var once = require_once();
  var pkg = require_package2();
  var deprecateOptionsTimeout = once((log, deprecation) => log.warn(deprecation));
  var deprecateOptionsAgent = once((log, deprecation) => log.warn(deprecation));
  var deprecateOptionsHeaders = once((log, deprecation) => log.warn(deprecation));
  function parseOptions(options, log, hook) {
    if (options.headers) {
      options.headers = Object.keys(options.headers).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = options.headers[key];
        return newObj;
      }, {});
    }
    const clientDefaults = {
      headers: options.headers || {},
      request: options.request || {},
      mediaType: {
        previews: [],
        format: ""
      }
    };
    if (options.baseUrl) {
      clientDefaults.baseUrl = options.baseUrl;
    }
    if (options.userAgent) {
      clientDefaults.headers["user-agent"] = options.userAgent;
    }
    if (options.previews) {
      clientDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      clientDefaults.headers["time-zone"] = options.timeZone;
    }
    if (options.timeout) {
      deprecateOptionsTimeout(log, new Deprecation("[@octokit/rest] new Octokit({timeout}) is deprecated. Use {request: {timeout}} instead. See https://github.com/octokit/request.js#request"));
      clientDefaults.request.timeout = options.timeout;
    }
    if (options.agent) {
      deprecateOptionsAgent(log, new Deprecation("[@octokit/rest] new Octokit({agent}) is deprecated. Use {request: {agent}} instead. See https://github.com/octokit/request.js#request"));
      clientDefaults.request.agent = options.agent;
    }
    if (options.headers) {
      deprecateOptionsHeaders(log, new Deprecation("[@octokit/rest] new Octokit({headers}) is deprecated. Use {userAgent, previews} instead. See https://github.com/octokit/request.js#request"));
    }
    const userAgentOption = clientDefaults.headers["user-agent"];
    const defaultUserAgent = `octokit.js/${pkg.version} ${getUserAgent()}`;
    clientDefaults.headers["user-agent"] = [userAgentOption, defaultUserAgent].filter(Boolean).join(" ");
    clientDefaults.request.hook = hook.bind(null, "request");
    return clientDefaults;
  }
});

// node_modules/@octokit/rest/lib/constructor.js
var require_constructor = __commonJS((exports2, module2) => {
  module2.exports = Octokit;
  var {request} = require_dist_node6();
  var Hook = require_before_after_hook();
  var parseClientOptions = require_parse_client_options();
  function Octokit(plugins, options) {
    options = options || {};
    const hook = new Hook.Collection();
    const log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn,
      error: console.error
    }, options && options.log);
    const api = {
      hook,
      log,
      request: request.defaults(parseClientOptions(options, log, hook))
    };
    plugins.forEach((pluginFunction) => pluginFunction(api, options));
    return api;
  }
});

// node_modules/@octokit/rest/lib/register-plugin.js
var require_register_plugin = __commonJS((exports2, module2) => {
  module2.exports = registerPlugin;
  var factory = require_factory();
  function registerPlugin(plugins, pluginFunction) {
    return factory(plugins.includes(pluginFunction) ? plugins : plugins.concat(pluginFunction));
  }
});

// node_modules/@octokit/rest/lib/factory.js
var require_factory = __commonJS((exports2, module2) => {
  module2.exports = factory;
  var Octokit = require_constructor();
  var registerPlugin = require_register_plugin();
  function factory(plugins) {
    const Api = Octokit.bind(null, plugins || []);
    Api.plugin = registerPlugin.bind(null, plugins || []);
    return Api;
  }
});

// node_modules/@octokit/rest/lib/core.js
var require_core5 = __commonJS((exports2, module2) => {
  var factory = require_factory();
  module2.exports = factory();
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node10 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  async function auth(token) {
    const tokenType = token.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token) ? "installation" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  }
  function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
      return `bearer ${token}`;
    }
    return `token ${token}`;
  }
  async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
  }
  var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
      throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
      throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
      hook: hook.bind(null, token)
    });
  };
  exports2.createTokenAuth = createTokenAuth;
});

// node_modules/btoa-lite/btoa-node.js
var require_btoa_node = __commonJS((exports2, module2) => {
  module2.exports = function btoa(str) {
    return new Buffer(str).toString("base64");
  };
});

// node_modules/atob-lite/atob-node.js
var require_atob_node = __commonJS((exports2, module2) => {
  module2.exports = function atob(str) {
    return Buffer.from(str, "base64").toString("binary");
  };
});

// node_modules/@octokit/rest/plugins/authentication/with-authorization-prefix.js
var require_with_authorization_prefix = __commonJS((exports2, module2) => {
  module2.exports = withAuthorizationPrefix;
  var atob = require_atob_node();
  var REGEX_IS_BASIC_AUTH = /^[\w-]+:/;
  function withAuthorizationPrefix(authorization) {
    if (/^(basic|bearer|token) /i.test(authorization)) {
      return authorization;
    }
    try {
      if (REGEX_IS_BASIC_AUTH.test(atob(authorization))) {
        return `basic ${authorization}`;
      }
    } catch (error) {
    }
    if (authorization.split(/\./).length === 3) {
      return `bearer ${authorization}`;
    }
    return `token ${authorization}`;
  }
});

// node_modules/@octokit/rest/plugins/authentication/before-request.js
var require_before_request = __commonJS((exports2, module2) => {
  module2.exports = authenticationBeforeRequest;
  var btoa = require_btoa_node();
  var withAuthorizationPrefix = require_with_authorization_prefix();
  function authenticationBeforeRequest(state, options) {
    if (typeof state.auth === "string") {
      options.headers.authorization = withAuthorizationPrefix(state.auth);
      return;
    }
    if (state.auth.username) {
      const hash = btoa(`${state.auth.username}:${state.auth.password}`);
      options.headers.authorization = `Basic ${hash}`;
      if (state.otp) {
        options.headers["x-github-otp"] = state.otp;
      }
      return;
    }
    if (state.auth.clientId) {
      if (/\/applications\/:?[\w_]+\/tokens\/:?[\w_]+($|\?)/.test(options.url)) {
        const hash = btoa(`${state.auth.clientId}:${state.auth.clientSecret}`);
        options.headers.authorization = `Basic ${hash}`;
        return;
      }
      options.url += options.url.indexOf("?") === -1 ? "?" : "&";
      options.url += `client_id=${state.auth.clientId}&client_secret=${state.auth.clientSecret}`;
      return;
    }
    return Promise.resolve().then(() => {
      return state.auth();
    }).then((authorization) => {
      options.headers.authorization = withAuthorizationPrefix(authorization);
    });
  }
});

// node_modules/@octokit/rest/node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node11 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var deprecation = require_dist_node4();
  var once = _interopDefault(require_once());
  var logOnce = once((deprecation2) => console.warn(deprecation2));
  var RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.status = statusCode;
      Object.defineProperty(this, "code", {
        get() {
          logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
          return statusCode;
        }
      });
      this.headers = options.headers || {};
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
    }
  };
  exports2.RequestError = RequestError;
});

// node_modules/@octokit/rest/plugins/authentication/request-error.js
var require_request_error = __commonJS((exports2, module2) => {
  module2.exports = authenticationRequestError;
  var {RequestError} = require_dist_node11();
  function authenticationRequestError(state, error, options) {
    if (!error.headers)
      throw error;
    const otpRequired = /required/.test(error.headers["x-github-otp"] || "");
    if (error.status !== 401 || !otpRequired) {
      throw error;
    }
    if (error.status === 401 && otpRequired && error.request && error.request.headers["x-github-otp"]) {
      if (state.otp) {
        delete state.otp;
      } else {
        throw new RequestError("Invalid one-time password for two-factor authentication", 401, {
          headers: error.headers,
          request: options
        });
      }
    }
    if (typeof state.auth.on2fa !== "function") {
      throw new RequestError("2FA required, but options.on2fa is not a function. See https://github.com/octokit/rest.js#authentication", 401, {
        headers: error.headers,
        request: options
      });
    }
    return Promise.resolve().then(() => {
      return state.auth.on2fa();
    }).then((oneTimePassword) => {
      const newOptions = Object.assign(options, {
        headers: Object.assign(options.headers, {
          "x-github-otp": oneTimePassword
        })
      });
      return state.octokit.request(newOptions).then((response) => {
        state.otp = oneTimePassword;
        return response;
      });
    });
  }
});

// node_modules/@octokit/rest/plugins/authentication/validate.js
var require_validate = __commonJS((exports2, module2) => {
  module2.exports = validateAuth;
  function validateAuth(auth) {
    if (typeof auth === "string") {
      return;
    }
    if (typeof auth === "function") {
      return;
    }
    if (auth.username && auth.password) {
      return;
    }
    if (auth.clientId && auth.clientSecret) {
      return;
    }
    throw new Error(`Invalid "auth" option: ${JSON.stringify(auth)}`);
  }
});

// node_modules/@octokit/rest/plugins/authentication/index.js
var require_authentication = __commonJS((exports2, module2) => {
  module2.exports = authenticationPlugin;
  var {createTokenAuth} = require_dist_node10();
  var {Deprecation} = require_dist_node4();
  var once = require_once();
  var beforeRequest = require_before_request();
  var requestError = require_request_error();
  var validate = require_validate();
  var withAuthorizationPrefix = require_with_authorization_prefix();
  var deprecateAuthBasic = once((log, deprecation) => log.warn(deprecation));
  var deprecateAuthObject = once((log, deprecation) => log.warn(deprecation));
  function authenticationPlugin(octokit, options) {
    if (options.authStrategy) {
      const auth = options.authStrategy(options.auth);
      octokit.hook.wrap("request", auth.hook);
      octokit.auth = auth;
      return;
    }
    if (!options.auth) {
      octokit.auth = () => Promise.resolve({
        type: "unauthenticated"
      });
      return;
    }
    const isBasicAuthString = typeof options.auth === "string" && /^basic/.test(withAuthorizationPrefix(options.auth));
    if (typeof options.auth === "string" && !isBasicAuthString) {
      const auth = createTokenAuth(options.auth);
      octokit.hook.wrap("request", auth.hook);
      octokit.auth = auth;
      return;
    }
    const [deprecationMethod, deprecationMessapge] = isBasicAuthString ? [
      deprecateAuthBasic,
      'Setting the "new Octokit({ auth })" option to a Basic Auth string is deprecated. Use https://github.com/octokit/auth-basic.js instead. See (https://octokit.github.io/rest.js/#authentication)'
    ] : [
      deprecateAuthObject,
      'Setting the "new Octokit({ auth })" option to an object without also setting the "authStrategy" option is deprecated and will be removed in v17. See (https://octokit.github.io/rest.js/#authentication)'
    ];
    deprecationMethod(octokit.log, new Deprecation("[@octokit/rest] " + deprecationMessapge));
    octokit.auth = () => Promise.resolve({
      type: "deprecated",
      message: deprecationMessapge
    });
    validate(options.auth);
    const state = {
      octokit,
      auth: options.auth
    };
    octokit.hook.before("request", beforeRequest.bind(null, state));
    octokit.hook.error("request", requestError.bind(null, state));
  }
});

// node_modules/@octokit/rest/plugins/authentication-deprecated/authenticate.js
var require_authenticate = __commonJS((exports2, module2) => {
  module2.exports = authenticate;
  var {Deprecation} = require_dist_node4();
  var once = require_once();
  var deprecateAuthenticate = once((log, deprecation) => log.warn(deprecation));
  function authenticate(state, options) {
    deprecateAuthenticate(state.octokit.log, new Deprecation('[@octokit/rest] octokit.authenticate() is deprecated. Use "auth" constructor option instead.'));
    if (!options) {
      state.auth = false;
      return;
    }
    switch (options.type) {
      case "basic":
        if (!options.username || !options.password) {
          throw new Error("Basic authentication requires both a username and password to be set");
        }
        break;
      case "oauth":
        if (!options.token && !(options.key && options.secret)) {
          throw new Error("OAuth2 authentication requires a token or key & secret to be set");
        }
        break;
      case "token":
      case "app":
        if (!options.token) {
          throw new Error("Token authentication requires a token to be set");
        }
        break;
      default:
        throw new Error("Invalid authentication type, must be 'basic', 'oauth', 'token' or 'app'");
    }
    state.auth = options;
  }
});

// node_modules/lodash.uniq/index.js
var require_lodash3 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map");
  var Set2 = getNative(root, "Set");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function noop() {
  }
  module2.exports = uniq;
});

// node_modules/@octokit/rest/plugins/authentication-deprecated/before-request.js
var require_before_request2 = __commonJS((exports2, module2) => {
  module2.exports = authenticationBeforeRequest;
  var btoa = require_btoa_node();
  var uniq = require_lodash3();
  function authenticationBeforeRequest(state, options) {
    if (!state.auth.type) {
      return;
    }
    if (state.auth.type === "basic") {
      const hash = btoa(`${state.auth.username}:${state.auth.password}`);
      options.headers.authorization = `Basic ${hash}`;
      return;
    }
    if (state.auth.type === "token") {
      options.headers.authorization = `token ${state.auth.token}`;
      return;
    }
    if (state.auth.type === "app") {
      options.headers.authorization = `Bearer ${state.auth.token}`;
      const acceptHeaders = options.headers.accept.split(",").concat("application/vnd.github.machine-man-preview+json");
      options.headers.accept = uniq(acceptHeaders).filter(Boolean).join(",");
      return;
    }
    options.url += options.url.indexOf("?") === -1 ? "?" : "&";
    if (state.auth.token) {
      options.url += `access_token=${encodeURIComponent(state.auth.token)}`;
      return;
    }
    const key = encodeURIComponent(state.auth.key);
    const secret = encodeURIComponent(state.auth.secret);
    options.url += `client_id=${key}&client_secret=${secret}`;
  }
});

// node_modules/@octokit/rest/plugins/authentication-deprecated/request-error.js
var require_request_error2 = __commonJS((exports2, module2) => {
  module2.exports = authenticationRequestError;
  var {RequestError} = require_dist_node11();
  function authenticationRequestError(state, error, options) {
    if (!error.headers)
      throw error;
    const otpRequired = /required/.test(error.headers["x-github-otp"] || "");
    if (error.status !== 401 || !otpRequired) {
      throw error;
    }
    if (error.status === 401 && otpRequired && error.request && error.request.headers["x-github-otp"]) {
      throw new RequestError("Invalid one-time password for two-factor authentication", 401, {
        headers: error.headers,
        request: options
      });
    }
    if (typeof state.auth.on2fa !== "function") {
      throw new RequestError("2FA required, but options.on2fa is not a function. See https://github.com/octokit/rest.js#authentication", 401, {
        headers: error.headers,
        request: options
      });
    }
    return Promise.resolve().then(() => {
      return state.auth.on2fa();
    }).then((oneTimePassword) => {
      const newOptions = Object.assign(options, {
        headers: Object.assign({"x-github-otp": oneTimePassword}, options.headers)
      });
      return state.octokit.request(newOptions);
    });
  }
});

// node_modules/@octokit/rest/plugins/authentication-deprecated/index.js
var require_authentication_deprecated = __commonJS((exports2, module2) => {
  module2.exports = authenticationPlugin;
  var {Deprecation} = require_dist_node4();
  var once = require_once();
  var deprecateAuthenticate = once((log, deprecation) => log.warn(deprecation));
  var authenticate = require_authenticate();
  var beforeRequest = require_before_request2();
  var requestError = require_request_error2();
  function authenticationPlugin(octokit, options) {
    if (options.auth) {
      octokit.authenticate = () => {
        deprecateAuthenticate(octokit.log, new Deprecation('[@octokit/rest] octokit.authenticate() is deprecated and has no effect when "auth" option is set on Octokit constructor'));
      };
      return;
    }
    const state = {
      octokit,
      auth: false
    };
    octokit.authenticate = authenticate.bind(null, state);
    octokit.hook.before("request", beforeRequest.bind(null, state));
    octokit.hook.error("request", requestError.bind(null, state));
  }
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node12 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var VERSION = "1.1.2";
  var REGEX = [/^\/search\//, /^\/repos\/[^/]+\/[^/]+\/commits\/[^/]+\/(check-runs|check-suites)([^/]|$)/, /^\/installation\/repositories([^/]|$)/, /^\/user\/installations([^/]|$)/, /^\/repos\/[^/]+\/[^/]+\/actions\/secrets([^/]|$)/, /^\/repos\/[^/]+\/[^/]+\/actions\/workflows(\/[^/]+\/runs)?([^/]|$)/, /^\/repos\/[^/]+\/[^/]+\/actions\/runs(\/[^/]+\/(artifacts|jobs))?([^/]|$)/];
  function normalizePaginatedListResponse(octokit, url, response) {
    const path = url.replace(octokit.request.endpoint.DEFAULTS.baseUrl, "");
    const responseNeedsNormalization = REGEX.find((regex) => regex.test(path));
    if (!responseNeedsNormalization)
      return;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
      response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
      response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    Object.defineProperty(response.data, namespaceKey, {
      get() {
        octokit.log.warn(`[@octokit/paginate-rest] "response.data.${namespaceKey}" is deprecated for "GET ${path}". Get the results directly from "response.data"`);
        return Array.from(data);
      }
    });
  }
  function iterator(octokit, route, parameters) {
    const options = octokit.request.endpoint(route, parameters);
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
      [Symbol.asyncIterator]: () => ({
        next() {
          if (!url) {
            return Promise.resolve({
              done: true
            });
          }
          return octokit.request({
            method,
            url,
            headers
          }).then((response) => {
            normalizePaginatedListResponse(octokit, url, response);
            url = ((response.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
            return {
              value: response
            };
          });
        }
      })
    };
  }
  function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
      mapFn = parameters;
      parameters = void 0;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
  }
  function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result) => {
      if (result.done) {
        return results;
      }
      let earlyExit = false;
      function done() {
        earlyExit = true;
      }
      results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
      if (earlyExit) {
        return results;
      }
      return gather(octokit, results, iterator2, mapFn);
    });
  }
  function paginateRest(octokit) {
    return {
      paginate: Object.assign(paginate.bind(null, octokit), {
        iterator: iterator.bind(null, octokit)
      })
    };
  }
  paginateRest.VERSION = VERSION;
  exports2.paginateRest = paginateRest;
});

// node_modules/@octokit/rest/plugins/pagination/index.js
var require_pagination = __commonJS((exports2, module2) => {
  module2.exports = paginatePlugin;
  var {paginateRest} = require_dist_node12();
  function paginatePlugin(octokit) {
    Object.assign(octokit, paginateRest(octokit));
  }
});

// node_modules/lodash.get/index.js
var require_lodash4 = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var symbolTag = "[object Symbol]";
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string2) {
      result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  module2.exports = get;
});

// node_modules/lodash.set/index.js
var require_lodash5 = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var symbolTag = "[object Symbol]";
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = isKey(path, object) ? [path] : castPath(path);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index < length) {
      var key = toKey(path[index]), newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string2) {
      result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }
  module2.exports = set;
});

// node_modules/@octokit/rest/plugins/validate/validate.js
var require_validate2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = validate;
  var {RequestError} = require_dist_node11();
  var get = require_lodash4();
  var set = require_lodash5();
  function validate(octokit, options) {
    if (!options.request.validate) {
      return;
    }
    const {validate: params} = options.request;
    Object.keys(params).forEach((parameterName) => {
      const parameter = get(params, parameterName);
      const expectedType = parameter.type;
      let parentParameterName;
      let parentValue;
      let parentParamIsPresent = true;
      let parentParameterIsArray = false;
      if (/\./.test(parameterName)) {
        parentParameterName = parameterName.replace(/\.[^.]+$/, "");
        parentParameterIsArray = parentParameterName.slice(-2) === "[]";
        if (parentParameterIsArray) {
          parentParameterName = parentParameterName.slice(0, -2);
        }
        parentValue = get(options, parentParameterName);
        parentParamIsPresent = parentParameterName === "headers" || typeof parentValue === "object" && parentValue !== null;
      }
      const values = parentParameterIsArray ? (get(options, parentParameterName) || []).map((value) => value[parameterName.split(/\./).pop()]) : [get(options, parameterName)];
      values.forEach((value, i) => {
        const valueIsPresent = typeof value !== "undefined";
        const valueIsNull = value === null;
        const currentParameterName = parentParameterIsArray ? parameterName.replace(/\[\]/, `[${i}]`) : parameterName;
        if (!parameter.required && !valueIsPresent) {
          return;
        }
        if (!parentParamIsPresent) {
          return;
        }
        if (parameter.allowNull && valueIsNull) {
          return;
        }
        if (!parameter.allowNull && valueIsNull) {
          throw new RequestError(`'${currentParameterName}' cannot be null`, 400, {
            request: options
          });
        }
        if (parameter.required && !valueIsPresent) {
          throw new RequestError(`Empty value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {
            request: options
          });
        }
        if (expectedType === "integer") {
          const unparsedValue = value;
          value = parseInt(value, 10);
          if (isNaN(value)) {
            throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(unparsedValue)} is NaN`, 400, {
              request: options
            });
          }
        }
        if (parameter.enum && parameter.enum.indexOf(String(value)) === -1) {
          throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {
            request: options
          });
        }
        if (parameter.validation) {
          const regex = new RegExp(parameter.validation);
          if (!regex.test(value)) {
            throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {
              request: options
            });
          }
        }
        if (expectedType === "object" && typeof value === "string") {
          try {
            value = JSON.parse(value);
          } catch (exception) {
            throw new RequestError(`JSON parse error of value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {
              request: options
            });
          }
        }
        set(options, parameter.mapTo || currentParameterName, value);
      });
    });
    return options;
  }
});

// node_modules/@octokit/rest/plugins/validate/index.js
var require_validate3 = __commonJS((exports2, module2) => {
  module2.exports = octokitValidate;
  var validate = require_validate2();
  function octokitValidate(octokit) {
    octokit.hook.before("request", validate.bind(null, octokit));
  }
});

// node_modules/octokit-pagination-methods/lib/deprecate.js
var require_deprecate = __commonJS((exports2, module2) => {
  module2.exports = deprecate;
  var loggedMessages = {};
  function deprecate(message) {
    if (loggedMessages[message]) {
      return;
    }
    console.warn(`DEPRECATED (@octokit/rest): ${message}`);
    loggedMessages[message] = 1;
  }
});

// node_modules/octokit-pagination-methods/lib/get-page-links.js
var require_get_page_links = __commonJS((exports2, module2) => {
  module2.exports = getPageLinks;
  function getPageLinks(link) {
    link = link.link || link.headers.link || "";
    const links = {};
    link.replace(/<([^>]*)>;\s*rel="([\w]*)"/g, (m, uri, type) => {
      links[type] = uri;
    });
    return links;
  }
});

// node_modules/octokit-pagination-methods/lib/http-error.js
var require_http_error = __commonJS((exports2, module2) => {
  module2.exports = class HttpError extends Error {
    constructor(message, code, headers) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.code = code;
      this.headers = headers;
    }
  };
});

// node_modules/octokit-pagination-methods/lib/get-page.js
var require_get_page = __commonJS((exports2, module2) => {
  module2.exports = getPage;
  var deprecate = require_deprecate();
  var getPageLinks = require_get_page_links();
  var HttpError = require_http_error();
  function getPage(octokit, link, which, headers) {
    deprecate(`octokit.get${which.charAt(0).toUpperCase() + which.slice(1)}Page() \u2013 You can use octokit.paginate or async iterators instead: https://github.com/octokit/rest.js#pagination.`);
    const url = getPageLinks(link)[which];
    if (!url) {
      const urlError = new HttpError(`No ${which} page found`, 404);
      return Promise.reject(urlError);
    }
    const requestOptions = {
      url,
      headers: applyAcceptHeader(link, headers)
    };
    const promise = octokit.request(requestOptions);
    return promise;
  }
  function applyAcceptHeader(res, headers) {
    const previous = res.headers && res.headers["x-github-media-type"];
    if (!previous || headers && headers.accept) {
      return headers;
    }
    headers = headers || {};
    headers.accept = "application/vnd." + previous.replace("; param=", ".").replace("; format=", "+");
    return headers;
  }
});

// node_modules/octokit-pagination-methods/lib/get-first-page.js
var require_get_first_page = __commonJS((exports2, module2) => {
  module2.exports = getFirstPage;
  var getPage = require_get_page();
  function getFirstPage(octokit, link, headers) {
    return getPage(octokit, link, "first", headers);
  }
});

// node_modules/octokit-pagination-methods/lib/get-last-page.js
var require_get_last_page = __commonJS((exports2, module2) => {
  module2.exports = getLastPage;
  var getPage = require_get_page();
  function getLastPage(octokit, link, headers) {
    return getPage(octokit, link, "last", headers);
  }
});

// node_modules/octokit-pagination-methods/lib/get-next-page.js
var require_get_next_page = __commonJS((exports2, module2) => {
  module2.exports = getNextPage;
  var getPage = require_get_page();
  function getNextPage(octokit, link, headers) {
    return getPage(octokit, link, "next", headers);
  }
});

// node_modules/octokit-pagination-methods/lib/get-previous-page.js
var require_get_previous_page = __commonJS((exports2, module2) => {
  module2.exports = getPreviousPage;
  var getPage = require_get_page();
  function getPreviousPage(octokit, link, headers) {
    return getPage(octokit, link, "prev", headers);
  }
});

// node_modules/octokit-pagination-methods/lib/has-first-page.js
var require_has_first_page = __commonJS((exports2, module2) => {
  module2.exports = hasFirstPage;
  var deprecate = require_deprecate();
  var getPageLinks = require_get_page_links();
  function hasFirstPage(link) {
    deprecate(`octokit.hasFirstPage() \u2013 You can use octokit.paginate or async iterators instead: https://github.com/octokit/rest.js#pagination.`);
    return getPageLinks(link).first;
  }
});

// node_modules/octokit-pagination-methods/lib/has-last-page.js
var require_has_last_page = __commonJS((exports2, module2) => {
  module2.exports = hasLastPage;
  var deprecate = require_deprecate();
  var getPageLinks = require_get_page_links();
  function hasLastPage(link) {
    deprecate(`octokit.hasLastPage() \u2013 You can use octokit.paginate or async iterators instead: https://github.com/octokit/rest.js#pagination.`);
    return getPageLinks(link).last;
  }
});

// node_modules/octokit-pagination-methods/lib/has-next-page.js
var require_has_next_page = __commonJS((exports2, module2) => {
  module2.exports = hasNextPage;
  var deprecate = require_deprecate();
  var getPageLinks = require_get_page_links();
  function hasNextPage(link) {
    deprecate(`octokit.hasNextPage() \u2013 You can use octokit.paginate or async iterators instead: https://github.com/octokit/rest.js#pagination.`);
    return getPageLinks(link).next;
  }
});

// node_modules/octokit-pagination-methods/lib/has-previous-page.js
var require_has_previous_page = __commonJS((exports2, module2) => {
  module2.exports = hasPreviousPage;
  var deprecate = require_deprecate();
  var getPageLinks = require_get_page_links();
  function hasPreviousPage(link) {
    deprecate(`octokit.hasPreviousPage() \u2013 You can use octokit.paginate or async iterators instead: https://github.com/octokit/rest.js#pagination.`);
    return getPageLinks(link).prev;
  }
});

// node_modules/octokit-pagination-methods/index.js
var require_octokit_pagination_methods = __commonJS((exports2, module2) => {
  module2.exports = paginationMethodsPlugin;
  function paginationMethodsPlugin(octokit) {
    octokit.getFirstPage = require_get_first_page().bind(null, octokit);
    octokit.getLastPage = require_get_last_page().bind(null, octokit);
    octokit.getNextPage = require_get_next_page().bind(null, octokit);
    octokit.getPreviousPage = require_get_previous_page().bind(null, octokit);
    octokit.hasFirstPage = require_has_first_page();
    octokit.hasLastPage = require_has_last_page();
    octokit.hasNextPage = require_has_next_page();
    octokit.hasPreviousPage = require_has_previous_page();
  }
});

// node_modules/@octokit/rest/index.js
var require_rest = __commonJS((exports2, module2) => {
  var {requestLog} = require_dist_node7();
  var {
    restEndpointMethods
  } = require_dist_node8();
  var Core = require_core5();
  var CORE_PLUGINS = [
    require_authentication(),
    require_authentication_deprecated(),
    requestLog,
    require_pagination(),
    restEndpointMethods,
    require_validate3(),
    require_octokit_pagination_methods()
  ];
  var OctokitRest = Core.plugin(CORE_PLUGINS);
  function DeprecatedOctokit(options) {
    const warn = options && options.log && options.log.warn ? options.log.warn : console.warn;
    warn('[@octokit/rest] `const Octokit = require("@octokit/rest")` is deprecated. Use `const { Octokit } = require("@octokit/rest")` instead');
    return new OctokitRest(options);
  }
  var Octokit = Object.assign(DeprecatedOctokit, {
    Octokit: OctokitRest
  });
  Object.keys(OctokitRest).forEach((key) => {
    if (OctokitRest.hasOwnProperty(key)) {
      Octokit[key] = OctokitRest[key];
    }
  });
  module2.exports = Octokit;
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs_1 = require("fs");
  var os_1 = require("os");
  var Context = class {
    constructor() {
      this.payload = {};
      if (process.env.GITHUB_EVENT_PATH) {
        if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
          this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, {encoding: "utf8"}));
        } else {
          process.stdout.write(`GITHUB_EVENT_PATH ${process.env.GITHUB_EVENT_PATH} does not exist${os_1.EOL}`);
        }
      }
      this.eventName = process.env.GITHUB_EVENT_NAME;
      this.sha = process.env.GITHUB_SHA;
      this.ref = process.env.GITHUB_REF;
      this.workflow = process.env.GITHUB_WORKFLOW;
      this.action = process.env.GITHUB_ACTION;
      this.actor = process.env.GITHUB_ACTOR;
    }
    get issue() {
      const payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), {number: (payload.issue || payload.pullRequest || payload).number});
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return {owner, repo};
      }
      if (this.payload.repository) {
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      }
      throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  };
  exports2.Context = Context;
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var graphql_1 = require_graphql2();
  var rest_1 = __importDefault(require_rest());
  var Context = __importStar(require_context());
  rest_1.default.prototype = new rest_1.default();
  exports2.context = new Context.Context();
  var GitHub = class extends rest_1.default {
    constructor(token, opts = {}) {
      super(Object.assign(Object.assign({}, opts), {auth: `token ${token}`}));
      this.graphql = graphql_1.defaults({
        headers: {authorization: `token ${token}`}
      });
    }
  };
  exports2.GitHub = GitHub;
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  Object.defineProperty(exports2, "__esModule", {value: true});
  var assert_1 = require("assert");
  var fs = require("fs");
  var path = require("path");
  _a = fs.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
  exports2.IS_WINDOWS = process.platform === "win32";
  function exists(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield exports2.stat(fsPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
      return true;
    });
  }
  exports2.exists = exists;
  function isDirectory(fsPath, useStat = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const stats = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
      return stats.isDirectory();
    });
  }
  exports2.isDirectory = isDirectory;
  function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
      throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports2.IS_WINDOWS) {
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    }
    return p.startsWith("/");
  }
  exports2.isRooted = isRooted;
  function mkdirP(fsPath, maxDepth = 1e3, depth = 1) {
    return __awaiter(this, void 0, void 0, function* () {
      assert_1.ok(fsPath, "a path argument must be provided");
      fsPath = path.resolve(fsPath);
      if (depth >= maxDepth)
        return exports2.mkdir(fsPath);
      try {
        yield exports2.mkdir(fsPath);
        return;
      } catch (err) {
        switch (err.code) {
          case "ENOENT": {
            yield mkdirP(path.dirname(fsPath), maxDepth, depth + 1);
            yield exports2.mkdir(fsPath);
            return;
          }
          default: {
            let stats;
            try {
              stats = yield exports2.stat(fsPath);
            } catch (err2) {
              throw err;
            }
            if (!stats.isDirectory())
              throw err;
          }
        }
      }
    });
  }
  exports2.mkdirP = mkdirP;
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, void 0, void 0, function* () {
      let stats = void 0;
      try {
        stats = yield exports2.stat(filePath);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
      }
      if (stats && stats.isFile()) {
        if (exports2.IS_WINDOWS) {
          const upperExt = path.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
            return filePath;
          }
        } else {
          if (isUnixExecutable(stats)) {
            return filePath;
          }
        }
      }
      const originalFilePath = filePath;
      for (const extension of extensions) {
        filePath = originalFilePath + extension;
        stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            try {
              const directory = path.dirname(filePath);
              const upperName = path.basename(filePath).toUpperCase();
              for (const actualName of yield exports2.readdir(directory)) {
                if (upperName === actualName.toUpperCase()) {
                  filePath = path.join(directory, actualName);
                  break;
                }
              }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
      }
      return "";
    });
  }
  exports2.tryGetExecutablePath = tryGetExecutablePath;
  function normalizeSeparators(p) {
    p = p || "";
    if (exports2.IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      return p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var childProcess = require("child_process");
  var path = require("path");
  var util_1 = require("util");
  var ioUtil = require_io_util();
  var exec = util_1.promisify(childProcess.exec);
  function cp(source, dest, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const {force, recursive} = readCopyOptions(options);
      const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(source)) : dest;
      if (!(yield ioUtil.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  exports2.cp = cp;
  function mv(source, dest, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      if (yield ioUtil.exists(dest)) {
        let destExists = true;
        if (yield ioUtil.isDirectory(dest)) {
          dest = path.join(dest, path.basename(source));
          destExists = yield ioUtil.exists(dest);
        }
        if (destExists) {
          if (options.force == null || options.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path.dirname(dest));
      yield ioUtil.rename(source, dest);
    });
  }
  exports2.mv = mv;
  function rmRF(inputPath) {
    return __awaiter(this, void 0, void 0, function* () {
      if (ioUtil.IS_WINDOWS) {
        try {
          if (yield ioUtil.isDirectory(inputPath, true)) {
            yield exec(`rd /s /q "${inputPath}"`);
          } else {
            yield exec(`del /f /a "${inputPath}"`);
          }
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
        try {
          yield ioUtil.unlink(inputPath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      } else {
        let isDir = false;
        try {
          isDir = yield ioUtil.isDirectory(inputPath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
          return;
        }
        if (isDir) {
          yield exec(`rm -rf "${inputPath}"`);
        } else {
          yield ioUtil.unlink(inputPath);
        }
      }
    });
  }
  exports2.rmRF = rmRF;
  function mkdirP(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
      yield ioUtil.mkdirP(fsPath);
    });
  }
  exports2.mkdirP = mkdirP;
  function which(tool, check) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result = yield which(tool, false);
        if (!result) {
          if (ioUtil.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
      }
      try {
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env.PATHEXT) {
          for (const extension of process.env.PATHEXT.split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return filePath;
          }
          return "";
        }
        if (tool.includes("/") || ioUtil.IS_WINDOWS && tool.includes("\\")) {
          return "";
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(directory + path.sep + tool, extensions);
          if (filePath) {
            return filePath;
          }
        }
        return "";
      } catch (err) {
        throw new Error(`which failed with message ${err.message}`);
      }
    });
  }
  exports2.which = which;
  function readCopyOptions(options) {
    const force = options.force == null ? true : options.force;
    const recursive = Boolean(options.recursive);
    return {force, recursive};
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, void 0, void 0, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, void 0, void 0, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile);
          yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil.chmod(destFile, "0666");
            yield ioUtil.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force) {
        yield ioUtil.copyFile(srcFile, destFile);
      }
    });
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var os = __importStar(require("os"));
  var events = __importStar(require("events"));
  var child = __importStar(require("child_process"));
  var path = __importStar(require("path"));
  var io = __importStar(require_io());
  var ioUtil = __importStar(require_io_util());
  var IS_WINDOWS = process.platform === "win32";
  var ToolRunner = class extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message);
      }
    }
    _getCommandString(options, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a of args) {
          cmd += ` ${a}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n = s.indexOf(os.EOL);
        while (n > -1) {
          const line = s.substring(0, n);
          onLine(line);
          s = s.substring(n + os.EOL.length);
          n = s.indexOf(os.EOL);
        }
        strBuffer = s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a of this.args) {
            argline += " ";
            argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "	",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length; i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length; i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      const result = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || false,
        windowsVerbatimArguments: options.windowsVerbatimArguments || false,
        failOnStdErr: options.failOnStdErr || false,
        ignoreReturnCode: options.ignoreReturnCode || false,
        delay: options.delay || 1e4
      };
      result.outStream = options.outStream || process.stdout;
      result.errStream = options.errStream || process.stderr;
      return result;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      const result = {};
      result.cwd = options.cwd;
      result.env = options.env;
      result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
      if (options.windowsVerbatimArguments) {
        result.argv0 = `"${toolPath}"`;
      }
      return result;
    }
    exec() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io.which(this.toolPath, true);
        return new Promise((resolve, reject) => {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message) => {
            this._debug(message);
          });
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          const stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          const errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state.processError = err.message;
            state.processExited = true;
            state.processClosed = true;
            state.CheckComplete();
          });
          cp.on("exit", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          cp.on("close", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            state.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          state.on("done", (error, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error) {
              reject(error);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        });
      });
    }
  };
  exports2.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c) {
      if (escaped && c !== '"') {
        arg += "\\";
      }
      arg += c;
      escaped = false;
    }
    for (let i = 0; i < argString.length; i++) {
      const c = argString.charAt(i);
      if (c === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c);
        }
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }
  exports2.argStringToArray = argStringToArray;
  var ExecState = class extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options;
      this.toolPath = toolPath;
      if (options.delay) {
        this.delay = options.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = setTimeout(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error;
      if (this.processExited) {
        if (this.processError) {
          error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done) {
        return;
      }
      if (!state.processClosed && state.processExited) {
        const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message);
      }
      state._setResult();
    }
  };
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options);
      return runner.exec();
    });
  }
  exports2.exec = exec;
});

// src/git.js
var require_git = __commonJS((exports2, module2) => {
  var {context, GitHub} = require_github();
  var {exec: _exec} = require_exec();
  var SEPARATOR = "==============================================";
  async function exec(command, args) {
    let stdout = "";
    let stderr = "";
    try {
      const options = {
        listeners: {
          stdout: (data) => {
            stdout += data.toString();
          },
          stderr: (data) => {
            stderr += data.toString();
          }
        }
      };
      const code = await _exec(command, args, options);
      return {
        code,
        stdout,
        stderr
      };
    } catch (err) {
      return {
        code: 1,
        stdout,
        stderr,
        error: err
      };
    }
  }
  async function getPreviousTagSha2(tagPrefix) {
    return (await exec(`git rev-list --tags=${tagPrefix}* --topo-order --max-count=1`)).stdout.trim();
  }
  async function getTag2(previousTagSha) {
    return (await exec(`git describe --tags ${previousTagSha}`)).stdout.trim();
  }
  async function fetchTags2() {
    await exec("git fetch --tags");
    return await exec("git tag");
  }
  async function getCommits2(fromTag) {
    let logs = "";
    if (fromTag) {
      logs = (await exec(`git log ${fromTag}..HEAD --pretty=format:'%s%n%b${SEPARATOR}' --abbrev-commit`)).stdout.trim();
    } else {
      logs = (await exec(`git log --pretty=format:'%s%n%b${SEPARATOR}' --abbrev-commit`)).stdout.trim();
    }
    return logs.split(SEPARATOR).map((x) => ({message: x.trim().replace(/(^['\s]+)|(['\s]+$)/g, "")})).filter((x) => !!x.message);
  }
  async function checkTagExists2(tag) {
    return !!(await exec(`git tag -l "${tag}"`)).stdout.trim();
  }
  async function createTag2(github_token, GITHUB_SHA, tagName, annotated) {
    const octokit = new GitHub(github_token);
    if (annotated) {
      console.log(`Creating annotated tag`);
      const tagCreateResponse = await octokit.git.createTag({
        ...context.repo,
        tag: tagName,
        message: tagName,
        object: GITHUB_SHA,
        type: "commit"
      });
      console.log(`Pushing annotated tag to the repo`);
      await octokit.git.createRef({
        ...context.repo,
        ref: `refs/tags/${tagName}`,
        sha: tagCreateResponse.data.sha
      });
      return;
    } else {
      console.log(`Pushing new lightweight tag to the repo`);
      await octokit.git.createRef({
        ...context.repo,
        ref: `refs/tags/${tagName}`,
        sha: GITHUB_SHA
      });
    }
  }
  async function gitDescribe() {
    return (await exec(`git describe --tags`)).stdout.trim();
  }
  module2.exports = {
    createTag: createTag2,
    checkTagExists: checkTagExists2,
    getCommits: getCommits2,
    getTag: getTag2,
    fetchTags: fetchTags2,
    getPreviousTagSha: getPreviousTagSha2,
    gitDescribe
  };
});

// src/utils.js
var require_utils11 = __commonJS((exports2, module2) => {
  var semver = require_semver();
  var {gitDescribe} = require_git();
  var BranchePrefix = {
    master: "v",
    stage: "s",
    dev: "d"
  };
  async function calculateVersion(tag, branch, bump, preRelease, defaultBump = "patch") {
    let newVersion = "";
    let newTag = "";
    if (preRelease) {
      console.log(`Prerelease on branch ${branch}`);
      const describe = await gitDescribe();
      const dissect = describe.split("-");
      const tag2 = dissect[0];
      const inc = dissect[1];
      const hash = dissect[2];
      newTag = `${tag2}-${branch}-${inc}-${hash}`;
    } else {
      let prefix = BranchePrefix[branch] ? BranchePrefix[branch] : branch[0];
      const rawVersion = tag.replace(prefix, "");
      const incResult = semver.inc(rawVersion, bump || defaultBump);
      console.log(`SemVer.inc(${rawVersion}, ${bump || defaultBump}): ${incResult}`);
      if (!incResult) {
        throw new Error("`SemVer inc rejected tag ${tag}`");
      }
      newVersion = `${incResult}`;
      newTag = `${prefix}${newVersion}`;
    }
    return {newVersion, newTag};
  }
  module2.exports = {calculateVersion};
});

// index.js
var core = require_core();
var {analyzeCommits} = require_commit_analyzer();
var {generateNotes} = require_release_notes_generator();
var branch_fetcher = require_git_branch();
var utils = require_utils11();
var {getPreviousTagSha, getTag, getCommits, checkTagExists, createTag, fetchTags} = require_git();
async function run() {
  try {
    const defaultBump = core.getInput("default_bump");
    const messageParserPreset = core.getInput("message_parser_preset");
    const tagPrefix = core.getInput("tag_prefix");
    const releaseBranches = core.getInput("release_branches");
    const createAnnotatedTag = core.getInput("create_annotated_tag");
    const dryRun = core.getInput("dry_run");
    const {GITHUB_REF, GITHUB_SHA} = process.env;
    if (!GITHUB_REF) {
      core.setFailed("Missing GITHUB_REF");
      return;
    }
    if (!GITHUB_SHA) {
      core.setFailed("Missing GITHUB_SHA");
      return;
    }
    const branch = branch_fetcher.sync();
    core.info(`Triggered on branch ${branch}`);
    const preRelease = releaseBranches.split(",").every((releaseBranch) => !branch.match(releaseBranch));
    core.info(`Pre release branch: ${preRelease}`);
    core.setOutput("preRelease", preRelease);
    const hasTag = !!(await fetchTags()).stdout.trim();
    let tag = "";
    let commits = [];
    if (hasTag) {
      const previousTagSha = await getPreviousTagSha(tagPrefix);
      tag = await getTag(previousTagSha);
      commits = await getCommits(tag);
      if (previousTagSha === GITHUB_SHA) {
        core.debug("No new commits since previous tag. Skipping...");
        core.setOutput("previous_tag", tag);
        return;
      }
    } else {
      tag = "0.0.0";
      commits = await getCommits();
      core.setOutput("previous_tag", tag);
    }
    console.info(`Current tag is ${tag}`);
    core.debug(`Commits: ${commits}`);
    var bump = await analyzeCommits({preset: messageParserPreset || "conventionalcommits"}, {commits, logger: {log: console.info.bind(console)}});
    core.debug(`Bump type from commits: ${bump}`);
    bump = bump || defaultBump;
    core.info(`Effective bump type: ${bump}`);
    if (!bump) {
      core.setFailed(`Nothing to bump - not building release`);
      return;
    }
    const {newVersion, newTag} = await utils.calculateVersion(tag, branch, bump, preRelease, defaultBump);
    core.setOutput("new_version", newVersion);
    core.setOutput("new_tag", newTag);
    core.debug(`New tag: ${newTag}`);
    const changelog = await generateNotes({}, {
      commits,
      logger: {log: console.info.bind(console)},
      options: {
        repositoryUrl: `https://github.com/${process.env.GITHUB_REPOSITORY}`
      },
      lastRelease: {gitTag: tag},
      nextRelease: {gitTag: newTag, version: newVersion}
    });
    core.setOutput("changelog", changelog);
    if (preRelease) {
      core.debug("This branch is not a release branch. Skipping the tag creation.");
      return;
    }
    if (await checkTagExists(newTag)) {
      core.debug("This tag already exists. Skipping the tag creation.");
      return;
    }
    core.info("dry_run: " + dryRun + " (" + typeof dryRun + ")");
    if (dryRun === "true") {
      core.setOutput("dry_run", "true");
      core.info("Dry run: not performing tag action.");
      return;
    }
    if (createAnnotatedTag === "true") {
      core.debug(`Creating annotated tag`);
      await createTag(core.getInput("github_token"), GITHUB_SHA, newTag, true);
    } else {
      core.debug(`Pushing new tag to the repo`);
      await createTag(core.getInput("github_token"), GITHUB_SHA, newTag, false);
    }
  } catch (error) {
    core.setFailed(error.message);
  }
}
run();
